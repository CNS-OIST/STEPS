# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_steps_swig', [dirname(__file__)])
        except ImportError:
            import _steps_swig
            return _steps_swig
        if fp is not None:
            try:
                _mod = imp.load_module('_steps_swig', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _steps_swig = swig_import_helper()
    del swig_import_helper
else:
    import _steps_swig
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _steps_swig.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self): return _steps_swig.SwigPyIterator_value(self)
    def incr(self, n=1): return _steps_swig.SwigPyIterator_incr(self, n)
    def decr(self, n=1): return _steps_swig.SwigPyIterator_decr(self, n)
    def distance(self, *args): return _steps_swig.SwigPyIterator_distance(self, *args)
    def equal(self, *args): return _steps_swig.SwigPyIterator_equal(self, *args)
    def copy(self): return _steps_swig.SwigPyIterator_copy(self)
    def next(self): return _steps_swig.SwigPyIterator_next(self)
    def __next__(self): return _steps_swig.SwigPyIterator___next__(self)
    def previous(self): return _steps_swig.SwigPyIterator_previous(self)
    def advance(self, *args): return _steps_swig.SwigPyIterator_advance(self, *args)
    def __eq__(self, *args): return _steps_swig.SwigPyIterator___eq__(self, *args)
    def __ne__(self, *args): return _steps_swig.SwigPyIterator___ne__(self, *args)
    def __iadd__(self, *args): return _steps_swig.SwigPyIterator___iadd__(self, *args)
    def __isub__(self, *args): return _steps_swig.SwigPyIterator___isub__(self, *args)
    def __add__(self, *args): return _steps_swig.SwigPyIterator___add__(self, *args)
    def __sub__(self, *args): return _steps_swig.SwigPyIterator___sub__(self, *args)
    def __iter__(self): return self
SwigPyIterator_swigregister = _steps_swig.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class Err(_object):
    """Proxy of C++ steps::Err class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Err, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Err, name)
    __repr__ = _swig_repr
    def __init__(self, msg=""): 
        """
        __init__(steps::Err self, std::string const & msg="") -> Err
        __init__(steps::Err self) -> Err
        """
        this = _steps_swig.new_Err(msg)
        try: self.this.append(this)
        except: self.this = this
    def getMsg(self):
        """getMsg(Err self) -> char const *"""
        return _steps_swig.Err_getMsg(self)

    __swig_destroy__ = _steps_swig.delete_Err
    __del__ = lambda self : None;
Err_swigregister = _steps_swig.Err_swigregister
Err_swigregister(Err)

class ArgErr(Err):
    """Proxy of C++ steps::ArgErr class"""
    __swig_setmethods__ = {}
    for _s in [Err]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ArgErr, name, value)
    __swig_getmethods__ = {}
    for _s in [Err]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ArgErr, name)
    __repr__ = _swig_repr
    def __init__(self, msg=""): 
        """
        __init__(steps::ArgErr self, std::string const & msg="") -> ArgErr
        __init__(steps::ArgErr self) -> ArgErr
        """
        this = _steps_swig.new_ArgErr(msg)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_ArgErr
    __del__ = lambda self : None;
ArgErr_swigregister = _steps_swig.ArgErr_swigregister
ArgErr_swigregister(ArgErr)

class NotImplErr(Err):
    """Proxy of C++ steps::NotImplErr class"""
    __swig_setmethods__ = {}
    for _s in [Err]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NotImplErr, name, value)
    __swig_getmethods__ = {}
    for _s in [Err]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, NotImplErr, name)
    __repr__ = _swig_repr
    def __init__(self, msg=""): 
        """
        __init__(steps::NotImplErr self, std::string const & msg="") -> NotImplErr
        __init__(steps::NotImplErr self) -> NotImplErr
        """
        this = _steps_swig.new_NotImplErr(msg)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_NotImplErr
    __del__ = lambda self : None;
NotImplErr_swigregister = _steps_swig.NotImplErr_swigregister
NotImplErr_swigregister(NotImplErr)

class ProgErr(Err):
    """Proxy of C++ steps::ProgErr class"""
    __swig_setmethods__ = {}
    for _s in [Err]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ProgErr, name, value)
    __swig_getmethods__ = {}
    for _s in [Err]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ProgErr, name)
    __repr__ = _swig_repr
    def __init__(self, msg=""): 
        """
        __init__(steps::ProgErr self, std::string const & msg="") -> ProgErr
        __init__(steps::ProgErr self) -> ProgErr
        """
        this = _steps_swig.new_ProgErr(msg)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_ProgErr
    __del__ = lambda self : None;
ProgErr_swigregister = _steps_swig.ProgErr_swigregister
ProgErr_swigregister(ProgErr)

class vector_dbl(_object):
    """Proxy of C++ std::vector<(double)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_dbl, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_dbl, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(vector_dbl self) -> SwigPyIterator"""
        return _steps_swig.vector_dbl_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(vector_dbl self) -> bool"""
        return _steps_swig.vector_dbl___nonzero__(self)

    def __bool__(self):
        """__bool__(vector_dbl self) -> bool"""
        return _steps_swig.vector_dbl___bool__(self)

    def __len__(self):
        """__len__(vector_dbl self) -> std::vector< double >::size_type"""
        return _steps_swig.vector_dbl___len__(self)

    def pop(self):
        """pop(vector_dbl self) -> std::vector< double >::value_type"""
        return _steps_swig.vector_dbl_pop(self)

    def __getslice__(self, *args):
        """__getslice__(vector_dbl self, std::vector< double >::difference_type i, std::vector< double >::difference_type j) -> vector_dbl"""
        return _steps_swig.vector_dbl___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(vector_dbl self, std::vector< double >::difference_type i, std::vector< double >::difference_type j, 
            vector_dbl v=std::vector< double,std::allocator< double > >())
        __setslice__(vector_dbl self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)
        """
        return _steps_swig.vector_dbl___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(vector_dbl self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)"""
        return _steps_swig.vector_dbl___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(vector_dbl self, std::vector< double >::difference_type i)
        __delitem__(vector_dbl self, PySliceObject * slice)
        """
        return _steps_swig.vector_dbl___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(vector_dbl self, PySliceObject * slice) -> vector_dbl
        __getitem__(vector_dbl self, std::vector< double >::difference_type i) -> std::vector< double >::value_type const &
        """
        return _steps_swig.vector_dbl___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(vector_dbl self, PySliceObject * slice, vector_dbl v)
        __setitem__(vector_dbl self, PySliceObject * slice)
        __setitem__(vector_dbl self, std::vector< double >::difference_type i, std::vector< double >::value_type const & x)
        """
        return _steps_swig.vector_dbl___setitem__(self, *args)

    def append(self, *args):
        """append(vector_dbl self, std::vector< double >::value_type const & x)"""
        return _steps_swig.vector_dbl_append(self, *args)

    def empty(self):
        """empty(vector_dbl self) -> bool"""
        return _steps_swig.vector_dbl_empty(self)

    def size(self):
        """size(vector_dbl self) -> std::vector< double >::size_type"""
        return _steps_swig.vector_dbl_size(self)

    def clear(self):
        """clear(vector_dbl self)"""
        return _steps_swig.vector_dbl_clear(self)

    def swap(self, *args):
        """swap(vector_dbl self, vector_dbl v)"""
        return _steps_swig.vector_dbl_swap(self, *args)

    def get_allocator(self):
        """get_allocator(vector_dbl self) -> std::vector< double >::allocator_type"""
        return _steps_swig.vector_dbl_get_allocator(self)

    def begin(self):
        """begin(vector_dbl self) -> std::vector< double >::iterator"""
        return _steps_swig.vector_dbl_begin(self)

    def end(self):
        """end(vector_dbl self) -> std::vector< double >::iterator"""
        return _steps_swig.vector_dbl_end(self)

    def rbegin(self):
        """rbegin(vector_dbl self) -> std::vector< double >::reverse_iterator"""
        return _steps_swig.vector_dbl_rbegin(self)

    def rend(self):
        """rend(vector_dbl self) -> std::vector< double >::reverse_iterator"""
        return _steps_swig.vector_dbl_rend(self)

    def pop_back(self):
        """pop_back(vector_dbl self)"""
        return _steps_swig.vector_dbl_pop_back(self)

    def erase(self, *args):
        """
        erase(vector_dbl self, std::vector< double >::iterator pos) -> std::vector< double >::iterator
        erase(vector_dbl self, std::vector< double >::iterator first, std::vector< double >::iterator last) -> std::vector< double >::iterator
        """
        return _steps_swig.vector_dbl_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(double)> self) -> vector_dbl
        __init__(std::vector<(double)> self, vector_dbl arg2) -> vector_dbl
        __init__(std::vector<(double)> self, std::vector< double >::size_type size) -> vector_dbl
        __init__(std::vector<(double)> self, std::vector< double >::size_type size, std::vector< double >::value_type const & value) -> vector_dbl
        """
        this = _steps_swig.new_vector_dbl(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(vector_dbl self, std::vector< double >::value_type const & x)"""
        return _steps_swig.vector_dbl_push_back(self, *args)

    def front(self):
        """front(vector_dbl self) -> std::vector< double >::value_type const &"""
        return _steps_swig.vector_dbl_front(self)

    def back(self):
        """back(vector_dbl self) -> std::vector< double >::value_type const &"""
        return _steps_swig.vector_dbl_back(self)

    def assign(self, *args):
        """assign(vector_dbl self, std::vector< double >::size_type n, std::vector< double >::value_type const & x)"""
        return _steps_swig.vector_dbl_assign(self, *args)

    def resize(self, *args):
        """
        resize(vector_dbl self, std::vector< double >::size_type new_size)
        resize(vector_dbl self, std::vector< double >::size_type new_size, std::vector< double >::value_type const & x)
        """
        return _steps_swig.vector_dbl_resize(self, *args)

    def insert(self, *args):
        """
        insert(vector_dbl self, std::vector< double >::iterator pos, std::vector< double >::value_type const & x) -> std::vector< double >::iterator
        insert(vector_dbl self, std::vector< double >::iterator pos, std::vector< double >::size_type n, std::vector< double >::value_type const & x)
        """
        return _steps_swig.vector_dbl_insert(self, *args)

    def reserve(self, *args):
        """reserve(vector_dbl self, std::vector< double >::size_type n)"""
        return _steps_swig.vector_dbl_reserve(self, *args)

    def capacity(self):
        """capacity(vector_dbl self) -> std::vector< double >::size_type"""
        return _steps_swig.vector_dbl_capacity(self)

    __swig_destroy__ = _steps_swig.delete_vector_dbl
    __del__ = lambda self : None;
vector_dbl_swigregister = _steps_swig.vector_dbl_swigregister
vector_dbl_swigregister(vector_dbl)

class vector_chn(_object):
    """Proxy of C++ std::vector<(p.steps::model::Chan)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_chn, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_chn, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(vector_chn self) -> SwigPyIterator"""
        return _steps_swig.vector_chn_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(vector_chn self) -> bool"""
        return _steps_swig.vector_chn___nonzero__(self)

    def __bool__(self):
        """__bool__(vector_chn self) -> bool"""
        return _steps_swig.vector_chn___bool__(self)

    def __len__(self):
        """__len__(vector_chn self) -> std::vector< steps::model::Chan * >::size_type"""
        return _steps_swig.vector_chn___len__(self)

    def pop(self):
        """pop(vector_chn self) -> Chan"""
        return _steps_swig.vector_chn_pop(self)

    def __getslice__(self, *args):
        """__getslice__(vector_chn self, std::vector< steps::model::Chan * >::difference_type i, std::vector< steps::model::Chan * >::difference_type j) -> vector_chn"""
        return _steps_swig.vector_chn___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(vector_chn self, std::vector< steps::model::Chan * >::difference_type i, std::vector< steps::model::Chan * >::difference_type j, 
            vector_chn v=std::vector< steps::model::Chan *,std::allocator< steps::model::Chan * > >())
        __setslice__(vector_chn self, std::vector< steps::model::Chan * >::difference_type i, std::vector< steps::model::Chan * >::difference_type j)
        """
        return _steps_swig.vector_chn___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(vector_chn self, std::vector< steps::model::Chan * >::difference_type i, std::vector< steps::model::Chan * >::difference_type j)"""
        return _steps_swig.vector_chn___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(vector_chn self, std::vector< steps::model::Chan * >::difference_type i)
        __delitem__(vector_chn self, PySliceObject * slice)
        """
        return _steps_swig.vector_chn___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(vector_chn self, PySliceObject * slice) -> vector_chn
        __getitem__(vector_chn self, std::vector< steps::model::Chan * >::difference_type i) -> Chan
        """
        return _steps_swig.vector_chn___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(vector_chn self, PySliceObject * slice, vector_chn v)
        __setitem__(vector_chn self, PySliceObject * slice)
        __setitem__(vector_chn self, std::vector< steps::model::Chan * >::difference_type i, Chan x)
        """
        return _steps_swig.vector_chn___setitem__(self, *args)

    def append(self, *args):
        """append(vector_chn self, Chan x)"""
        return _steps_swig.vector_chn_append(self, *args)

    def empty(self):
        """empty(vector_chn self) -> bool"""
        return _steps_swig.vector_chn_empty(self)

    def size(self):
        """size(vector_chn self) -> std::vector< steps::model::Chan * >::size_type"""
        return _steps_swig.vector_chn_size(self)

    def clear(self):
        """clear(vector_chn self)"""
        return _steps_swig.vector_chn_clear(self)

    def swap(self, *args):
        """swap(vector_chn self, vector_chn v)"""
        return _steps_swig.vector_chn_swap(self, *args)

    def get_allocator(self):
        """get_allocator(vector_chn self) -> std::vector< steps::model::Chan * >::allocator_type"""
        return _steps_swig.vector_chn_get_allocator(self)

    def begin(self):
        """begin(vector_chn self) -> std::vector< steps::model::Chan * >::iterator"""
        return _steps_swig.vector_chn_begin(self)

    def end(self):
        """end(vector_chn self) -> std::vector< steps::model::Chan * >::iterator"""
        return _steps_swig.vector_chn_end(self)

    def rbegin(self):
        """rbegin(vector_chn self) -> std::vector< steps::model::Chan * >::reverse_iterator"""
        return _steps_swig.vector_chn_rbegin(self)

    def rend(self):
        """rend(vector_chn self) -> std::vector< steps::model::Chan * >::reverse_iterator"""
        return _steps_swig.vector_chn_rend(self)

    def pop_back(self):
        """pop_back(vector_chn self)"""
        return _steps_swig.vector_chn_pop_back(self)

    def erase(self, *args):
        """
        erase(vector_chn self, std::vector< steps::model::Chan * >::iterator pos) -> std::vector< steps::model::Chan * >::iterator
        erase(vector_chn self, std::vector< steps::model::Chan * >::iterator first, std::vector< steps::model::Chan * >::iterator last) -> std::vector< steps::model::Chan * >::iterator
        """
        return _steps_swig.vector_chn_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(p.steps::model::Chan)> self) -> vector_chn
        __init__(std::vector<(p.steps::model::Chan)> self, vector_chn arg2) -> vector_chn
        __init__(std::vector<(p.steps::model::Chan)> self, std::vector< steps::model::Chan * >::size_type size) -> vector_chn
        __init__(std::vector<(p.steps::model::Chan)> self, std::vector< steps::model::Chan * >::size_type size, Chan value) -> vector_chn
        """
        this = _steps_swig.new_vector_chn(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(vector_chn self, Chan x)"""
        return _steps_swig.vector_chn_push_back(self, *args)

    def front(self):
        """front(vector_chn self) -> Chan"""
        return _steps_swig.vector_chn_front(self)

    def back(self):
        """back(vector_chn self) -> Chan"""
        return _steps_swig.vector_chn_back(self)

    def assign(self, *args):
        """assign(vector_chn self, std::vector< steps::model::Chan * >::size_type n, Chan x)"""
        return _steps_swig.vector_chn_assign(self, *args)

    def resize(self, *args):
        """
        resize(vector_chn self, std::vector< steps::model::Chan * >::size_type new_size)
        resize(vector_chn self, std::vector< steps::model::Chan * >::size_type new_size, Chan x)
        """
        return _steps_swig.vector_chn_resize(self, *args)

    def insert(self, *args):
        """
        insert(vector_chn self, std::vector< steps::model::Chan * >::iterator pos, Chan x) -> std::vector< steps::model::Chan * >::iterator
        insert(vector_chn self, std::vector< steps::model::Chan * >::iterator pos, std::vector< steps::model::Chan * >::size_type n, 
            Chan x)
        """
        return _steps_swig.vector_chn_insert(self, *args)

    def reserve(self, *args):
        """reserve(vector_chn self, std::vector< steps::model::Chan * >::size_type n)"""
        return _steps_swig.vector_chn_reserve(self, *args)

    def capacity(self):
        """capacity(vector_chn self) -> std::vector< steps::model::Chan * >::size_type"""
        return _steps_swig.vector_chn_capacity(self)

    __swig_destroy__ = _steps_swig.delete_vector_chn
    __del__ = lambda self : None;
vector_chn_swigregister = _steps_swig.vector_chn_swigregister
vector_chn_swigregister(vector_chn)

class vector_cst(_object):
    """Proxy of C++ std::vector<(p.steps::model::ChanState)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_cst, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_cst, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(vector_cst self) -> SwigPyIterator"""
        return _steps_swig.vector_cst_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(vector_cst self) -> bool"""
        return _steps_swig.vector_cst___nonzero__(self)

    def __bool__(self):
        """__bool__(vector_cst self) -> bool"""
        return _steps_swig.vector_cst___bool__(self)

    def __len__(self):
        """__len__(vector_cst self) -> std::vector< steps::model::ChanState * >::size_type"""
        return _steps_swig.vector_cst___len__(self)

    def pop(self):
        """pop(vector_cst self) -> ChanState"""
        return _steps_swig.vector_cst_pop(self)

    def __getslice__(self, *args):
        """__getslice__(vector_cst self, std::vector< steps::model::ChanState * >::difference_type i, std::vector< steps::model::ChanState * >::difference_type j) -> vector_cst"""
        return _steps_swig.vector_cst___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(vector_cst self, std::vector< steps::model::ChanState * >::difference_type i, std::vector< steps::model::ChanState * >::difference_type j, 
            vector_cst v=std::vector< steps::model::ChanState *,std::allocator< steps::model::ChanState * > >())
        __setslice__(vector_cst self, std::vector< steps::model::ChanState * >::difference_type i, std::vector< steps::model::ChanState * >::difference_type j)
        """
        return _steps_swig.vector_cst___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(vector_cst self, std::vector< steps::model::ChanState * >::difference_type i, std::vector< steps::model::ChanState * >::difference_type j)"""
        return _steps_swig.vector_cst___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(vector_cst self, std::vector< steps::model::ChanState * >::difference_type i)
        __delitem__(vector_cst self, PySliceObject * slice)
        """
        return _steps_swig.vector_cst___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(vector_cst self, PySliceObject * slice) -> vector_cst
        __getitem__(vector_cst self, std::vector< steps::model::ChanState * >::difference_type i) -> ChanState
        """
        return _steps_swig.vector_cst___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(vector_cst self, PySliceObject * slice, vector_cst v)
        __setitem__(vector_cst self, PySliceObject * slice)
        __setitem__(vector_cst self, std::vector< steps::model::ChanState * >::difference_type i, ChanState x)
        """
        return _steps_swig.vector_cst___setitem__(self, *args)

    def append(self, *args):
        """append(vector_cst self, ChanState x)"""
        return _steps_swig.vector_cst_append(self, *args)

    def empty(self):
        """empty(vector_cst self) -> bool"""
        return _steps_swig.vector_cst_empty(self)

    def size(self):
        """size(vector_cst self) -> std::vector< steps::model::ChanState * >::size_type"""
        return _steps_swig.vector_cst_size(self)

    def clear(self):
        """clear(vector_cst self)"""
        return _steps_swig.vector_cst_clear(self)

    def swap(self, *args):
        """swap(vector_cst self, vector_cst v)"""
        return _steps_swig.vector_cst_swap(self, *args)

    def get_allocator(self):
        """get_allocator(vector_cst self) -> std::vector< steps::model::ChanState * >::allocator_type"""
        return _steps_swig.vector_cst_get_allocator(self)

    def begin(self):
        """begin(vector_cst self) -> std::vector< steps::model::ChanState * >::iterator"""
        return _steps_swig.vector_cst_begin(self)

    def end(self):
        """end(vector_cst self) -> std::vector< steps::model::ChanState * >::iterator"""
        return _steps_swig.vector_cst_end(self)

    def rbegin(self):
        """rbegin(vector_cst self) -> std::vector< steps::model::ChanState * >::reverse_iterator"""
        return _steps_swig.vector_cst_rbegin(self)

    def rend(self):
        """rend(vector_cst self) -> std::vector< steps::model::ChanState * >::reverse_iterator"""
        return _steps_swig.vector_cst_rend(self)

    def pop_back(self):
        """pop_back(vector_cst self)"""
        return _steps_swig.vector_cst_pop_back(self)

    def erase(self, *args):
        """
        erase(vector_cst self, std::vector< steps::model::ChanState * >::iterator pos) -> std::vector< steps::model::ChanState * >::iterator
        erase(vector_cst self, std::vector< steps::model::ChanState * >::iterator first, std::vector< steps::model::ChanState * >::iterator last) -> std::vector< steps::model::ChanState * >::iterator
        """
        return _steps_swig.vector_cst_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(p.steps::model::ChanState)> self) -> vector_cst
        __init__(std::vector<(p.steps::model::ChanState)> self, vector_cst arg2) -> vector_cst
        __init__(std::vector<(p.steps::model::ChanState)> self, std::vector< steps::model::ChanState * >::size_type size) -> vector_cst
        __init__(std::vector<(p.steps::model::ChanState)> self, std::vector< steps::model::ChanState * >::size_type size, ChanState value) -> vector_cst
        """
        this = _steps_swig.new_vector_cst(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(vector_cst self, ChanState x)"""
        return _steps_swig.vector_cst_push_back(self, *args)

    def front(self):
        """front(vector_cst self) -> ChanState"""
        return _steps_swig.vector_cst_front(self)

    def back(self):
        """back(vector_cst self) -> ChanState"""
        return _steps_swig.vector_cst_back(self)

    def assign(self, *args):
        """assign(vector_cst self, std::vector< steps::model::ChanState * >::size_type n, ChanState x)"""
        return _steps_swig.vector_cst_assign(self, *args)

    def resize(self, *args):
        """
        resize(vector_cst self, std::vector< steps::model::ChanState * >::size_type new_size)
        resize(vector_cst self, std::vector< steps::model::ChanState * >::size_type new_size, ChanState x)
        """
        return _steps_swig.vector_cst_resize(self, *args)

    def insert(self, *args):
        """
        insert(vector_cst self, std::vector< steps::model::ChanState * >::iterator pos, ChanState x) -> std::vector< steps::model::ChanState * >::iterator
        insert(vector_cst self, std::vector< steps::model::ChanState * >::iterator pos, std::vector< steps::model::ChanState * >::size_type n, 
            ChanState x)
        """
        return _steps_swig.vector_cst_insert(self, *args)

    def reserve(self, *args):
        """reserve(vector_cst self, std::vector< steps::model::ChanState * >::size_type n)"""
        return _steps_swig.vector_cst_reserve(self, *args)

    def capacity(self):
        """capacity(vector_cst self) -> std::vector< steps::model::ChanState * >::size_type"""
        return _steps_swig.vector_cst_capacity(self)

    __swig_destroy__ = _steps_swig.delete_vector_cst
    __del__ = lambda self : None;
vector_cst_swigregister = _steps_swig.vector_cst_swigregister
vector_cst_swigregister(vector_cst)

class vector_spc(_object):
    """Proxy of C++ std::vector<(p.steps::model::Spec)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_spc, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_spc, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(vector_spc self) -> SwigPyIterator"""
        return _steps_swig.vector_spc_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(vector_spc self) -> bool"""
        return _steps_swig.vector_spc___nonzero__(self)

    def __bool__(self):
        """__bool__(vector_spc self) -> bool"""
        return _steps_swig.vector_spc___bool__(self)

    def __len__(self):
        """__len__(vector_spc self) -> std::vector< steps::model::Spec * >::size_type"""
        return _steps_swig.vector_spc___len__(self)

    def pop(self):
        """pop(vector_spc self) -> Spec"""
        return _steps_swig.vector_spc_pop(self)

    def __getslice__(self, *args):
        """__getslice__(vector_spc self, std::vector< steps::model::Spec * >::difference_type i, std::vector< steps::model::Spec * >::difference_type j) -> vector_spc"""
        return _steps_swig.vector_spc___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(vector_spc self, std::vector< steps::model::Spec * >::difference_type i, std::vector< steps::model::Spec * >::difference_type j, 
            vector_spc v=std::vector< steps::model::Spec *,std::allocator< steps::model::Spec * > >())
        __setslice__(vector_spc self, std::vector< steps::model::Spec * >::difference_type i, std::vector< steps::model::Spec * >::difference_type j)
        """
        return _steps_swig.vector_spc___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(vector_spc self, std::vector< steps::model::Spec * >::difference_type i, std::vector< steps::model::Spec * >::difference_type j)"""
        return _steps_swig.vector_spc___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(vector_spc self, std::vector< steps::model::Spec * >::difference_type i)
        __delitem__(vector_spc self, PySliceObject * slice)
        """
        return _steps_swig.vector_spc___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(vector_spc self, PySliceObject * slice) -> vector_spc
        __getitem__(vector_spc self, std::vector< steps::model::Spec * >::difference_type i) -> Spec
        """
        return _steps_swig.vector_spc___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(vector_spc self, PySliceObject * slice, vector_spc v)
        __setitem__(vector_spc self, PySliceObject * slice)
        __setitem__(vector_spc self, std::vector< steps::model::Spec * >::difference_type i, Spec x)
        """
        return _steps_swig.vector_spc___setitem__(self, *args)

    def append(self, *args):
        """append(vector_spc self, Spec x)"""
        return _steps_swig.vector_spc_append(self, *args)

    def empty(self):
        """empty(vector_spc self) -> bool"""
        return _steps_swig.vector_spc_empty(self)

    def size(self):
        """size(vector_spc self) -> std::vector< steps::model::Spec * >::size_type"""
        return _steps_swig.vector_spc_size(self)

    def clear(self):
        """clear(vector_spc self)"""
        return _steps_swig.vector_spc_clear(self)

    def swap(self, *args):
        """swap(vector_spc self, vector_spc v)"""
        return _steps_swig.vector_spc_swap(self, *args)

    def get_allocator(self):
        """get_allocator(vector_spc self) -> std::vector< steps::model::Spec * >::allocator_type"""
        return _steps_swig.vector_spc_get_allocator(self)

    def begin(self):
        """begin(vector_spc self) -> std::vector< steps::model::Spec * >::iterator"""
        return _steps_swig.vector_spc_begin(self)

    def end(self):
        """end(vector_spc self) -> std::vector< steps::model::Spec * >::iterator"""
        return _steps_swig.vector_spc_end(self)

    def rbegin(self):
        """rbegin(vector_spc self) -> std::vector< steps::model::Spec * >::reverse_iterator"""
        return _steps_swig.vector_spc_rbegin(self)

    def rend(self):
        """rend(vector_spc self) -> std::vector< steps::model::Spec * >::reverse_iterator"""
        return _steps_swig.vector_spc_rend(self)

    def pop_back(self):
        """pop_back(vector_spc self)"""
        return _steps_swig.vector_spc_pop_back(self)

    def erase(self, *args):
        """
        erase(vector_spc self, std::vector< steps::model::Spec * >::iterator pos) -> std::vector< steps::model::Spec * >::iterator
        erase(vector_spc self, std::vector< steps::model::Spec * >::iterator first, std::vector< steps::model::Spec * >::iterator last) -> std::vector< steps::model::Spec * >::iterator
        """
        return _steps_swig.vector_spc_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(p.steps::model::Spec)> self) -> vector_spc
        __init__(std::vector<(p.steps::model::Spec)> self, vector_spc arg2) -> vector_spc
        __init__(std::vector<(p.steps::model::Spec)> self, std::vector< steps::model::Spec * >::size_type size) -> vector_spc
        __init__(std::vector<(p.steps::model::Spec)> self, std::vector< steps::model::Spec * >::size_type size, Spec value) -> vector_spc
        """
        this = _steps_swig.new_vector_spc(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(vector_spc self, Spec x)"""
        return _steps_swig.vector_spc_push_back(self, *args)

    def front(self):
        """front(vector_spc self) -> Spec"""
        return _steps_swig.vector_spc_front(self)

    def back(self):
        """back(vector_spc self) -> Spec"""
        return _steps_swig.vector_spc_back(self)

    def assign(self, *args):
        """assign(vector_spc self, std::vector< steps::model::Spec * >::size_type n, Spec x)"""
        return _steps_swig.vector_spc_assign(self, *args)

    def resize(self, *args):
        """
        resize(vector_spc self, std::vector< steps::model::Spec * >::size_type new_size)
        resize(vector_spc self, std::vector< steps::model::Spec * >::size_type new_size, Spec x)
        """
        return _steps_swig.vector_spc_resize(self, *args)

    def insert(self, *args):
        """
        insert(vector_spc self, std::vector< steps::model::Spec * >::iterator pos, Spec x) -> std::vector< steps::model::Spec * >::iterator
        insert(vector_spc self, std::vector< steps::model::Spec * >::iterator pos, std::vector< steps::model::Spec * >::size_type n, 
            Spec x)
        """
        return _steps_swig.vector_spc_insert(self, *args)

    def reserve(self, *args):
        """reserve(vector_spc self, std::vector< steps::model::Spec * >::size_type n)"""
        return _steps_swig.vector_spc_reserve(self, *args)

    def capacity(self):
        """capacity(vector_spc self) -> std::vector< steps::model::Spec * >::size_type"""
        return _steps_swig.vector_spc_capacity(self)

    __swig_destroy__ = _steps_swig.delete_vector_spc
    __del__ = lambda self : None;
vector_spc_swigregister = _steps_swig.vector_spc_swigregister
vector_spc_swigregister(vector_spc)

class vector_rec(_object):
    """Proxy of C++ std::vector<(p.steps::model::Reac)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_rec, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_rec, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(vector_rec self) -> SwigPyIterator"""
        return _steps_swig.vector_rec_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(vector_rec self) -> bool"""
        return _steps_swig.vector_rec___nonzero__(self)

    def __bool__(self):
        """__bool__(vector_rec self) -> bool"""
        return _steps_swig.vector_rec___bool__(self)

    def __len__(self):
        """__len__(vector_rec self) -> std::vector< steps::model::Reac * >::size_type"""
        return _steps_swig.vector_rec___len__(self)

    def pop(self):
        """pop(vector_rec self) -> Reac"""
        return _steps_swig.vector_rec_pop(self)

    def __getslice__(self, *args):
        """__getslice__(vector_rec self, std::vector< steps::model::Reac * >::difference_type i, std::vector< steps::model::Reac * >::difference_type j) -> vector_rec"""
        return _steps_swig.vector_rec___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(vector_rec self, std::vector< steps::model::Reac * >::difference_type i, std::vector< steps::model::Reac * >::difference_type j, 
            vector_rec v=std::vector< steps::model::Reac *,std::allocator< steps::model::Reac * > >())
        __setslice__(vector_rec self, std::vector< steps::model::Reac * >::difference_type i, std::vector< steps::model::Reac * >::difference_type j)
        """
        return _steps_swig.vector_rec___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(vector_rec self, std::vector< steps::model::Reac * >::difference_type i, std::vector< steps::model::Reac * >::difference_type j)"""
        return _steps_swig.vector_rec___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(vector_rec self, std::vector< steps::model::Reac * >::difference_type i)
        __delitem__(vector_rec self, PySliceObject * slice)
        """
        return _steps_swig.vector_rec___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(vector_rec self, PySliceObject * slice) -> vector_rec
        __getitem__(vector_rec self, std::vector< steps::model::Reac * >::difference_type i) -> Reac
        """
        return _steps_swig.vector_rec___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(vector_rec self, PySliceObject * slice, vector_rec v)
        __setitem__(vector_rec self, PySliceObject * slice)
        __setitem__(vector_rec self, std::vector< steps::model::Reac * >::difference_type i, Reac x)
        """
        return _steps_swig.vector_rec___setitem__(self, *args)

    def append(self, *args):
        """append(vector_rec self, Reac x)"""
        return _steps_swig.vector_rec_append(self, *args)

    def empty(self):
        """empty(vector_rec self) -> bool"""
        return _steps_swig.vector_rec_empty(self)

    def size(self):
        """size(vector_rec self) -> std::vector< steps::model::Reac * >::size_type"""
        return _steps_swig.vector_rec_size(self)

    def clear(self):
        """clear(vector_rec self)"""
        return _steps_swig.vector_rec_clear(self)

    def swap(self, *args):
        """swap(vector_rec self, vector_rec v)"""
        return _steps_swig.vector_rec_swap(self, *args)

    def get_allocator(self):
        """get_allocator(vector_rec self) -> std::vector< steps::model::Reac * >::allocator_type"""
        return _steps_swig.vector_rec_get_allocator(self)

    def begin(self):
        """begin(vector_rec self) -> std::vector< steps::model::Reac * >::iterator"""
        return _steps_swig.vector_rec_begin(self)

    def end(self):
        """end(vector_rec self) -> std::vector< steps::model::Reac * >::iterator"""
        return _steps_swig.vector_rec_end(self)

    def rbegin(self):
        """rbegin(vector_rec self) -> std::vector< steps::model::Reac * >::reverse_iterator"""
        return _steps_swig.vector_rec_rbegin(self)

    def rend(self):
        """rend(vector_rec self) -> std::vector< steps::model::Reac * >::reverse_iterator"""
        return _steps_swig.vector_rec_rend(self)

    def pop_back(self):
        """pop_back(vector_rec self)"""
        return _steps_swig.vector_rec_pop_back(self)

    def erase(self, *args):
        """
        erase(vector_rec self, std::vector< steps::model::Reac * >::iterator pos) -> std::vector< steps::model::Reac * >::iterator
        erase(vector_rec self, std::vector< steps::model::Reac * >::iterator first, std::vector< steps::model::Reac * >::iterator last) -> std::vector< steps::model::Reac * >::iterator
        """
        return _steps_swig.vector_rec_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(p.steps::model::Reac)> self) -> vector_rec
        __init__(std::vector<(p.steps::model::Reac)> self, vector_rec arg2) -> vector_rec
        __init__(std::vector<(p.steps::model::Reac)> self, std::vector< steps::model::Reac * >::size_type size) -> vector_rec
        __init__(std::vector<(p.steps::model::Reac)> self, std::vector< steps::model::Reac * >::size_type size, Reac value) -> vector_rec
        """
        this = _steps_swig.new_vector_rec(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(vector_rec self, Reac x)"""
        return _steps_swig.vector_rec_push_back(self, *args)

    def front(self):
        """front(vector_rec self) -> Reac"""
        return _steps_swig.vector_rec_front(self)

    def back(self):
        """back(vector_rec self) -> Reac"""
        return _steps_swig.vector_rec_back(self)

    def assign(self, *args):
        """assign(vector_rec self, std::vector< steps::model::Reac * >::size_type n, Reac x)"""
        return _steps_swig.vector_rec_assign(self, *args)

    def resize(self, *args):
        """
        resize(vector_rec self, std::vector< steps::model::Reac * >::size_type new_size)
        resize(vector_rec self, std::vector< steps::model::Reac * >::size_type new_size, Reac x)
        """
        return _steps_swig.vector_rec_resize(self, *args)

    def insert(self, *args):
        """
        insert(vector_rec self, std::vector< steps::model::Reac * >::iterator pos, Reac x) -> std::vector< steps::model::Reac * >::iterator
        insert(vector_rec self, std::vector< steps::model::Reac * >::iterator pos, std::vector< steps::model::Reac * >::size_type n, 
            Reac x)
        """
        return _steps_swig.vector_rec_insert(self, *args)

    def reserve(self, *args):
        """reserve(vector_rec self, std::vector< steps::model::Reac * >::size_type n)"""
        return _steps_swig.vector_rec_reserve(self, *args)

    def capacity(self):
        """capacity(vector_rec self) -> std::vector< steps::model::Reac * >::size_type"""
        return _steps_swig.vector_rec_capacity(self)

    __swig_destroy__ = _steps_swig.delete_vector_rec
    __del__ = lambda self : None;
vector_rec_swigregister = _steps_swig.vector_rec_swigregister
vector_rec_swigregister(vector_rec)

class vector_src(_object):
    """Proxy of C++ std::vector<(p.steps::model::SReac)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_src, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_src, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(vector_src self) -> SwigPyIterator"""
        return _steps_swig.vector_src_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(vector_src self) -> bool"""
        return _steps_swig.vector_src___nonzero__(self)

    def __bool__(self):
        """__bool__(vector_src self) -> bool"""
        return _steps_swig.vector_src___bool__(self)

    def __len__(self):
        """__len__(vector_src self) -> std::vector< steps::model::SReac * >::size_type"""
        return _steps_swig.vector_src___len__(self)

    def pop(self):
        """pop(vector_src self) -> SReac"""
        return _steps_swig.vector_src_pop(self)

    def __getslice__(self, *args):
        """__getslice__(vector_src self, std::vector< steps::model::SReac * >::difference_type i, std::vector< steps::model::SReac * >::difference_type j) -> vector_src"""
        return _steps_swig.vector_src___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(vector_src self, std::vector< steps::model::SReac * >::difference_type i, std::vector< steps::model::SReac * >::difference_type j, 
            vector_src v=std::vector< steps::model::SReac *,std::allocator< steps::model::SReac * > >())
        __setslice__(vector_src self, std::vector< steps::model::SReac * >::difference_type i, std::vector< steps::model::SReac * >::difference_type j)
        """
        return _steps_swig.vector_src___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(vector_src self, std::vector< steps::model::SReac * >::difference_type i, std::vector< steps::model::SReac * >::difference_type j)"""
        return _steps_swig.vector_src___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(vector_src self, std::vector< steps::model::SReac * >::difference_type i)
        __delitem__(vector_src self, PySliceObject * slice)
        """
        return _steps_swig.vector_src___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(vector_src self, PySliceObject * slice) -> vector_src
        __getitem__(vector_src self, std::vector< steps::model::SReac * >::difference_type i) -> SReac
        """
        return _steps_swig.vector_src___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(vector_src self, PySliceObject * slice, vector_src v)
        __setitem__(vector_src self, PySliceObject * slice)
        __setitem__(vector_src self, std::vector< steps::model::SReac * >::difference_type i, SReac x)
        """
        return _steps_swig.vector_src___setitem__(self, *args)

    def append(self, *args):
        """append(vector_src self, SReac x)"""
        return _steps_swig.vector_src_append(self, *args)

    def empty(self):
        """empty(vector_src self) -> bool"""
        return _steps_swig.vector_src_empty(self)

    def size(self):
        """size(vector_src self) -> std::vector< steps::model::SReac * >::size_type"""
        return _steps_swig.vector_src_size(self)

    def clear(self):
        """clear(vector_src self)"""
        return _steps_swig.vector_src_clear(self)

    def swap(self, *args):
        """swap(vector_src self, vector_src v)"""
        return _steps_swig.vector_src_swap(self, *args)

    def get_allocator(self):
        """get_allocator(vector_src self) -> std::vector< steps::model::SReac * >::allocator_type"""
        return _steps_swig.vector_src_get_allocator(self)

    def begin(self):
        """begin(vector_src self) -> std::vector< steps::model::SReac * >::iterator"""
        return _steps_swig.vector_src_begin(self)

    def end(self):
        """end(vector_src self) -> std::vector< steps::model::SReac * >::iterator"""
        return _steps_swig.vector_src_end(self)

    def rbegin(self):
        """rbegin(vector_src self) -> std::vector< steps::model::SReac * >::reverse_iterator"""
        return _steps_swig.vector_src_rbegin(self)

    def rend(self):
        """rend(vector_src self) -> std::vector< steps::model::SReac * >::reverse_iterator"""
        return _steps_swig.vector_src_rend(self)

    def pop_back(self):
        """pop_back(vector_src self)"""
        return _steps_swig.vector_src_pop_back(self)

    def erase(self, *args):
        """
        erase(vector_src self, std::vector< steps::model::SReac * >::iterator pos) -> std::vector< steps::model::SReac * >::iterator
        erase(vector_src self, std::vector< steps::model::SReac * >::iterator first, std::vector< steps::model::SReac * >::iterator last) -> std::vector< steps::model::SReac * >::iterator
        """
        return _steps_swig.vector_src_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(p.steps::model::SReac)> self) -> vector_src
        __init__(std::vector<(p.steps::model::SReac)> self, vector_src arg2) -> vector_src
        __init__(std::vector<(p.steps::model::SReac)> self, std::vector< steps::model::SReac * >::size_type size) -> vector_src
        __init__(std::vector<(p.steps::model::SReac)> self, std::vector< steps::model::SReac * >::size_type size, SReac value) -> vector_src
        """
        this = _steps_swig.new_vector_src(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(vector_src self, SReac x)"""
        return _steps_swig.vector_src_push_back(self, *args)

    def front(self):
        """front(vector_src self) -> SReac"""
        return _steps_swig.vector_src_front(self)

    def back(self):
        """back(vector_src self) -> SReac"""
        return _steps_swig.vector_src_back(self)

    def assign(self, *args):
        """assign(vector_src self, std::vector< steps::model::SReac * >::size_type n, SReac x)"""
        return _steps_swig.vector_src_assign(self, *args)

    def resize(self, *args):
        """
        resize(vector_src self, std::vector< steps::model::SReac * >::size_type new_size)
        resize(vector_src self, std::vector< steps::model::SReac * >::size_type new_size, SReac x)
        """
        return _steps_swig.vector_src_resize(self, *args)

    def insert(self, *args):
        """
        insert(vector_src self, std::vector< steps::model::SReac * >::iterator pos, SReac x) -> std::vector< steps::model::SReac * >::iterator
        insert(vector_src self, std::vector< steps::model::SReac * >::iterator pos, std::vector< steps::model::SReac * >::size_type n, 
            SReac x)
        """
        return _steps_swig.vector_src_insert(self, *args)

    def reserve(self, *args):
        """reserve(vector_src self, std::vector< steps::model::SReac * >::size_type n)"""
        return _steps_swig.vector_src_reserve(self, *args)

    def capacity(self):
        """capacity(vector_src self) -> std::vector< steps::model::SReac * >::size_type"""
        return _steps_swig.vector_src_capacity(self)

    __swig_destroy__ = _steps_swig.delete_vector_src
    __del__ = lambda self : None;
vector_src_swigregister = _steps_swig.vector_src_swigregister
vector_src_swigregister(vector_src)

class vector_dif(_object):
    """Proxy of C++ std::vector<(p.steps::model::Diff)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_dif, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_dif, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(vector_dif self) -> SwigPyIterator"""
        return _steps_swig.vector_dif_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(vector_dif self) -> bool"""
        return _steps_swig.vector_dif___nonzero__(self)

    def __bool__(self):
        """__bool__(vector_dif self) -> bool"""
        return _steps_swig.vector_dif___bool__(self)

    def __len__(self):
        """__len__(vector_dif self) -> std::vector< steps::model::Diff * >::size_type"""
        return _steps_swig.vector_dif___len__(self)

    def pop(self):
        """pop(vector_dif self) -> Diff"""
        return _steps_swig.vector_dif_pop(self)

    def __getslice__(self, *args):
        """__getslice__(vector_dif self, std::vector< steps::model::Diff * >::difference_type i, std::vector< steps::model::Diff * >::difference_type j) -> vector_dif"""
        return _steps_swig.vector_dif___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(vector_dif self, std::vector< steps::model::Diff * >::difference_type i, std::vector< steps::model::Diff * >::difference_type j, 
            vector_dif v=std::vector< steps::model::Diff *,std::allocator< steps::model::Diff * > >())
        __setslice__(vector_dif self, std::vector< steps::model::Diff * >::difference_type i, std::vector< steps::model::Diff * >::difference_type j)
        """
        return _steps_swig.vector_dif___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(vector_dif self, std::vector< steps::model::Diff * >::difference_type i, std::vector< steps::model::Diff * >::difference_type j)"""
        return _steps_swig.vector_dif___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(vector_dif self, std::vector< steps::model::Diff * >::difference_type i)
        __delitem__(vector_dif self, PySliceObject * slice)
        """
        return _steps_swig.vector_dif___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(vector_dif self, PySliceObject * slice) -> vector_dif
        __getitem__(vector_dif self, std::vector< steps::model::Diff * >::difference_type i) -> Diff
        """
        return _steps_swig.vector_dif___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(vector_dif self, PySliceObject * slice, vector_dif v)
        __setitem__(vector_dif self, PySliceObject * slice)
        __setitem__(vector_dif self, std::vector< steps::model::Diff * >::difference_type i, Diff x)
        """
        return _steps_swig.vector_dif___setitem__(self, *args)

    def append(self, *args):
        """append(vector_dif self, Diff x)"""
        return _steps_swig.vector_dif_append(self, *args)

    def empty(self):
        """empty(vector_dif self) -> bool"""
        return _steps_swig.vector_dif_empty(self)

    def size(self):
        """size(vector_dif self) -> std::vector< steps::model::Diff * >::size_type"""
        return _steps_swig.vector_dif_size(self)

    def clear(self):
        """clear(vector_dif self)"""
        return _steps_swig.vector_dif_clear(self)

    def swap(self, *args):
        """swap(vector_dif self, vector_dif v)"""
        return _steps_swig.vector_dif_swap(self, *args)

    def get_allocator(self):
        """get_allocator(vector_dif self) -> std::vector< steps::model::Diff * >::allocator_type"""
        return _steps_swig.vector_dif_get_allocator(self)

    def begin(self):
        """begin(vector_dif self) -> std::vector< steps::model::Diff * >::iterator"""
        return _steps_swig.vector_dif_begin(self)

    def end(self):
        """end(vector_dif self) -> std::vector< steps::model::Diff * >::iterator"""
        return _steps_swig.vector_dif_end(self)

    def rbegin(self):
        """rbegin(vector_dif self) -> std::vector< steps::model::Diff * >::reverse_iterator"""
        return _steps_swig.vector_dif_rbegin(self)

    def rend(self):
        """rend(vector_dif self) -> std::vector< steps::model::Diff * >::reverse_iterator"""
        return _steps_swig.vector_dif_rend(self)

    def pop_back(self):
        """pop_back(vector_dif self)"""
        return _steps_swig.vector_dif_pop_back(self)

    def erase(self, *args):
        """
        erase(vector_dif self, std::vector< steps::model::Diff * >::iterator pos) -> std::vector< steps::model::Diff * >::iterator
        erase(vector_dif self, std::vector< steps::model::Diff * >::iterator first, std::vector< steps::model::Diff * >::iterator last) -> std::vector< steps::model::Diff * >::iterator
        """
        return _steps_swig.vector_dif_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(p.steps::model::Diff)> self) -> vector_dif
        __init__(std::vector<(p.steps::model::Diff)> self, vector_dif arg2) -> vector_dif
        __init__(std::vector<(p.steps::model::Diff)> self, std::vector< steps::model::Diff * >::size_type size) -> vector_dif
        __init__(std::vector<(p.steps::model::Diff)> self, std::vector< steps::model::Diff * >::size_type size, Diff value) -> vector_dif
        """
        this = _steps_swig.new_vector_dif(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(vector_dif self, Diff x)"""
        return _steps_swig.vector_dif_push_back(self, *args)

    def front(self):
        """front(vector_dif self) -> Diff"""
        return _steps_swig.vector_dif_front(self)

    def back(self):
        """back(vector_dif self) -> Diff"""
        return _steps_swig.vector_dif_back(self)

    def assign(self, *args):
        """assign(vector_dif self, std::vector< steps::model::Diff * >::size_type n, Diff x)"""
        return _steps_swig.vector_dif_assign(self, *args)

    def resize(self, *args):
        """
        resize(vector_dif self, std::vector< steps::model::Diff * >::size_type new_size)
        resize(vector_dif self, std::vector< steps::model::Diff * >::size_type new_size, Diff x)
        """
        return _steps_swig.vector_dif_resize(self, *args)

    def insert(self, *args):
        """
        insert(vector_dif self, std::vector< steps::model::Diff * >::iterator pos, Diff x) -> std::vector< steps::model::Diff * >::iterator
        insert(vector_dif self, std::vector< steps::model::Diff * >::iterator pos, std::vector< steps::model::Diff * >::size_type n, 
            Diff x)
        """
        return _steps_swig.vector_dif_insert(self, *args)

    def reserve(self, *args):
        """reserve(vector_dif self, std::vector< steps::model::Diff * >::size_type n)"""
        return _steps_swig.vector_dif_reserve(self, *args)

    def capacity(self):
        """capacity(vector_dif self) -> std::vector< steps::model::Diff * >::size_type"""
        return _steps_swig.vector_dif_capacity(self)

    __swig_destroy__ = _steps_swig.delete_vector_dif
    __del__ = lambda self : None;
vector_dif_swigregister = _steps_swig.vector_dif_swigregister
vector_dif_swigregister(vector_dif)

class vector_vdt(_object):
    """Proxy of C++ std::vector<(p.steps::model::VDepTrans)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_vdt, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_vdt, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(vector_vdt self) -> SwigPyIterator"""
        return _steps_swig.vector_vdt_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(vector_vdt self) -> bool"""
        return _steps_swig.vector_vdt___nonzero__(self)

    def __bool__(self):
        """__bool__(vector_vdt self) -> bool"""
        return _steps_swig.vector_vdt___bool__(self)

    def __len__(self):
        """__len__(vector_vdt self) -> std::vector< steps::model::VDepTrans * >::size_type"""
        return _steps_swig.vector_vdt___len__(self)

    def pop(self):
        """pop(vector_vdt self) -> VDepTrans"""
        return _steps_swig.vector_vdt_pop(self)

    def __getslice__(self, *args):
        """__getslice__(vector_vdt self, std::vector< steps::model::VDepTrans * >::difference_type i, std::vector< steps::model::VDepTrans * >::difference_type j) -> vector_vdt"""
        return _steps_swig.vector_vdt___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(vector_vdt self, std::vector< steps::model::VDepTrans * >::difference_type i, std::vector< steps::model::VDepTrans * >::difference_type j, 
            vector_vdt v=std::vector< steps::model::VDepTrans *,std::allocator< steps::model::VDepTrans * > >())
        __setslice__(vector_vdt self, std::vector< steps::model::VDepTrans * >::difference_type i, std::vector< steps::model::VDepTrans * >::difference_type j)
        """
        return _steps_swig.vector_vdt___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(vector_vdt self, std::vector< steps::model::VDepTrans * >::difference_type i, std::vector< steps::model::VDepTrans * >::difference_type j)"""
        return _steps_swig.vector_vdt___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(vector_vdt self, std::vector< steps::model::VDepTrans * >::difference_type i)
        __delitem__(vector_vdt self, PySliceObject * slice)
        """
        return _steps_swig.vector_vdt___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(vector_vdt self, PySliceObject * slice) -> vector_vdt
        __getitem__(vector_vdt self, std::vector< steps::model::VDepTrans * >::difference_type i) -> VDepTrans
        """
        return _steps_swig.vector_vdt___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(vector_vdt self, PySliceObject * slice, vector_vdt v)
        __setitem__(vector_vdt self, PySliceObject * slice)
        __setitem__(vector_vdt self, std::vector< steps::model::VDepTrans * >::difference_type i, VDepTrans x)
        """
        return _steps_swig.vector_vdt___setitem__(self, *args)

    def append(self, *args):
        """append(vector_vdt self, VDepTrans x)"""
        return _steps_swig.vector_vdt_append(self, *args)

    def empty(self):
        """empty(vector_vdt self) -> bool"""
        return _steps_swig.vector_vdt_empty(self)

    def size(self):
        """size(vector_vdt self) -> std::vector< steps::model::VDepTrans * >::size_type"""
        return _steps_swig.vector_vdt_size(self)

    def clear(self):
        """clear(vector_vdt self)"""
        return _steps_swig.vector_vdt_clear(self)

    def swap(self, *args):
        """swap(vector_vdt self, vector_vdt v)"""
        return _steps_swig.vector_vdt_swap(self, *args)

    def get_allocator(self):
        """get_allocator(vector_vdt self) -> std::vector< steps::model::VDepTrans * >::allocator_type"""
        return _steps_swig.vector_vdt_get_allocator(self)

    def begin(self):
        """begin(vector_vdt self) -> std::vector< steps::model::VDepTrans * >::iterator"""
        return _steps_swig.vector_vdt_begin(self)

    def end(self):
        """end(vector_vdt self) -> std::vector< steps::model::VDepTrans * >::iterator"""
        return _steps_swig.vector_vdt_end(self)

    def rbegin(self):
        """rbegin(vector_vdt self) -> std::vector< steps::model::VDepTrans * >::reverse_iterator"""
        return _steps_swig.vector_vdt_rbegin(self)

    def rend(self):
        """rend(vector_vdt self) -> std::vector< steps::model::VDepTrans * >::reverse_iterator"""
        return _steps_swig.vector_vdt_rend(self)

    def pop_back(self):
        """pop_back(vector_vdt self)"""
        return _steps_swig.vector_vdt_pop_back(self)

    def erase(self, *args):
        """
        erase(vector_vdt self, std::vector< steps::model::VDepTrans * >::iterator pos) -> std::vector< steps::model::VDepTrans * >::iterator
        erase(vector_vdt self, std::vector< steps::model::VDepTrans * >::iterator first, std::vector< steps::model::VDepTrans * >::iterator last) -> std::vector< steps::model::VDepTrans * >::iterator
        """
        return _steps_swig.vector_vdt_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(p.steps::model::VDepTrans)> self) -> vector_vdt
        __init__(std::vector<(p.steps::model::VDepTrans)> self, vector_vdt arg2) -> vector_vdt
        __init__(std::vector<(p.steps::model::VDepTrans)> self, std::vector< steps::model::VDepTrans * >::size_type size) -> vector_vdt
        __init__(std::vector<(p.steps::model::VDepTrans)> self, std::vector< steps::model::VDepTrans * >::size_type size, VDepTrans value) -> vector_vdt
        """
        this = _steps_swig.new_vector_vdt(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(vector_vdt self, VDepTrans x)"""
        return _steps_swig.vector_vdt_push_back(self, *args)

    def front(self):
        """front(vector_vdt self) -> VDepTrans"""
        return _steps_swig.vector_vdt_front(self)

    def back(self):
        """back(vector_vdt self) -> VDepTrans"""
        return _steps_swig.vector_vdt_back(self)

    def assign(self, *args):
        """assign(vector_vdt self, std::vector< steps::model::VDepTrans * >::size_type n, VDepTrans x)"""
        return _steps_swig.vector_vdt_assign(self, *args)

    def resize(self, *args):
        """
        resize(vector_vdt self, std::vector< steps::model::VDepTrans * >::size_type new_size)
        resize(vector_vdt self, std::vector< steps::model::VDepTrans * >::size_type new_size, VDepTrans x)
        """
        return _steps_swig.vector_vdt_resize(self, *args)

    def insert(self, *args):
        """
        insert(vector_vdt self, std::vector< steps::model::VDepTrans * >::iterator pos, VDepTrans x) -> std::vector< steps::model::VDepTrans * >::iterator
        insert(vector_vdt self, std::vector< steps::model::VDepTrans * >::iterator pos, std::vector< steps::model::VDepTrans * >::size_type n, 
            VDepTrans x)
        """
        return _steps_swig.vector_vdt_insert(self, *args)

    def reserve(self, *args):
        """reserve(vector_vdt self, std::vector< steps::model::VDepTrans * >::size_type n)"""
        return _steps_swig.vector_vdt_reserve(self, *args)

    def capacity(self):
        """capacity(vector_vdt self) -> std::vector< steps::model::VDepTrans * >::size_type"""
        return _steps_swig.vector_vdt_capacity(self)

    __swig_destroy__ = _steps_swig.delete_vector_vdt
    __del__ = lambda self : None;
vector_vdt_swigregister = _steps_swig.vector_vdt_swigregister
vector_vdt_swigregister(vector_vdt)

class vector_vdsr(_object):
    """Proxy of C++ std::vector<(p.steps::model::VDepSReac)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_vdsr, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_vdsr, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(vector_vdsr self) -> SwigPyIterator"""
        return _steps_swig.vector_vdsr_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(vector_vdsr self) -> bool"""
        return _steps_swig.vector_vdsr___nonzero__(self)

    def __bool__(self):
        """__bool__(vector_vdsr self) -> bool"""
        return _steps_swig.vector_vdsr___bool__(self)

    def __len__(self):
        """__len__(vector_vdsr self) -> std::vector< steps::model::VDepSReac * >::size_type"""
        return _steps_swig.vector_vdsr___len__(self)

    def pop(self):
        """pop(vector_vdsr self) -> VDepSReac"""
        return _steps_swig.vector_vdsr_pop(self)

    def __getslice__(self, *args):
        """__getslice__(vector_vdsr self, std::vector< steps::model::VDepSReac * >::difference_type i, std::vector< steps::model::VDepSReac * >::difference_type j) -> vector_vdsr"""
        return _steps_swig.vector_vdsr___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(vector_vdsr self, std::vector< steps::model::VDepSReac * >::difference_type i, std::vector< steps::model::VDepSReac * >::difference_type j, 
            vector_vdsr v=std::vector< steps::model::VDepSReac *,std::allocator< steps::model::VDepSReac * > >())
        __setslice__(vector_vdsr self, std::vector< steps::model::VDepSReac * >::difference_type i, std::vector< steps::model::VDepSReac * >::difference_type j)
        """
        return _steps_swig.vector_vdsr___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(vector_vdsr self, std::vector< steps::model::VDepSReac * >::difference_type i, std::vector< steps::model::VDepSReac * >::difference_type j)"""
        return _steps_swig.vector_vdsr___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(vector_vdsr self, std::vector< steps::model::VDepSReac * >::difference_type i)
        __delitem__(vector_vdsr self, PySliceObject * slice)
        """
        return _steps_swig.vector_vdsr___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(vector_vdsr self, PySliceObject * slice) -> vector_vdsr
        __getitem__(vector_vdsr self, std::vector< steps::model::VDepSReac * >::difference_type i) -> VDepSReac
        """
        return _steps_swig.vector_vdsr___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(vector_vdsr self, PySliceObject * slice, vector_vdsr v)
        __setitem__(vector_vdsr self, PySliceObject * slice)
        __setitem__(vector_vdsr self, std::vector< steps::model::VDepSReac * >::difference_type i, VDepSReac x)
        """
        return _steps_swig.vector_vdsr___setitem__(self, *args)

    def append(self, *args):
        """append(vector_vdsr self, VDepSReac x)"""
        return _steps_swig.vector_vdsr_append(self, *args)

    def empty(self):
        """empty(vector_vdsr self) -> bool"""
        return _steps_swig.vector_vdsr_empty(self)

    def size(self):
        """size(vector_vdsr self) -> std::vector< steps::model::VDepSReac * >::size_type"""
        return _steps_swig.vector_vdsr_size(self)

    def clear(self):
        """clear(vector_vdsr self)"""
        return _steps_swig.vector_vdsr_clear(self)

    def swap(self, *args):
        """swap(vector_vdsr self, vector_vdsr v)"""
        return _steps_swig.vector_vdsr_swap(self, *args)

    def get_allocator(self):
        """get_allocator(vector_vdsr self) -> std::vector< steps::model::VDepSReac * >::allocator_type"""
        return _steps_swig.vector_vdsr_get_allocator(self)

    def begin(self):
        """begin(vector_vdsr self) -> std::vector< steps::model::VDepSReac * >::iterator"""
        return _steps_swig.vector_vdsr_begin(self)

    def end(self):
        """end(vector_vdsr self) -> std::vector< steps::model::VDepSReac * >::iterator"""
        return _steps_swig.vector_vdsr_end(self)

    def rbegin(self):
        """rbegin(vector_vdsr self) -> std::vector< steps::model::VDepSReac * >::reverse_iterator"""
        return _steps_swig.vector_vdsr_rbegin(self)

    def rend(self):
        """rend(vector_vdsr self) -> std::vector< steps::model::VDepSReac * >::reverse_iterator"""
        return _steps_swig.vector_vdsr_rend(self)

    def pop_back(self):
        """pop_back(vector_vdsr self)"""
        return _steps_swig.vector_vdsr_pop_back(self)

    def erase(self, *args):
        """
        erase(vector_vdsr self, std::vector< steps::model::VDepSReac * >::iterator pos) -> std::vector< steps::model::VDepSReac * >::iterator
        erase(vector_vdsr self, std::vector< steps::model::VDepSReac * >::iterator first, std::vector< steps::model::VDepSReac * >::iterator last) -> std::vector< steps::model::VDepSReac * >::iterator
        """
        return _steps_swig.vector_vdsr_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(p.steps::model::VDepSReac)> self) -> vector_vdsr
        __init__(std::vector<(p.steps::model::VDepSReac)> self, vector_vdsr arg2) -> vector_vdsr
        __init__(std::vector<(p.steps::model::VDepSReac)> self, std::vector< steps::model::VDepSReac * >::size_type size) -> vector_vdsr
        __init__(std::vector<(p.steps::model::VDepSReac)> self, std::vector< steps::model::VDepSReac * >::size_type size, VDepSReac value) -> vector_vdsr
        """
        this = _steps_swig.new_vector_vdsr(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(vector_vdsr self, VDepSReac x)"""
        return _steps_swig.vector_vdsr_push_back(self, *args)

    def front(self):
        """front(vector_vdsr self) -> VDepSReac"""
        return _steps_swig.vector_vdsr_front(self)

    def back(self):
        """back(vector_vdsr self) -> VDepSReac"""
        return _steps_swig.vector_vdsr_back(self)

    def assign(self, *args):
        """assign(vector_vdsr self, std::vector< steps::model::VDepSReac * >::size_type n, VDepSReac x)"""
        return _steps_swig.vector_vdsr_assign(self, *args)

    def resize(self, *args):
        """
        resize(vector_vdsr self, std::vector< steps::model::VDepSReac * >::size_type new_size)
        resize(vector_vdsr self, std::vector< steps::model::VDepSReac * >::size_type new_size, VDepSReac x)
        """
        return _steps_swig.vector_vdsr_resize(self, *args)

    def insert(self, *args):
        """
        insert(vector_vdsr self, std::vector< steps::model::VDepSReac * >::iterator pos, VDepSReac x) -> std::vector< steps::model::VDepSReac * >::iterator
        insert(vector_vdsr self, std::vector< steps::model::VDepSReac * >::iterator pos, std::vector< steps::model::VDepSReac * >::size_type n, 
            VDepSReac x)
        """
        return _steps_swig.vector_vdsr_insert(self, *args)

    def reserve(self, *args):
        """reserve(vector_vdsr self, std::vector< steps::model::VDepSReac * >::size_type n)"""
        return _steps_swig.vector_vdsr_reserve(self, *args)

    def capacity(self):
        """capacity(vector_vdsr self) -> std::vector< steps::model::VDepSReac * >::size_type"""
        return _steps_swig.vector_vdsr_capacity(self)

    __swig_destroy__ = _steps_swig.delete_vector_vdsr
    __del__ = lambda self : None;
vector_vdsr_swigregister = _steps_swig.vector_vdsr_swigregister
vector_vdsr_swigregister(vector_vdsr)

class vector_ohc(_object):
    """Proxy of C++ std::vector<(p.steps::model::OhmicCurr)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_ohc, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_ohc, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(vector_ohc self) -> SwigPyIterator"""
        return _steps_swig.vector_ohc_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(vector_ohc self) -> bool"""
        return _steps_swig.vector_ohc___nonzero__(self)

    def __bool__(self):
        """__bool__(vector_ohc self) -> bool"""
        return _steps_swig.vector_ohc___bool__(self)

    def __len__(self):
        """__len__(vector_ohc self) -> std::vector< steps::model::OhmicCurr * >::size_type"""
        return _steps_swig.vector_ohc___len__(self)

    def pop(self):
        """pop(vector_ohc self) -> OhmicCurr"""
        return _steps_swig.vector_ohc_pop(self)

    def __getslice__(self, *args):
        """__getslice__(vector_ohc self, std::vector< steps::model::OhmicCurr * >::difference_type i, std::vector< steps::model::OhmicCurr * >::difference_type j) -> vector_ohc"""
        return _steps_swig.vector_ohc___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(vector_ohc self, std::vector< steps::model::OhmicCurr * >::difference_type i, std::vector< steps::model::OhmicCurr * >::difference_type j, 
            vector_ohc v=std::vector< steps::model::OhmicCurr *,std::allocator< steps::model::OhmicCurr * > >())
        __setslice__(vector_ohc self, std::vector< steps::model::OhmicCurr * >::difference_type i, std::vector< steps::model::OhmicCurr * >::difference_type j)
        """
        return _steps_swig.vector_ohc___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(vector_ohc self, std::vector< steps::model::OhmicCurr * >::difference_type i, std::vector< steps::model::OhmicCurr * >::difference_type j)"""
        return _steps_swig.vector_ohc___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(vector_ohc self, std::vector< steps::model::OhmicCurr * >::difference_type i)
        __delitem__(vector_ohc self, PySliceObject * slice)
        """
        return _steps_swig.vector_ohc___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(vector_ohc self, PySliceObject * slice) -> vector_ohc
        __getitem__(vector_ohc self, std::vector< steps::model::OhmicCurr * >::difference_type i) -> OhmicCurr
        """
        return _steps_swig.vector_ohc___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(vector_ohc self, PySliceObject * slice, vector_ohc v)
        __setitem__(vector_ohc self, PySliceObject * slice)
        __setitem__(vector_ohc self, std::vector< steps::model::OhmicCurr * >::difference_type i, OhmicCurr x)
        """
        return _steps_swig.vector_ohc___setitem__(self, *args)

    def append(self, *args):
        """append(vector_ohc self, OhmicCurr x)"""
        return _steps_swig.vector_ohc_append(self, *args)

    def empty(self):
        """empty(vector_ohc self) -> bool"""
        return _steps_swig.vector_ohc_empty(self)

    def size(self):
        """size(vector_ohc self) -> std::vector< steps::model::OhmicCurr * >::size_type"""
        return _steps_swig.vector_ohc_size(self)

    def clear(self):
        """clear(vector_ohc self)"""
        return _steps_swig.vector_ohc_clear(self)

    def swap(self, *args):
        """swap(vector_ohc self, vector_ohc v)"""
        return _steps_swig.vector_ohc_swap(self, *args)

    def get_allocator(self):
        """get_allocator(vector_ohc self) -> std::vector< steps::model::OhmicCurr * >::allocator_type"""
        return _steps_swig.vector_ohc_get_allocator(self)

    def begin(self):
        """begin(vector_ohc self) -> std::vector< steps::model::OhmicCurr * >::iterator"""
        return _steps_swig.vector_ohc_begin(self)

    def end(self):
        """end(vector_ohc self) -> std::vector< steps::model::OhmicCurr * >::iterator"""
        return _steps_swig.vector_ohc_end(self)

    def rbegin(self):
        """rbegin(vector_ohc self) -> std::vector< steps::model::OhmicCurr * >::reverse_iterator"""
        return _steps_swig.vector_ohc_rbegin(self)

    def rend(self):
        """rend(vector_ohc self) -> std::vector< steps::model::OhmicCurr * >::reverse_iterator"""
        return _steps_swig.vector_ohc_rend(self)

    def pop_back(self):
        """pop_back(vector_ohc self)"""
        return _steps_swig.vector_ohc_pop_back(self)

    def erase(self, *args):
        """
        erase(vector_ohc self, std::vector< steps::model::OhmicCurr * >::iterator pos) -> std::vector< steps::model::OhmicCurr * >::iterator
        erase(vector_ohc self, std::vector< steps::model::OhmicCurr * >::iterator first, std::vector< steps::model::OhmicCurr * >::iterator last) -> std::vector< steps::model::OhmicCurr * >::iterator
        """
        return _steps_swig.vector_ohc_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(p.steps::model::OhmicCurr)> self) -> vector_ohc
        __init__(std::vector<(p.steps::model::OhmicCurr)> self, vector_ohc arg2) -> vector_ohc
        __init__(std::vector<(p.steps::model::OhmicCurr)> self, std::vector< steps::model::OhmicCurr * >::size_type size) -> vector_ohc
        __init__(std::vector<(p.steps::model::OhmicCurr)> self, std::vector< steps::model::OhmicCurr * >::size_type size, OhmicCurr value) -> vector_ohc
        """
        this = _steps_swig.new_vector_ohc(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(vector_ohc self, OhmicCurr x)"""
        return _steps_swig.vector_ohc_push_back(self, *args)

    def front(self):
        """front(vector_ohc self) -> OhmicCurr"""
        return _steps_swig.vector_ohc_front(self)

    def back(self):
        """back(vector_ohc self) -> OhmicCurr"""
        return _steps_swig.vector_ohc_back(self)

    def assign(self, *args):
        """assign(vector_ohc self, std::vector< steps::model::OhmicCurr * >::size_type n, OhmicCurr x)"""
        return _steps_swig.vector_ohc_assign(self, *args)

    def resize(self, *args):
        """
        resize(vector_ohc self, std::vector< steps::model::OhmicCurr * >::size_type new_size)
        resize(vector_ohc self, std::vector< steps::model::OhmicCurr * >::size_type new_size, OhmicCurr x)
        """
        return _steps_swig.vector_ohc_resize(self, *args)

    def insert(self, *args):
        """
        insert(vector_ohc self, std::vector< steps::model::OhmicCurr * >::iterator pos, OhmicCurr x) -> std::vector< steps::model::OhmicCurr * >::iterator
        insert(vector_ohc self, std::vector< steps::model::OhmicCurr * >::iterator pos, std::vector< steps::model::OhmicCurr * >::size_type n, 
            OhmicCurr x)
        """
        return _steps_swig.vector_ohc_insert(self, *args)

    def reserve(self, *args):
        """reserve(vector_ohc self, std::vector< steps::model::OhmicCurr * >::size_type n)"""
        return _steps_swig.vector_ohc_reserve(self, *args)

    def capacity(self):
        """capacity(vector_ohc self) -> std::vector< steps::model::OhmicCurr * >::size_type"""
        return _steps_swig.vector_ohc_capacity(self)

    __swig_destroy__ = _steps_swig.delete_vector_ohc
    __del__ = lambda self : None;
vector_ohc_swigregister = _steps_swig.vector_ohc_swigregister
vector_ohc_swigregister(vector_ohc)

class map_str_dbl(_object):
    """Proxy of C++ std::map<(std::string,double)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, map_str_dbl, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, map_str_dbl, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(map_str_dbl self) -> SwigPyIterator"""
        return _steps_swig.map_str_dbl_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(map_str_dbl self) -> bool"""
        return _steps_swig.map_str_dbl___nonzero__(self)

    def __bool__(self):
        """__bool__(map_str_dbl self) -> bool"""
        return _steps_swig.map_str_dbl___bool__(self)

    def __len__(self):
        """__len__(map_str_dbl self) -> std::map< std::string,double >::size_type"""
        return _steps_swig.map_str_dbl___len__(self)

    def __iter__(self): return self.key_iterator()
    def iterkeys(self): return self.key_iterator()
    def itervalues(self): return self.value_iterator()
    def iteritems(self): return self.iterator()
    def __getitem__(self, *args):
        """__getitem__(map_str_dbl self, std::map< std::string,double >::key_type const & key) -> std::map< std::string,double >::mapped_type const &"""
        return _steps_swig.map_str_dbl___getitem__(self, *args)

    def __delitem__(self, *args):
        """__delitem__(map_str_dbl self, std::map< std::string,double >::key_type const & key)"""
        return _steps_swig.map_str_dbl___delitem__(self, *args)

    def has_key(self, *args):
        """has_key(map_str_dbl self, std::map< std::string,double >::key_type const & key) -> bool"""
        return _steps_swig.map_str_dbl_has_key(self, *args)

    def keys(self):
        """keys(map_str_dbl self) -> PyObject *"""
        return _steps_swig.map_str_dbl_keys(self)

    def values(self):
        """values(map_str_dbl self) -> PyObject *"""
        return _steps_swig.map_str_dbl_values(self)

    def items(self):
        """items(map_str_dbl self) -> PyObject *"""
        return _steps_swig.map_str_dbl_items(self)

    def __contains__(self, *args):
        """__contains__(map_str_dbl self, std::map< std::string,double >::key_type const & key) -> bool"""
        return _steps_swig.map_str_dbl___contains__(self, *args)

    def key_iterator(self):
        """key_iterator(map_str_dbl self) -> SwigPyIterator"""
        return _steps_swig.map_str_dbl_key_iterator(self)

    def value_iterator(self):
        """value_iterator(map_str_dbl self) -> SwigPyIterator"""
        return _steps_swig.map_str_dbl_value_iterator(self)

    def __setitem__(self, *args):
        """
        __setitem__(map_str_dbl self, std::map< std::string,double >::key_type const & key)
        __setitem__(map_str_dbl self, std::map< std::string,double >::key_type const & key, std::map< std::string,double >::mapped_type const & x)
        """
        return _steps_swig.map_str_dbl___setitem__(self, *args)

    def asdict(self):
        """asdict(map_str_dbl self) -> PyObject *"""
        return _steps_swig.map_str_dbl_asdict(self)

    def __init__(self, *args): 
        """
        __init__(std::map<(std::string,double)> self, std::less< std::string > const & arg2) -> map_str_dbl
        __init__(std::map<(std::string,double)> self) -> map_str_dbl
        __init__(std::map<(std::string,double)> self, map_str_dbl arg2) -> map_str_dbl
        """
        this = _steps_swig.new_map_str_dbl(*args)
        try: self.this.append(this)
        except: self.this = this
    def empty(self):
        """empty(map_str_dbl self) -> bool"""
        return _steps_swig.map_str_dbl_empty(self)

    def size(self):
        """size(map_str_dbl self) -> std::map< std::string,double >::size_type"""
        return _steps_swig.map_str_dbl_size(self)

    def clear(self):
        """clear(map_str_dbl self)"""
        return _steps_swig.map_str_dbl_clear(self)

    def swap(self, *args):
        """swap(map_str_dbl self, map_str_dbl v)"""
        return _steps_swig.map_str_dbl_swap(self, *args)

    def get_allocator(self):
        """get_allocator(map_str_dbl self) -> std::map< std::string,double >::allocator_type"""
        return _steps_swig.map_str_dbl_get_allocator(self)

    def begin(self):
        """begin(map_str_dbl self) -> std::map< std::string,double >::iterator"""
        return _steps_swig.map_str_dbl_begin(self)

    def end(self):
        """end(map_str_dbl self) -> std::map< std::string,double >::iterator"""
        return _steps_swig.map_str_dbl_end(self)

    def rbegin(self):
        """rbegin(map_str_dbl self) -> std::map< std::string,double >::reverse_iterator"""
        return _steps_swig.map_str_dbl_rbegin(self)

    def rend(self):
        """rend(map_str_dbl self) -> std::map< std::string,double >::reverse_iterator"""
        return _steps_swig.map_str_dbl_rend(self)

    def count(self, *args):
        """count(map_str_dbl self, std::map< std::string,double >::key_type const & x) -> std::map< std::string,double >::size_type"""
        return _steps_swig.map_str_dbl_count(self, *args)

    def erase(self, *args):
        """
        erase(map_str_dbl self, std::map< std::string,double >::key_type const & x) -> std::map< std::string,double >::size_type
        erase(map_str_dbl self, std::map< std::string,double >::iterator position)
        erase(map_str_dbl self, std::map< std::string,double >::iterator first, std::map< std::string,double >::iterator last)
        """
        return _steps_swig.map_str_dbl_erase(self, *args)

    def find(self, *args):
        """find(map_str_dbl self, std::map< std::string,double >::key_type const & x) -> std::map< std::string,double >::iterator"""
        return _steps_swig.map_str_dbl_find(self, *args)

    def lower_bound(self, *args):
        """lower_bound(map_str_dbl self, std::map< std::string,double >::key_type const & x) -> std::map< std::string,double >::iterator"""
        return _steps_swig.map_str_dbl_lower_bound(self, *args)

    def upper_bound(self, *args):
        """upper_bound(map_str_dbl self, std::map< std::string,double >::key_type const & x) -> std::map< std::string,double >::iterator"""
        return _steps_swig.map_str_dbl_upper_bound(self, *args)

    __swig_destroy__ = _steps_swig.delete_map_str_dbl
    __del__ = lambda self : None;
map_str_dbl_swigregister = _steps_swig.map_str_dbl_swigregister
map_str_dbl_swigregister(map_str_dbl)

class vector_vsys(_object):
    """Proxy of C++ std::vector<(p.steps::model::Volsys)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_vsys, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_vsys, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(vector_vsys self) -> SwigPyIterator"""
        return _steps_swig.vector_vsys_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(vector_vsys self) -> bool"""
        return _steps_swig.vector_vsys___nonzero__(self)

    def __bool__(self):
        """__bool__(vector_vsys self) -> bool"""
        return _steps_swig.vector_vsys___bool__(self)

    def __len__(self):
        """__len__(vector_vsys self) -> std::vector< steps::model::Volsys * >::size_type"""
        return _steps_swig.vector_vsys___len__(self)

    def pop(self):
        """pop(vector_vsys self) -> Volsys"""
        return _steps_swig.vector_vsys_pop(self)

    def __getslice__(self, *args):
        """__getslice__(vector_vsys self, std::vector< steps::model::Volsys * >::difference_type i, std::vector< steps::model::Volsys * >::difference_type j) -> vector_vsys"""
        return _steps_swig.vector_vsys___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(vector_vsys self, std::vector< steps::model::Volsys * >::difference_type i, std::vector< steps::model::Volsys * >::difference_type j, 
            vector_vsys v=std::vector< steps::model::Volsys *,std::allocator< steps::model::Volsys * > >())
        __setslice__(vector_vsys self, std::vector< steps::model::Volsys * >::difference_type i, std::vector< steps::model::Volsys * >::difference_type j)
        """
        return _steps_swig.vector_vsys___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(vector_vsys self, std::vector< steps::model::Volsys * >::difference_type i, std::vector< steps::model::Volsys * >::difference_type j)"""
        return _steps_swig.vector_vsys___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(vector_vsys self, std::vector< steps::model::Volsys * >::difference_type i)
        __delitem__(vector_vsys self, PySliceObject * slice)
        """
        return _steps_swig.vector_vsys___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(vector_vsys self, PySliceObject * slice) -> vector_vsys
        __getitem__(vector_vsys self, std::vector< steps::model::Volsys * >::difference_type i) -> Volsys
        """
        return _steps_swig.vector_vsys___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(vector_vsys self, PySliceObject * slice, vector_vsys v)
        __setitem__(vector_vsys self, PySliceObject * slice)
        __setitem__(vector_vsys self, std::vector< steps::model::Volsys * >::difference_type i, Volsys x)
        """
        return _steps_swig.vector_vsys___setitem__(self, *args)

    def append(self, *args):
        """append(vector_vsys self, Volsys x)"""
        return _steps_swig.vector_vsys_append(self, *args)

    def empty(self):
        """empty(vector_vsys self) -> bool"""
        return _steps_swig.vector_vsys_empty(self)

    def size(self):
        """size(vector_vsys self) -> std::vector< steps::model::Volsys * >::size_type"""
        return _steps_swig.vector_vsys_size(self)

    def clear(self):
        """clear(vector_vsys self)"""
        return _steps_swig.vector_vsys_clear(self)

    def swap(self, *args):
        """swap(vector_vsys self, vector_vsys v)"""
        return _steps_swig.vector_vsys_swap(self, *args)

    def get_allocator(self):
        """get_allocator(vector_vsys self) -> std::vector< steps::model::Volsys * >::allocator_type"""
        return _steps_swig.vector_vsys_get_allocator(self)

    def begin(self):
        """begin(vector_vsys self) -> std::vector< steps::model::Volsys * >::iterator"""
        return _steps_swig.vector_vsys_begin(self)

    def end(self):
        """end(vector_vsys self) -> std::vector< steps::model::Volsys * >::iterator"""
        return _steps_swig.vector_vsys_end(self)

    def rbegin(self):
        """rbegin(vector_vsys self) -> std::vector< steps::model::Volsys * >::reverse_iterator"""
        return _steps_swig.vector_vsys_rbegin(self)

    def rend(self):
        """rend(vector_vsys self) -> std::vector< steps::model::Volsys * >::reverse_iterator"""
        return _steps_swig.vector_vsys_rend(self)

    def pop_back(self):
        """pop_back(vector_vsys self)"""
        return _steps_swig.vector_vsys_pop_back(self)

    def erase(self, *args):
        """
        erase(vector_vsys self, std::vector< steps::model::Volsys * >::iterator pos) -> std::vector< steps::model::Volsys * >::iterator
        erase(vector_vsys self, std::vector< steps::model::Volsys * >::iterator first, std::vector< steps::model::Volsys * >::iterator last) -> std::vector< steps::model::Volsys * >::iterator
        """
        return _steps_swig.vector_vsys_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(p.steps::model::Volsys)> self) -> vector_vsys
        __init__(std::vector<(p.steps::model::Volsys)> self, vector_vsys arg2) -> vector_vsys
        __init__(std::vector<(p.steps::model::Volsys)> self, std::vector< steps::model::Volsys * >::size_type size) -> vector_vsys
        __init__(std::vector<(p.steps::model::Volsys)> self, std::vector< steps::model::Volsys * >::size_type size, Volsys value) -> vector_vsys
        """
        this = _steps_swig.new_vector_vsys(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(vector_vsys self, Volsys x)"""
        return _steps_swig.vector_vsys_push_back(self, *args)

    def front(self):
        """front(vector_vsys self) -> Volsys"""
        return _steps_swig.vector_vsys_front(self)

    def back(self):
        """back(vector_vsys self) -> Volsys"""
        return _steps_swig.vector_vsys_back(self)

    def assign(self, *args):
        """assign(vector_vsys self, std::vector< steps::model::Volsys * >::size_type n, Volsys x)"""
        return _steps_swig.vector_vsys_assign(self, *args)

    def resize(self, *args):
        """
        resize(vector_vsys self, std::vector< steps::model::Volsys * >::size_type new_size)
        resize(vector_vsys self, std::vector< steps::model::Volsys * >::size_type new_size, Volsys x)
        """
        return _steps_swig.vector_vsys_resize(self, *args)

    def insert(self, *args):
        """
        insert(vector_vsys self, std::vector< steps::model::Volsys * >::iterator pos, Volsys x) -> std::vector< steps::model::Volsys * >::iterator
        insert(vector_vsys self, std::vector< steps::model::Volsys * >::iterator pos, std::vector< steps::model::Volsys * >::size_type n, 
            Volsys x)
        """
        return _steps_swig.vector_vsys_insert(self, *args)

    def reserve(self, *args):
        """reserve(vector_vsys self, std::vector< steps::model::Volsys * >::size_type n)"""
        return _steps_swig.vector_vsys_reserve(self, *args)

    def capacity(self):
        """capacity(vector_vsys self) -> std::vector< steps::model::Volsys * >::size_type"""
        return _steps_swig.vector_vsys_capacity(self)

    __swig_destroy__ = _steps_swig.delete_vector_vsys
    __del__ = lambda self : None;
vector_vsys_swigregister = _steps_swig.vector_vsys_swigregister
vector_vsys_swigregister(vector_vsys)

class vector_ssys(_object):
    """Proxy of C++ std::vector<(p.steps::model::Surfsys)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_ssys, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_ssys, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(vector_ssys self) -> SwigPyIterator"""
        return _steps_swig.vector_ssys_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(vector_ssys self) -> bool"""
        return _steps_swig.vector_ssys___nonzero__(self)

    def __bool__(self):
        """__bool__(vector_ssys self) -> bool"""
        return _steps_swig.vector_ssys___bool__(self)

    def __len__(self):
        """__len__(vector_ssys self) -> std::vector< steps::model::Surfsys * >::size_type"""
        return _steps_swig.vector_ssys___len__(self)

    def pop(self):
        """pop(vector_ssys self) -> Surfsys"""
        return _steps_swig.vector_ssys_pop(self)

    def __getslice__(self, *args):
        """__getslice__(vector_ssys self, std::vector< steps::model::Surfsys * >::difference_type i, std::vector< steps::model::Surfsys * >::difference_type j) -> vector_ssys"""
        return _steps_swig.vector_ssys___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(vector_ssys self, std::vector< steps::model::Surfsys * >::difference_type i, std::vector< steps::model::Surfsys * >::difference_type j, 
            vector_ssys v=std::vector< steps::model::Surfsys *,std::allocator< steps::model::Surfsys * > >())
        __setslice__(vector_ssys self, std::vector< steps::model::Surfsys * >::difference_type i, std::vector< steps::model::Surfsys * >::difference_type j)
        """
        return _steps_swig.vector_ssys___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(vector_ssys self, std::vector< steps::model::Surfsys * >::difference_type i, std::vector< steps::model::Surfsys * >::difference_type j)"""
        return _steps_swig.vector_ssys___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(vector_ssys self, std::vector< steps::model::Surfsys * >::difference_type i)
        __delitem__(vector_ssys self, PySliceObject * slice)
        """
        return _steps_swig.vector_ssys___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(vector_ssys self, PySliceObject * slice) -> vector_ssys
        __getitem__(vector_ssys self, std::vector< steps::model::Surfsys * >::difference_type i) -> Surfsys
        """
        return _steps_swig.vector_ssys___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(vector_ssys self, PySliceObject * slice, vector_ssys v)
        __setitem__(vector_ssys self, PySliceObject * slice)
        __setitem__(vector_ssys self, std::vector< steps::model::Surfsys * >::difference_type i, Surfsys x)
        """
        return _steps_swig.vector_ssys___setitem__(self, *args)

    def append(self, *args):
        """append(vector_ssys self, Surfsys x)"""
        return _steps_swig.vector_ssys_append(self, *args)

    def empty(self):
        """empty(vector_ssys self) -> bool"""
        return _steps_swig.vector_ssys_empty(self)

    def size(self):
        """size(vector_ssys self) -> std::vector< steps::model::Surfsys * >::size_type"""
        return _steps_swig.vector_ssys_size(self)

    def clear(self):
        """clear(vector_ssys self)"""
        return _steps_swig.vector_ssys_clear(self)

    def swap(self, *args):
        """swap(vector_ssys self, vector_ssys v)"""
        return _steps_swig.vector_ssys_swap(self, *args)

    def get_allocator(self):
        """get_allocator(vector_ssys self) -> std::vector< steps::model::Surfsys * >::allocator_type"""
        return _steps_swig.vector_ssys_get_allocator(self)

    def begin(self):
        """begin(vector_ssys self) -> std::vector< steps::model::Surfsys * >::iterator"""
        return _steps_swig.vector_ssys_begin(self)

    def end(self):
        """end(vector_ssys self) -> std::vector< steps::model::Surfsys * >::iterator"""
        return _steps_swig.vector_ssys_end(self)

    def rbegin(self):
        """rbegin(vector_ssys self) -> std::vector< steps::model::Surfsys * >::reverse_iterator"""
        return _steps_swig.vector_ssys_rbegin(self)

    def rend(self):
        """rend(vector_ssys self) -> std::vector< steps::model::Surfsys * >::reverse_iterator"""
        return _steps_swig.vector_ssys_rend(self)

    def pop_back(self):
        """pop_back(vector_ssys self)"""
        return _steps_swig.vector_ssys_pop_back(self)

    def erase(self, *args):
        """
        erase(vector_ssys self, std::vector< steps::model::Surfsys * >::iterator pos) -> std::vector< steps::model::Surfsys * >::iterator
        erase(vector_ssys self, std::vector< steps::model::Surfsys * >::iterator first, std::vector< steps::model::Surfsys * >::iterator last) -> std::vector< steps::model::Surfsys * >::iterator
        """
        return _steps_swig.vector_ssys_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(p.steps::model::Surfsys)> self) -> vector_ssys
        __init__(std::vector<(p.steps::model::Surfsys)> self, vector_ssys arg2) -> vector_ssys
        __init__(std::vector<(p.steps::model::Surfsys)> self, std::vector< steps::model::Surfsys * >::size_type size) -> vector_ssys
        __init__(std::vector<(p.steps::model::Surfsys)> self, std::vector< steps::model::Surfsys * >::size_type size, Surfsys value) -> vector_ssys
        """
        this = _steps_swig.new_vector_ssys(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(vector_ssys self, Surfsys x)"""
        return _steps_swig.vector_ssys_push_back(self, *args)

    def front(self):
        """front(vector_ssys self) -> Surfsys"""
        return _steps_swig.vector_ssys_front(self)

    def back(self):
        """back(vector_ssys self) -> Surfsys"""
        return _steps_swig.vector_ssys_back(self)

    def assign(self, *args):
        """assign(vector_ssys self, std::vector< steps::model::Surfsys * >::size_type n, Surfsys x)"""
        return _steps_swig.vector_ssys_assign(self, *args)

    def resize(self, *args):
        """
        resize(vector_ssys self, std::vector< steps::model::Surfsys * >::size_type new_size)
        resize(vector_ssys self, std::vector< steps::model::Surfsys * >::size_type new_size, Surfsys x)
        """
        return _steps_swig.vector_ssys_resize(self, *args)

    def insert(self, *args):
        """
        insert(vector_ssys self, std::vector< steps::model::Surfsys * >::iterator pos, Surfsys x) -> std::vector< steps::model::Surfsys * >::iterator
        insert(vector_ssys self, std::vector< steps::model::Surfsys * >::iterator pos, std::vector< steps::model::Surfsys * >::size_type n, 
            Surfsys x)
        """
        return _steps_swig.vector_ssys_insert(self, *args)

    def reserve(self, *args):
        """reserve(vector_ssys self, std::vector< steps::model::Surfsys * >::size_type n)"""
        return _steps_swig.vector_ssys_reserve(self, *args)

    def capacity(self):
        """capacity(vector_ssys self) -> std::vector< steps::model::Surfsys * >::size_type"""
        return _steps_swig.vector_ssys_capacity(self)

    __swig_destroy__ = _steps_swig.delete_vector_ssys
    __del__ = lambda self : None;
vector_ssys_swigregister = _steps_swig.vector_ssys_swigregister
vector_ssys_swigregister(vector_ssys)

class Model(_object):
    """Proxy of C++ steps::model::Model class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Model, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Model, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(steps::model::Model self) -> Model"""
        this = _steps_swig.new_Model()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_Model
    __del__ = lambda self : None;
    def getSpec(self, *args):
        """
        Returns a reference to the steps.model.Spec species object with 
        identifier string spec_id (if defined).

        Syntax::

            getSpec(spec_id)

        Arguments:
            string spec_id
                     
        Return:
            steps.model.Spec

        """
        return _steps_swig.Model_getSpec(self, *args)

    def delSpec(self, *args):
        """
        Remove the steps.model.Spec species object with identifier 
        string spec_id (if defined) from the model.

        Syntax::

            delSpec(spec_id)

        Arguments:
            string spec_id

        Return:
            None

        """
        return _steps_swig.Model_delSpec(self, *args)

    def getAllSpecs(self):
        """
        Returns a list of steps.model.Spec object references of all species in the model.

        Syntax::

            getAllSpecs()
            
        Arguments:
            None
                     
        Return:
            list<steps.model.Spec>

        """
        return _steps_swig.Model_getAllSpecs(self)

    def getChan(self, *args):
        """
        Returns a reference to the steps.model.Chan channel object with
        identifier string chan_id (if defined).

        Syntax::

            getSpec(chan_id)

        Arguments:
            string chan_id
                     
        Return:
            steps.model.Chan

        """
        return _steps_swig.Model_getChan(self, *args)

    def getAllChans(self):
        """
        Returns a list of steps.model.Chan object references of all channels in the model.

        Syntax::

            getAllChans()
            
        Arguments:
            None
                     
        Return:
            list<steps.model.Chan>

        """
        return _steps_swig.Model_getAllChans(self)

    def getVolsys(self, *args):
        """
        Returns a reference to the steps.model.Volsys volume system object with 
        identifier string vsys_id (if defined).

        Syntax::

            getVolsys(vsys_id)

        Arguments:
            string vsys_id

        Return:
            steps.model.Volsys

        """
        return _steps_swig.Model_getVolsys(self, *args)

    def delVolsys(self, *args):
        """
        Remove the steps.model.Volsys volume system object with identifier string 
        vsys_id (if defined) from the model.

        Syntax::

            delVolsys(vsys_id)

        Arguments:
            string vsys_id

        Return:
            None

        """
        return _steps_swig.Model_delVolsys(self, *args)

    def getAllVolsyss(self):
        """
        Returns a list of steps.model.Volsys object references of all volume systems in the model.

        Syntax::

            getAllVolsyss()
            
        Arguments:
            None
                     
        Return:
            list<steps.model.Volsys>

        """
        return _steps_swig.Model_getAllVolsyss(self)

    def getSurfsys(self, *args):
        """
        Returns a reference to the steps.model.Surfsys surface system object with 
        identifier string ssys_id (if defined).

        Syntax::

            getSurfsys(ssys_id)

        Arguments:
            string ssys_id

        Return:
            steps.model.Surfsys

        """
        return _steps_swig.Model_getSurfsys(self, *args)

    def delSurfsys(self, *args):
        """
        Remove the steps.model.Surfsys surface system object with identifier string 
        ssys_id (if defined) from the model.

        Syntax::

            delSurfsys(ssys_id)

        Arguments:
            string ssys_id

        Return:
            None

        """
        return _steps_swig.Model_delSurfsys(self, *args)

    def getAllSurfsyss(self):
        """
        Returns a list of steps.model.Surfsys object references of all surface systems in the model.

        Syntax::

            getAllSurfsyss()
            
        Arguments:
            None
                     
        Return:
            list<steps.model.Surfsys>

        """
        return _steps_swig.Model_getAllSurfsyss(self)

Model_swigregister = _steps_swig.Model_swigregister
Model_swigregister(Model)

class Spec(_object):
    """Proxy of C++ steps::model::Spec class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Spec, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Spec, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(steps::model::Spec self, std::string const & id, Model model, int valence=0) -> Spec
        __init__(steps::model::Spec self, std::string const & id, Model model) -> Spec
        """
        this = _steps_swig.new_Spec(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_Spec
    __del__ = lambda self : None;
    def getID(self):
        """
        Get the identifier string of the species.

        Syntax::

            getID()

        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.Spec_getID(self)

    def setID(self, *args):
        """
        Set the identifier string of the species.

        Syntax::

            setID(name)

        Arguments:
            string name

        Return:
            None

        """
        return _steps_swig.Spec_setID(self, *args)

    def getModel(self):
        """
        Returns a reference to the parent steps.model.Model container object.

        Syntax::

            getModel()
            
        Arguments:
            None

        Return:
            steps.model.Model
            
        Attribute:
            model

        """
        return _steps_swig.Spec_getModel(self)

    def setValence(self, *args):
        """
        Set the valence of the species.
        			 
        Syntax::
        			 
            setValence(valence)

        Arguments:
        	int valence

        Return:
        	None

        """
        return _steps_swig.Spec_setValence(self, *args)

    def getValence(self):
        """
        Returns the valence of the species.
        	
        Syntax::
        	
        	getValence()
        			 
        Arguments:
        	None
        		
        Return:
        	int

        """
        return _steps_swig.Spec_getValence(self)

Spec_swigregister = _steps_swig.Spec_swigregister
Spec_swigregister(Spec)

class Chan(_object):
    """Proxy of C++ steps::model::Chan class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Chan, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Chan, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(steps::model::Chan self, std::string const & id, Model model) -> Chan"""
        this = _steps_swig.new_Chan(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_Chan
    __del__ = lambda self : None;
    def getID(self):
        """
        Get the identifier string of the channel.

        Syntax::

            getID()

        Arguments:
        	None
        			 
        Return:
            string

        """
        return _steps_swig.Chan_getID(self)

    def setID(self, *args):
        """
        Set the identifier string of the channel.

        Syntax::

            setID(name)

        Arguments:
            string name
        			 
        Return:
            None

        """
        return _steps_swig.Chan_setID(self, *args)

    def getModel(self):
        """
        Returns a reference to the parent steps.model.Model container object.

        Syntax::
        			 
            getModel()
        			 
        Arguments:
            None
        			 
        Return:
            steps.model.Model
        			 
        Attribute:
            model

        """
        return _steps_swig.Chan_getModel(self)

    def getChanState(self, *args):
        """
        Returns a reference to channel state of the channel with string identifier id.
        	
        Syntax::
        			 
        	getChanState(id)
        	
        Arguments:
        	string id
        		
        Return:
        	steps.model.Chanstate

        """
        return _steps_swig.Chan_getChanState(self, *args)

    def getAllChanStates(self):
        """
        Returns a list of steps.model.Chanstate object references of all channel states in the channel.
        			 
        Syntax::
        	
        	getAllChanStates()

        Arguments:
        	None
        		
        Return:
        	list<steps.model.ChanState>

        """
        return _steps_swig.Chan_getAllChanStates(self)

Chan_swigregister = _steps_swig.Chan_swigregister
Chan_swigregister(Chan)

class ChanState(Spec):
    """Proxy of C++ steps::model::ChanState class"""
    __swig_setmethods__ = {}
    for _s in [Spec]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ChanState, name, value)
    __swig_getmethods__ = {}
    for _s in [Spec]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ChanState, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        Returns the valence of the species.
        	
        Syntax::
        	
        	getValence()
        			 
        Arguments:
        	None
        		
        Return:
        	int

        """
        this = _steps_swig.new_ChanState(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_ChanState
    __del__ = lambda self : None;
    def setID(self, *args):
        """
        Set the identifier string of the channel state.
        			 
        Syntax::
        			 
            setID(name)
        			 
        Arguments:
            string name
        			 
        Return:
            None

        """
        return _steps_swig.ChanState_setID(self, *args)

    def getChan(self):
        """
        Returns a reference to the parent steps.model.Chan container object.
        			 
        Syntax::
        			 
            getChan()
        			 
        Arguments:
            None
        			 
        Return:
            steps.model.Chan

        """
        return _steps_swig.ChanState_getChan(self)

ChanState_swigregister = _steps_swig.ChanState_swigregister
ChanState_swigregister(ChanState)

class Surfsys(_object):
    """Proxy of C++ steps::model::Surfsys class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Surfsys, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Surfsys, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(steps::model::Surfsys self, std::string const & id, Model model) -> Surfsys"""
        this = _steps_swig.new_Surfsys(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_Surfsys
    __del__ = lambda self : None;
    def getID(self):
        """
        Get the identifier string of the surface system.

        Syntax::
            
            getID()

        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.Surfsys_getID(self)

    def setID(self, *args):
        """
        Set the identifier string of the surface system.

        Syntax::

            setID(name)
            
        Arguments:
            string name

        Return:
            None

        """
        return _steps_swig.Surfsys_setID(self, *args)

    def getModel(self):
        """
        Returns a reference to the parent steps.model.Model container object.

        Syntax::

            getModel()

        Arguments:
            None

        Return:
            steps.model.Model

        """
        return _steps_swig.Surfsys_getModel(self)

    def getSReac(self, *args):
        """
        Returns a reference to the steps.model.SReac surface-reaction object 
        with identifier sreac_id (if defined in the surface system).

        Syntax::

            getSReac(id)

        Arguments:
            string id

        Return:
            steps.model.SReac

        """
        return _steps_swig.Surfsys_getSReac(self, *args)

    def delSReac(self, *args):
        """
        Remove the steps.model.SReac surface-reaction object with identifier 
        id from the surface system.

        Syntax::

            delSReac(id)
            
        Arguments:
            string id

        Return:
            None

        """
        return _steps_swig.Surfsys_delSReac(self, *args)

    def getAllSReacs(self):
        """
        Returns a list of references to all steps.model.SReac surface-reaction 
        objects defined in the surface system.

        Syntax::

            getAllSReacs()

        Arguments:
            None

        Return:
            list<steps.model.SReac>

        """
        return _steps_swig.Surfsys_getAllSReacs(self)

    def getDiff(self, *args):
        """
        Returns a reference to the steps.model.Diff diffusion-rule object with 
        identifier diff_id (if defined in the surface system).

        Syntax::

            getDiff(diff_id)

        Arguments:
            string diff_id

        Return:
            steps.model.Diff

        """
        return _steps_swig.Surfsys_getDiff(self, *args)

    def delDiff(self, *args):
        """
        Remove the steps.model.Diff diffusion-rule object with identifier diff_id 
        from the surface system.

        Syntax::

            delDiff(diff_id)

        Arguments:
            string diff_id

        Return:
            None

        """
        return _steps_swig.Surfsys_delDiff(self, *args)

    def getAllDiffs(self):
        """
        Returns a list of references to all steps.model.Diff diffusion-rule objects 
        defined in the surface system.

        Syntax::

            getAllDiffs()

        Arguments:
            None

        Return:
            list<steps.model.Diff>

        """
        return _steps_swig.Surfsys_getAllDiffs(self)

    def getVDepTrans(self, *args):
        """
        Returns a reference to the steps.model.VDepTrans voltage-dependent transition object 
        with identifier id (if defined in the surface system).
        	
        Syntax::
        	
            getVDepTrans(id)
        	
        Arguments:
            string id
        	
        Return:
            steps.model.VDepTrans

        """
        return _steps_swig.Surfsys_getVDepTrans(self, *args)

    def delVDepTrans(self, *args):
        """
        Remove the steps.model.VDepTrans voltage-dependent transition object with identifier 
        id from the surface system.
        	
        Syntax::
        	
            delVDepTrans(id)
            
        Arguments:
            string id
        	
        Return:
            None

        """
        return _steps_swig.Surfsys_delVDepTrans(self, *args)

    def getAllVDepTrans(self):
        """
        Returns a list of references to all steps.model.VDepTrans voltage-dependent transition 
        objects defined in the surface system.
        			 
        Syntax::
        			 
            getAllVDepTrans()
        			 
        Arguments:
            None
        			 
        Return:
            list<steps.model.VDepTrans>

        """
        return _steps_swig.Surfsys_getAllVDepTrans(self)

    def getOhmicCurr(self, *args):
        """
        Returns a reference to the steps.model.OhmicCurr ohmic current object 
        with identifier id (if defined in the surface system).
        	
        Syntax::
        	
            getOhmicCurr(id)
        	
        Arguments:
            string id
        	
        Return:
            steps.model.OhmicCurr

        """
        return _steps_swig.Surfsys_getOhmicCurr(self, *args)

    def delOhmicCurr(self, *args):
        """
        Remove the steps.model.OhmicCurr ohmic current object with identifier 
        id from the surface system.
        	
        Syntax::
        	
            delOhmicCurr(id)
            
        Arguments:
            string id
        	
        Return:
            None

        """
        return _steps_swig.Surfsys_delOhmicCurr(self, *args)

    def getAllOhmicCurrs(self):
        """
        Returns a list of references to all steps.model.OhmicCurr ohmic current 
        objects defined in the surface system.
        			 
        Syntax::
        			 
            getAllOhmicCurrs()
        			 
        Arguments:
            None
        			 
        Return:
            list<steps.model.OhmicCurr>

        """
        return _steps_swig.Surfsys_getAllOhmicCurrs(self)

    def getGHKcurr(self, *args):
        """
        Returns a reference to the steps.model.GHKcurr ghk current object 
        with identifier id (if defined in the surface system).
        			 
        Syntax::
        			 
            getGHKcurr(id)
        			 
        Arguments:
            string id
        			 
        Return:
            steps.model.GHKcurr

        """
        return _steps_swig.Surfsys_getGHKcurr(self, *args)

    def delGHKcurr(self, *args):
        """
        Remove the steps.model.GHKcurr ghk current object with identifier 
        id from the surface system.
        			 
        Syntax::
        			 
            delGHKcurr(id)
        			 
        Arguments:
            string id
        			 
        Return:
            None

        """
        return _steps_swig.Surfsys_delGHKcurr(self, *args)

    def getAllGHKcurrs(self):
        """
        Returns a list of references to all steps.model.GHKcurr ghk current 
        objects defined in the surface system.
        			 
        Syntax::
        			 
            getAllGHKcurrs()
        			 
        Arguments:
            None
        			 
        Return:
            list<steps.model.GHKcurrs>

        """
        return _steps_swig.Surfsys_getAllGHKcurrs(self)

    def getAllSpecs(self):
        """
        Returns a list of references to all steps.model.Spec species objects included 
        in the surface system; that is all reactants and products in the surface 
        reactions belonging to this surface system. No duplicate member is included.

        Syntax::

            getAllSpecs()
            
        Arguments:
            None

        Return:
            list<steps.model.Spec>

        """
        return _steps_swig.Surfsys_getAllSpecs(self)

Surfsys_swigregister = _steps_swig.Surfsys_swigregister
Surfsys_swigregister(Surfsys)

class Volsys(_object):
    """Proxy of C++ steps::model::Volsys class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Volsys, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Volsys, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(steps::model::Volsys self, std::string const & id, Model model) -> Volsys"""
        this = _steps_swig.new_Volsys(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_Volsys
    __del__ = lambda self : None;
    def getID(self):
        """
        Get the identifier string of the volume system.

        Syntax::

            getID()
            
        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.Volsys_getID(self)

    def setID(self, *args):
        """
        Set the identifier string of the volume system.

        Syntax::

            setID(name)
            
        Arguments:
            string name

        Return:
            None

        """
        return _steps_swig.Volsys_setID(self, *args)

    def getModel(self):
        """
        Returns a reference to the parent steps.model.Model container object.

        Syntax::

            getModel()
            
        Arguments:
            None

        Return:
            steps.model.Model

        """
        return _steps_swig.Volsys_getModel(self)

    def getReac(self, *args):
        """
        Returns a reference to the steps.model.Reac reaction-rule object with 
        identifier string reac_id (if defined in the volume system).

        Syntax::

            getReac(reac_id)
            
        Arguments:
            string reac_id

        Return:
            steps.model.Reac

        """
        return _steps_swig.Volsys_getReac(self, *args)

    def delReac(self, *args):
        """
        Remove the steps.model.Reac reaction-rule object with identifier reac_id 
        (if defined) from the volume system.

        Syntax::

            delReac(reac_id)

        Arguments:
            string reac_id

        Return:
            None

        """
        return _steps_swig.Volsys_delReac(self, *args)

    def getAllReacs(self):
        """
        Returns a list of references to all steps.model.Reac objects in this volume 
        system; that is all reaction rules belonging to this volume system. No duplicate 
        member is included.

        Syntax::

            getAllReacs()
            
        Arguments:
            None

        Return:
            list<steps.model.Reac>

        """
        return _steps_swig.Volsys_getAllReacs(self)

    def getDiff(self, *args):
        """
        Returns a reference to the steps.model.Diff diffusion-rule object with 
        identifier diff_id (if defined in the volume system).

        Syntax::

            getDiff(diff_id)
            
        Arguments:
            string diff_id

        Return:
            steps.model.Diff

        """
        return _steps_swig.Volsys_getDiff(self, *args)

    def delDiff(self, *args):
        """
        Remove the steps.model.Diff diffusion-rule object with identifier diff_id 
        from the volume system.

        Syntax::

            delDiff(diff_id)
            
        Arguments:
            string diff_id

        Return:
            None

        """
        return _steps_swig.Volsys_delDiff(self, *args)

    def getAllDiffs(self):
        """
        Returns a list of references to all steps.model.Diff diffusion-rule objects 
        defined in the volume system.

        Syntax::

            getAllDiffs()
            
        Arguments:
            None

        Return:
            list<steps.model.Diff>

        """
        return _steps_swig.Volsys_getAllDiffs(self)

    def getAllSpecs(self):
        """
        Returns a list of references to all steps.model.Spec objects in this volume system; 
        that is all reactants, products or diffusing species in the reaction and diffusion 
        rules belonging to this volume system. No duplicate member is included.

        Syntax::

            getAllSpecs()
            
        Arguments:
            None

        Return:
            list<steps.model.Spec>

        """
        return _steps_swig.Volsys_getAllSpecs(self)

Volsys_swigregister = _steps_swig.Volsys_swigregister
Volsys_swigregister(Volsys)

class Diff(_object):
    """Proxy of C++ steps::model::Diff class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Diff, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Diff, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(steps::model::Diff self, std::string const & id, Volsys volsys, Spec lig, double dcst=0.0) -> Diff
        __init__(steps::model::Diff self, std::string const & id, Volsys volsys, Spec lig) -> Diff
        __init__(steps::model::Diff self, std::string const & id, Surfsys surfsys, Spec lig, double dcst=0.0) -> Diff
        __init__(steps::model::Diff self, std::string const & id, Surfsys surfsys, Spec lig) -> Diff
        """
        this = _steps_swig.new_Diff(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_Diff
    __del__ = lambda self : None;
    def getID(self):
        """
        Get the identifier string of the diffusion rule.

        Syntax::

            getID()
            
        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.Diff_getID(self)

    def setID(self, *args):
        """
        Set the identifier string of the diffusion rule.

        Syntax::

            setID(name)
            
        Arguments:
            string name

        Return:
            None

        """
        return _steps_swig.Diff_setID(self, *args)

    def getVolsys(self):
        """
        Returns a reference to the parent steps.model.Volsys volume system object if a volume diffusion object.

        Syntax::

            getVolsys()
            
        Arguments:
            None

        Return:
            steps.model.Volsys

        """
        return _steps_swig.Diff_getVolsys(self)

    def getSurfsys(self):
        """
        Returns a reference to the parent steps.model.Surfsys surface system object if surface diffusion object.

        Syntax::

            getSurfys()

        Arguments:
            None

        Return:
            steps.model.Surfsys

        """
        return _steps_swig.Diff_getSurfsys(self)

    def getModel(self):
        """
        Returns a reference to the parent steps.model.Model container object.

        Syntax::

            getModel()
            
        Arguments:
            None

        Return:
            steps.model.Model

        """
        return _steps_swig.Diff_getModel(self)

    def getLig(self):
        """
        get a reference to the steps.model.Spec species object to which this 
        diffusion rule is applied.

        Syntax::

            getLig()
            
        Arguments:
            None

        Return:
            steps.model.Spec

        """
        return _steps_swig.Diff_getLig(self)

    def setLig(self, *args):
        """
        Set a reference to the steps.model.Spec species object to which this 
        diffusion rule is applied.

        Syntax::

            setLig(lig)
            
        Arguments:
            steps.model.Spec lig

        Return:
            None

        """
        return _steps_swig.Diff_setLig(self, *args)

    def getDcst(self):
        """
        Get the diffusion constant for the diffusion rule, in s.i. units.

        Syntax::

            getDcst()
            
        Arguments:
            None

        Return:
            float

        """
        return _steps_swig.Diff_getDcst(self)

    def setDcst(self, *args):
        """
        Set the diffusion constant for the diffusion rule, in s.i. units.

        Syntax::

            setDcst(dcst)
            
        Arguments:
            float dcst

        Return:
            None

        """
        return _steps_swig.Diff_setDcst(self, *args)

Diff_swigregister = _steps_swig.Diff_swigregister
Diff_swigregister(Diff)

class Reac(_object):
    """Proxy of C++ steps::model::Reac class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Reac, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Reac, name)
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """
        __init__(steps::model::Reac self, std::string const & id, Volsys volsys, vector_spc lhs=std::vector< steps::model::Spec * >(), 
            vector_spc rhs=std::vector< steps::model::Spec * >(), double kcst=0.0) -> Reac
        """
        this = _steps_swig.new_Reac(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_Reac
    __del__ = lambda self : None;
    def getID(self):
        """
        Get the identifier string of the reaction rule.

        Syntax::

            getID()
            
        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.Reac_getID(self)

    def setID(self, *args):
        """
        Set the identifier string of the reaction rule.

        Syntax::

            setID(name)
            
        Arguments:
            string name

        Return:
            None

        """
        return _steps_swig.Reac_setID(self, *args)

    def getVolsys(self):
        """
        Returns a reference to the parent steps.model.Volsys volume system object.

        Syntax::

            getVolsys()
            
        Arguments:
            None

        Return:
            steps.model.Volsys

        """
        return _steps_swig.Reac_getVolsys(self)

    def getModel(self):
        """
        Returns a reference to the parent steps.model.Model container object.

        Syntax::

            getModel()
            
        Arguments:
            None

        Return:
            steps.model.Model

        """
        return _steps_swig.Reac_getModel(self)

    def getLHS(self):
        """
        Get a list of references to steps.model.Spec species objects on the 
        left hand side of the reaction: the reactants.

        Syntax::

            getLHS()
            
        Arguments:
            None

        Return:
            list<steps.model.Spec>

        """
        return _steps_swig.Reac_getLHS(self)

    def setLHS(self, *args):
        """
        Set a list of references to steps.model.Spec species objects on the 
        left hand side of the reaction: the reactants.

        Syntax::

            setLHS(lhs)

        Arguments:
            list<steps.model.Spec> lhs

        Return:
            None

        """
        return _steps_swig.Reac_setLHS(self, *args)

    def getRHS(self):
        """
        Get a list of references to steps.model.Spec species objects on the 
        right hand side of the reaction: the reactants.

        Syntax::

            getRHS()

        Arguments:
            None

        Return:
            list<steps.model.Spec>

        """
        return _steps_swig.Reac_getRHS(self)

    def setRHS(self, *args):
        """
        Set a list of references to steps.model.Spec species objects on the 
        right hand side of the reaction: the reactants.

        Syntax::

            setRHS(rhs)
            
        Arguments:
            list<steps.model.Spec> rhs

        Return:
            None

        """
        return _steps_swig.Reac_setRHS(self, *args)

    def getOrder(self):
        """
        Returns the order of this reaction.

        Syntax::

            getOrder()
            
        Arguments:
            None

        Return:
            int

        """
        return _steps_swig.Reac_getOrder(self)

    def getKcst(self):
        """
        Get the kinetic reaction rate constant, in s.i. units, 
        where the actual units depend on the order of the reaction.

        Syntax::
            
            getKcst()

        Arguments:
            None

        Return:
            float

        """
        return _steps_swig.Reac_getKcst(self)

    def setKcst(self, *args):
        """
        Set the kinetic reaction rate constant, in s.i. units, 
        where the actual units depend on the order of the reaction.

        Syntax::
            
            setKcst(kcst)

        Arguments:
            float kcst

        Return:
            None

        """
        return _steps_swig.Reac_setKcst(self, *args)

    def getAllSpecs(self):
        """
        Returns a list of references to all steps.model.Spec species objects in 
        the reaction; that is all reactants and products. No duplicate member 
        is included.

        Syntax::

            getAllSpecs()

        Arguments:
            None

        Return:
            list<steps.model.Spec>

        """
        return _steps_swig.Reac_getAllSpecs(self)

Reac_swigregister = _steps_swig.Reac_swigregister
Reac_swigregister(Reac)

class SReac(_object):
    """Proxy of C++ steps::model::SReac class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SReac, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SReac, name)
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """
        __init__(steps::model::SReac self, std::string const & id, Surfsys surfsys, vector_spc olhs=std::vector< steps::model::Spec * >(), 
            vector_spc ilhs=std::vector< steps::model::Spec * >(), vector_spc slhs=std::vector< steps::model::Spec * >(), 
            vector_spc irhs=std::vector< steps::model::Spec * >(), 
            vector_spc srhs=std::vector< steps::model::Spec * >(), 
            vector_spc orhs=std::vector< steps::model::Spec * >(), double kcst=0.0) -> SReac
        """
        this = _steps_swig.new_SReac(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_SReac
    __del__ = lambda self : None;
    def getID(self):
        """
        Get the identifier string of the surface reaction rule.

        Syntax::

            getID()
            
        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.SReac_getID(self)

    def setID(self, *args):
        """
        Set the identifier string of the surface reaction rule.

        Syntax::

            setID(name)
            
        Arguments:
            string name

        Return:
            None

        """
        return _steps_swig.SReac_setID(self, *args)

    def getSurfsys(self):
        """
        Returns a reference to the parent steps.model.Surfsys surface system object.

        Syntax::

            getSurfsys()
            
        Arguments:
            None

        Return:
            steps.model.Surfsys

        """
        return _steps_swig.SReac_getSurfsys(self)

    def getModel(self):
        """
        Returns a reference to the parent steps.model.Model container object of parent surface system object.

        Syntax::

            getModel()
            
        Arguments:
            None

        Return:
            steps.model.Model

        """
        return _steps_swig.SReac_getModel(self)

    def getInner(self):
        """Obsolete"""
        return _steps_swig.SReac_getInner(self)

    def getOuter(self):
        """Obsolete"""
        return _steps_swig.SReac_getOuter(self)

    def getOLHS(self):
        """
        Get a list of references to steps.model.Spec species objects; 
        the left hand side outer volume reactants.

        Syntax::

            getOLHS()
            
        Arguments:
            None

        Return:
            list<steps.model.Spec>

        """
        return _steps_swig.SReac_getOLHS(self)

    def setOLHS(self, *args):
        """
        Set a list of references to steps.model.Spec species objects; 
        the left hand side outer volume reactants.

        Syntax::

            setOLHS(olhs)
            
        Arguments:
            list<steps.model.Spec) olhs

        Return:
            None

        """
        return _steps_swig.SReac_setOLHS(self, *args)

    def getILHS(self):
        """
        Get a list of references to steps.model.Spec species objects; 
        the left hand side inner volume reactants.

        Syntax::
            
            getILHS()

        Arguments:
            None

        Return:
            list<steps.model.Spec>

        """
        return _steps_swig.SReac_getILHS(self)

    def setILHS(self, *args):
        """
        Set a list of references to steps.model.Spec species objects; 
        the left hand side inner volume reactants.

        Syntax::

            setILHS(ilhs)

        Arguments:
            list<steps.model.Spec> ilhs

        Return:
            None

        """
        return _steps_swig.SReac_setILHS(self, *args)

    def getSLHS(self):
        """
        Get a list of references to steps.model.Spec species objects; 
        the left hand side surface reactants.

        Syntax::

            getSLHS()
            
        Arguments:
            None

        Return:
            list<steps.model.Spec>

        """
        return _steps_swig.SReac_getSLHS(self)

    def setSLHS(self, *args):
        """
        Set a list of references to steps.model.Spec species objects; 
        the left hand side surface reactants.

        Syntax::

            setSLHS(slhs)
            
        Arguments:
            list<steps.model.Spec> slhs

        Return:
            None

        """
        return _steps_swig.SReac_setSLHS(self, *args)

    def getIRHS(self):
        """
        Get a list of references to steps.model.Spec species objects; 
        the right hand side inner volume reactants.

        Syntax::

            getIRHS()
            
        Arguments:
            None

        Return:
            list<steps.model.Spec>

        """
        return _steps_swig.SReac_getIRHS(self)

    def setIRHS(self, *args):
        """
        Set a list of references to steps.model.Spec species objects; 
        the right hand side inner volume reactants.

        Syntax::

            setIRHS(irhs)
            
        Arguments:
            list<steps.model.Spec> irhs

        Return:
            None

        """
        return _steps_swig.SReac_setIRHS(self, *args)

    def getSRHS(self):
        """
        Get a list of references to steps.model.Spec species objects; 
        the right hand side surface reactants.

        Syntax::
            
            getSRHS()

        Arguments:
            None

        Return:
            list<steps.model.Spec>

        """
        return _steps_swig.SReac_getSRHS(self)

    def setSRHS(self, *args):
        """
        Set a list of references to steps.model.Spec species objects; 
        the right hand side surface reactants.

        Syntax::

            setSRHS(srhs)
            
        Arguments:
            list<steps.model.Spec> srhs

        Return:
            None

        """
        return _steps_swig.SReac_setSRHS(self, *args)

    def getORHS(self):
        """
        Get a list of references to steps.model.Spec species objects; 
        the right hand side outer volume reactants.

        Syntax::

            getORHS()
            
        Arguments:
            None

        Return:
            list<steps.model.Spec>

        """
        return _steps_swig.SReac_getORHS(self)

    def setORHS(self, *args):
        """
        Get a list of references to steps.model.Spec species objects; 
        the right hand side outer volume reactants.

        Syntax::

            setORHS(orhs)
            
        Arguments:
            list<steps.model.Spec> orhs

        Return:
            None

        """
        return _steps_swig.SReac_setORHS(self, *args)

    def getOrder(self):
        """
        Returns the order of this surface reaction.

        Syntax::

            getOrder()
            
        Arguments:
            None

        Return:
            int

        """
        return _steps_swig.SReac_getOrder(self)

    def getKcst(self):
        """
        Get the kinetic reaction rate constant, in s.i. units, 
        where the actual units depend on the order of the surface reaction.

        Syntax::

            getKcst()
            
        Arguments:
            None

        Return:
            float

        """
        return _steps_swig.SReac_getKcst(self)

    def setKcst(self, *args):
        """
        Set the kinetic reaction rate constant, in s.i. units, 
        where the actual units depend on the order of the surface reaction.

        Syntax::

            setKcst(kcst)
            
        Arguments:
            float kcst

        Return:
            None

        """
        return _steps_swig.SReac_setKcst(self, *args)

    def getAllSpecs(self):
        """
        Returns a list of references to all steps.model.Spec species objects in 
        the surface reaction; that is all reactants and products. No duplicate member 
        is included.

        Syntax::

            getAllSpecs()
            
        Arguments:
            None

        Return:
            list<steps.model.Spec>

        """
        return _steps_swig.SReac_getAllSpecs(self)

SReac_swigregister = _steps_swig.SReac_swigregister
SReac_swigregister(SReac)

class VDepTrans(_object):
    """Proxy of C++ steps::model::VDepTrans class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VDepTrans, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VDepTrans, name)
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """
        __init__(steps::model::VDepTrans self, std::string const & id, Surfsys surfsys, ChanState src, ChanState dst, vector_dbl ratetab, 
            double vmin, double vmax, double dv, uint tablesize) -> VDepTrans
        """
        this = _steps_swig.new_VDepTrans(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_VDepTrans
    __del__ = lambda self : None;
    def getID(self):
        """
        Get the identifier string of the voltage-dependent transition.
        			 
        Syntax::
        			 
           getID()
        			 
        Arguments:
            None
        			 
        Return:
            string

        """
        return _steps_swig.VDepTrans_getID(self)

    def setID(self, *args):
        """
        Set the identifier string of the voltage-dependent transition.
        			 
        Syntax::
        			 
            setID(name)
        			 
        Arguments:
            string name
        			 
        Return:
            None

        """
        return _steps_swig.VDepTrans_setID(self, *args)

    def getSurfsys(self):
        """
        Returns a reference to the parent steps.model.Surfsys surface system object.
        			 
        Syntax::
        			 
            getSurfsys()
        			 
        Arguments:
            None
        			 
        Return:
            steps.model.Surfsys

        """
        return _steps_swig.VDepTrans_getSurfsys(self)

    def getModel(self):
        """
        Returns a reference to the parent steps.model.Model container object of parent surface system object.

        Syntax::

            getModel()
            
        Arguments:
            None

        Return:
            steps.model.Model

        """
        return _steps_swig.VDepTrans_getModel(self)

    def getChan(self):
        """
        Returns a reference to the steps.model.Chan container object of source and destination channel states.

        Syntax::

            getChan()
            
        Arguments:
            None

        Return:
            steps.model.Chan

        """
        return _steps_swig.VDepTrans_getChan(self)

    def getSrc(self):
        """
        Returns a reference to the 'source' (left-hand side) steps.model.ChanState object.

        Syntax::

            getSrc()
            
        Arguments:
            None

        Return:
            steps.model.ChanState

        """
        return _steps_swig.VDepTrans_getSrc(self)

    def setSrc(self, *args):
        """
        Set the 'source' (left-hand side) channel state.
        			 
        Syntax::
        			 
            setSrc(src)
        			 
        Arguments:
            steps.model.ChanState src
        			 
        Return:
            None

        """
        return _steps_swig.VDepTrans_setSrc(self, *args)

    def getDst(self):
        """
        Returns a reference to the 'destination' (right-hand side) steps.model.ChanState object.

        Syntax::

            getDst()
            
        Arguments:
            None

        Return:
            steps.model.ChanState

        """
        return _steps_swig.VDepTrans_getDst(self)

    def setDst(self, *args):
        """
        Set the 'destination' (right-hand side) channel state.
        			 
        Syntax::
        			 
            setDst(dst)
        			 
        Arguments:
            steps.model.ChanState dst
        			 
        Return:
            None

        """
        return _steps_swig.VDepTrans_setDst(self, *args)

    def getRate(self):
        """
        Return a list of transition rates in the default voltage range.
        			 
        Syntax::
            
            getRate()
        			 
        Arguments:
            None
        	
        Return:
        	list<float>

        """
        return _steps_swig.VDepTrans_getRate(self)

VDepTrans_swigregister = _steps_swig.VDepTrans_swigregister
VDepTrans_swigregister(VDepTrans)

class VDepSReac(_object):
    """Proxy of C++ steps::model::VDepSReac class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VDepSReac, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VDepSReac, name)
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """
        __init__(steps::model::VDepSReac self, std::string const & id, Surfsys surfsys, vector_spc olhs=std::vector< steps::model::Spec * >(), 
            vector_spc ilhs=std::vector< steps::model::Spec * >(), vector_spc slhs=std::vector< steps::model::Spec * >(), 
            vector_spc irhs=std::vector< steps::model::Spec * >(), 
            vector_spc srhs=std::vector< steps::model::Spec * >(), 
            vector_spc orhs=std::vector< steps::model::Spec * >(), vector_dbl ktab=std::vector< double >(), 
            double vmin=0.0, double vmax=0.0, double dv=0.0, 
            uint tablesize=0) -> VDepSReac
        """
        this = _steps_swig.new_VDepSReac(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_VDepSReac
    __del__ = lambda self : None;
    def getID(self):
        """
        Get the identifier string of the voltage-dependent reaction.
        			 
        Syntax::
        			 
           getID()
        			 
        Arguments:
            None
        			 
        Return:
            string

        """
        return _steps_swig.VDepSReac_getID(self)

    def setID(self, *args):
        """
        Set the identifier string of the voltage-dependent reaction.
        			 
        Syntax::
        			 
            setID(name)
        			 
        Arguments:
            string name
        			 
        Return:
            None

        """
        return _steps_swig.VDepSReac_setID(self, *args)

    def getSurfsys(self):
        """
        Returns a reference to the parent steps.model.Surfsys surface system object.
        			 
        Syntax::
        			 
            getSurfsys()
        			 
        Arguments:
            None
        			 
        Return:
            steps.model.Surfsys

        """
        return _steps_swig.VDepSReac_getSurfsys(self)

    def getModel(self):
        """
        Returns a reference to the parent steps.model.Model container object of parent surface system object.

        Syntax::

            getModel()
            
        Arguments:
            None

        Return:
            steps.model.Model

        """
        return _steps_swig.VDepSReac_getModel(self)

    def getOLHS(self):
        """
        Get a list of references to steps.model.Spec species objects; 
        the left hand side outer volume reactants.

        Syntax::

            getOLHS()
            
        Arguments:
            None

        Return:
            list<steps.model.Spec>

        """
        return _steps_swig.VDepSReac_getOLHS(self)

    def setOLHS(self, *args):
        """
        Set a list of references to steps.model.Spec species objects; 
        the left hand side outer volume reactants.

        Syntax::

            setOLHS(olhs)
            
        Arguments:
            list<steps.model.Spec) olhs

        Return:
            None

        """
        return _steps_swig.VDepSReac_setOLHS(self, *args)

    def getILHS(self):
        """
        Get a list of references to steps.model.Spec species objects; 
        the left hand side inner volume reactants.

        Syntax::
            
            getILHS()

        Arguments:
            None

        Return:
            list<steps.model.Spec>

        """
        return _steps_swig.VDepSReac_getILHS(self)

    def setILHS(self, *args):
        """
        Set a list of references to steps.model.Spec species objects; 
        the left hand side inner volume reactants.

        Syntax::

            setILHS(ilhs)

        Arguments:
            list<steps.model.Spec> ilhs

        Return:
            None

        """
        return _steps_swig.VDepSReac_setILHS(self, *args)

    def getSLHS(self):
        """
        Get a list of references to steps.model.Spec species objects; 
        the left hand side surface reactants.

        Syntax::

            getSLHS()
            
        Arguments:
            None

        Return:
            list<steps.model.Spec>

        """
        return _steps_swig.VDepSReac_getSLHS(self)

    def setSLHS(self, *args):
        """
        Set a list of references to steps.model.Spec species objects; 
        the left hand side surface reactants.

        Syntax::

            setSLHS(slhs)
            
        Arguments:
            list<steps.model.Spec> slhs

        Return:
            None

        """
        return _steps_swig.VDepSReac_setSLHS(self, *args)

    def getIRHS(self):
        """
        Get a list of references to steps.model.Spec species objects; 
        the right hand side inner volume reactants.

        Syntax::

            getIRHS()
            
        Arguments:
            None

        Return:
            list<steps.model.Spec>

        """
        return _steps_swig.VDepSReac_getIRHS(self)

    def setIRHS(self, *args):
        """
        Set a list of references to steps.model.Spec species objects; 
        the right hand side inner volume reactants.

        Syntax::

            setIRHS(irhs)
            
        Arguments:
            list<steps.model.Spec> irhs

        Return:
            None

        """
        return _steps_swig.VDepSReac_setIRHS(self, *args)

    def getSRHS(self):
        """
        Get a list of references to steps.model.Spec species objects; 
        the right hand side surface reactants.

        Syntax::
            
            getSRHS()

        Arguments:
            None

        Return:
            list<steps.model.Spec>

        """
        return _steps_swig.VDepSReac_getSRHS(self)

    def setSRHS(self, *args):
        """
        Set a list of references to steps.model.Spec species objects; 
        the right hand side surface reactants.

        Syntax::

            setSRHS(srhs)
            
        Arguments:
            list<steps.model.Spec> srhs

        Return:
            None

        """
        return _steps_swig.VDepSReac_setSRHS(self, *args)

    def getORHS(self):
        """
        Get a list of references to steps.model.Spec species objects; 
        the right hand side outer volume reactants.

        Syntax::

            getORHS()
            
        Arguments:
            None

        Return:
            list<steps.model.Spec>

        """
        return _steps_swig.VDepSReac_getORHS(self)

    def setORHS(self, *args):
        """
        Get a list of references to steps.model.Spec species objects; 
        the right hand side outer volume reactants.

        Syntax::

            setORHS(orhs)
            
        Arguments:
            list<steps.model.Spec> orhs

        Return:
            None

        """
        return _steps_swig.VDepSReac_setORHS(self, *args)

    def getOrder(self):
        """
        Returns the order of this voltage-dependent reaction.

        Syntax::

            getOrder()
            
        Arguments:
            None

        Return:
            int

        """
        return _steps_swig.VDepSReac_getOrder(self)

    def getK(self):
        """
        Return a list of reaction 'constants' in the default voltage range.
        			 
        Syntax::
            
            getK()
        			 
        Arguments:
            None
        	
        Return:
        	list<float>

        """
        return _steps_swig.VDepSReac_getK(self)

    def getAllSpecs(self):
        """
        Returns a list of references to all steps.model.Spec species objects in 
        the voltage-dependent reaction; that is all reactants and products. No duplicate member 
        is included.

        Syntax::

            getAllSpecs()
            
        Arguments:
            None

        Return:
            list<steps.model.Spec>

        """
        return _steps_swig.VDepSReac_getAllSpecs(self)

VDepSReac_swigregister = _steps_swig.VDepSReac_swigregister
VDepSReac_swigregister(VDepSReac)

class OhmicCurr(_object):
    """Proxy of C++ steps::model::OhmicCurr class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OhmicCurr, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OhmicCurr, name)
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """__init__(steps::model::OhmicCurr self, std::string const & id, Surfsys surfsys, ChanState chanstate, double erev, double g) -> OhmicCurr"""
        this = _steps_swig.new_OhmicCurr(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_OhmicCurr
    __del__ = lambda self : None;
    def getID(self):
        """
        Get the identifier string of the ohmic current.
        			 
        Syntax::
        			 
           getID()
        			 
        Arguments:
            None
        			 
        Return:
            string

        """
        return _steps_swig.OhmicCurr_getID(self)

    def setID(self, *args):
        """
        Set the identifier string of the ohmic current.
        			 
        Syntax::
        			 
            setID(name)
        			 
        Arguments:
            string name
        			 
        Return:
            None

        """
        return _steps_swig.OhmicCurr_setID(self, *args)

    def getSurfsys(self):
        """
        Returns a reference to the parent steps.model.Surfsys surface system object.
        			 
        Syntax::
        			 
            getSurfsys()
        			 
        Arguments:
            None
        			 
        Return:
            steps.model.Surfsys

        """
        return _steps_swig.OhmicCurr_getSurfsys(self)

    def getModel(self):
        """
        Returns a reference to the parent steps.model.Model container object of parent surface system object.

        Syntax::

            getModel()
            
        Arguments:
            None

        Return:
            steps.model.Model

        """
        return _steps_swig.OhmicCurr_getModel(self)

    def getChanState(self):
        """
        Returns a reference to the steps.model.ChanState channel state object.

        Syntax::

            getChanState()
            
        Arguments:
            None

        Return:
            steps.model.ChanState

        """
        return _steps_swig.OhmicCurr_getChanState(self)

    def setChanState(self, *args):
        """
        Set the channel state for this ohmic current.
        			 
        Syntax::
        			 
            setChanState(chanstate)
        			 
        Arguments:
            steps.model.ChanState chanstate
        			 
        Return:
            None

        """
        return _steps_swig.OhmicCurr_setChanState(self, *args)

    def getERev(self):
        """
        Returns the reversal potential of this ohmic current in volts.

        Syntax::

            getERev()
            
        Arguments:
            None

        Return:
            float

        """
        return _steps_swig.OhmicCurr_getERev(self)

    def setERev(self, *args):
        """
        Set the reveral potential for this ohmic current in volts.
        			 
        Syntax::
        			 
            setERev(erev)
        			 
        Arguments:
            flaot erev
        			 
        Return:
            None

        """
        return _steps_swig.OhmicCurr_setERev(self, *args)

    def getG(self):
        """
        Returns the single-channel conductance for this ohmic current in Siemens.

        Syntax::

            getG()
            
        Arguments:
            None

        Return:
            float

        """
        return _steps_swig.OhmicCurr_getG(self)

    def setG(self, *args):
        """
        Set the single-channel conductance for this ohmic current in Siemens.
        			 
        Syntax::
        			 
            setG(g)
        			 
        Arguments:
            flaot g
        			 
        Return:
            None

        """
        return _steps_swig.OhmicCurr_setG(self, *args)

OhmicCurr_swigregister = _steps_swig.OhmicCurr_swigregister
OhmicCurr_swigregister(OhmicCurr)

class GHKcurr(_object):
    """Proxy of C++ steps::model::GHKcurr class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GHKcurr, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GHKcurr, name)
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """
        __init__(steps::model::GHKcurr self, std::string const & id, Surfsys surfsys, ChanState chanstate, Spec ion, bool computeflux=False, 
            double virtual_oconc=-1, double vshift=0.0) -> GHKcurr
        """
        this = _steps_swig.new_GHKcurr(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_GHKcurr
    __del__ = lambda self : None;
    def getID(self):
        """
        Get the identifier string of the ghk current.
        			 
        Syntax::
        			 
           getID()
        			 
        Arguments:
            None
        			 
        Return:
            string

        """
        return _steps_swig.GHKcurr_getID(self)

    def setID(self, *args):
        """
        Set the identifier string of the ghk current.
        			 
        Syntax::
        			 
            setID(name)
        			 
        Arguments:
            string name
        			 
        Return:
            None

        """
        return _steps_swig.GHKcurr_setID(self, *args)

    def getSurfsys(self):
        """
        Returns a reference to the parent steps.model.Surfsys surface system object.
        			 
        Syntax::
        			 
            getSurfsys()
        			 
        Arguments:
            None
        			 
        Return:
            steps.model.Surfsys

        """
        return _steps_swig.GHKcurr_getSurfsys(self)

    def getModel(self):
        """
        Returns a reference to the parent steps.model.Model container object of parent surface system object.

        Syntax::

            getModel()
            
        Arguments:
            None

        Return:
            steps.model.Model

        """
        return _steps_swig.GHKcurr_getModel(self)

    def getChanState(self):
        """
        Returns a reference to the steps.model.ChanState channel state object.

        Syntax::

            getChanState()
            
        Arguments:
            None

        Return:
            steps.model.ChanState

        """
        return _steps_swig.GHKcurr_getChanState(self)

    def setChanState(self, *args):
        """
        Set the channel state for this ghk current.
        			 
        Syntax::
        			 
            setChanState(chanstate)
        			 
        Arguments:
            steps.model.ChanState chanstate
        			 
        Return:
            None

        """
        return _steps_swig.GHKcurr_setChanState(self, *args)

    def getIon(self):
        """
        Returns a reference to steps.model.Spec object- the ion of this ghk current.

        Syntax::

            getIon()
            
        Arguments:
            None

        Return:
            steps.model.Spec

        """
        return _steps_swig.GHKcurr_getIon(self)

    def setIon(self, *args):
        """
        Set the ion for this ghk current.
        			 
        Syntax::
        			 
            setIon(ion)
        			 
        Arguments:
            steps.model.Spec ion
        			 
        Return:
            None

        """
        return _steps_swig.GHKcurr_setIon(self, *args)

    def setPInfo(self, *args, **kwargs):
        """
        Supply information from a channel measurement in order to find the permeability. 
        A measured single-channel coonductance (in Siemens) should be supplied, along with the potential (in volts),
        temperature (in Kelvins), the 'outer' concentration and 'inner' concentration of ion (in molar units).

        Syntax::
        	
        	setPInfo(g, V, T, oconc, iconc)
        	
        Arguments:
        	* float g (the conductance)
        	* float V (the voltage)
        	* float T (the temperature)
        	* float oconc (the 'outer' concentration)
        	* float iconc (the 'inner' concentration)

        Return:
        	None

        """
        return _steps_swig.GHKcurr_setPInfo(self, *args, **kwargs)

    def setP(self, *args):
        """
        Set the single-channel permeability directly (units: cubic meters / second). 

        Syntax::

            setP(p)

        Arguments:
            * float p (the single-channel permeability)

        Return:
            None

        """
        return _steps_swig.GHKcurr_setP(self, *args)

GHKcurr_swigregister = _steps_swig.GHKcurr_swigregister
GHKcurr_swigregister(GHKcurr)

class set_str(_object):
    """Proxy of C++ std::set<(std::string)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, set_str, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, set_str, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(set_str self) -> SwigPyIterator"""
        return _steps_swig.set_str_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(set_str self) -> bool"""
        return _steps_swig.set_str___nonzero__(self)

    def __bool__(self):
        """__bool__(set_str self) -> bool"""
        return _steps_swig.set_str___bool__(self)

    def __len__(self):
        """__len__(set_str self) -> std::set< std::string >::size_type"""
        return _steps_swig.set_str___len__(self)

    def append(self, *args):
        """append(set_str self, std::set< std::string >::value_type x)"""
        return _steps_swig.set_str_append(self, *args)

    def __contains__(self, *args):
        """__contains__(set_str self, std::set< std::string >::value_type x) -> bool"""
        return _steps_swig.set_str___contains__(self, *args)

    def __getitem__(self, *args):
        """__getitem__(set_str self, std::set< std::string >::difference_type i) -> std::set< std::string >::value_type"""
        return _steps_swig.set_str___getitem__(self, *args)

    def add(self, *args):
        """add(set_str self, std::set< std::string >::value_type x)"""
        return _steps_swig.set_str_add(self, *args)

    def discard(self, *args):
        """discard(set_str self, std::set< std::string >::value_type x)"""
        return _steps_swig.set_str_discard(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::set<(std::string)> self, std::less< std::string > const & arg2) -> set_str
        __init__(std::set<(std::string)> self) -> set_str
        __init__(std::set<(std::string)> self, set_str arg2) -> set_str
        """
        this = _steps_swig.new_set_str(*args)
        try: self.this.append(this)
        except: self.this = this
    def empty(self):
        """empty(set_str self) -> bool"""
        return _steps_swig.set_str_empty(self)

    def size(self):
        """size(set_str self) -> std::set< std::string >::size_type"""
        return _steps_swig.set_str_size(self)

    def clear(self):
        """clear(set_str self)"""
        return _steps_swig.set_str_clear(self)

    def swap(self, *args):
        """swap(set_str self, set_str v)"""
        return _steps_swig.set_str_swap(self, *args)

    def count(self, *args):
        """count(set_str self, std::set< std::string >::key_type const & x) -> std::set< std::string >::size_type"""
        return _steps_swig.set_str_count(self, *args)

    def begin(self):
        """begin(set_str self) -> std::set< std::string >::iterator"""
        return _steps_swig.set_str_begin(self)

    def end(self):
        """end(set_str self) -> std::set< std::string >::iterator"""
        return _steps_swig.set_str_end(self)

    def rbegin(self):
        """rbegin(set_str self) -> std::set< std::string >::reverse_iterator"""
        return _steps_swig.set_str_rbegin(self)

    def rend(self):
        """rend(set_str self) -> std::set< std::string >::reverse_iterator"""
        return _steps_swig.set_str_rend(self)

    def erase(self, *args):
        """
        erase(set_str self, std::set< std::string >::key_type const & x) -> std::set< std::string >::size_type
        erase(set_str self, std::set< std::string >::iterator pos)
        erase(set_str self, std::set< std::string >::iterator first, std::set< std::string >::iterator last)
        """
        return _steps_swig.set_str_erase(self, *args)

    def find(self, *args):
        """find(set_str self, std::set< std::string >::key_type const & x) -> std::set< std::string >::iterator"""
        return _steps_swig.set_str_find(self, *args)

    def lower_bound(self, *args):
        """lower_bound(set_str self, std::set< std::string >::key_type const & x) -> std::set< std::string >::iterator"""
        return _steps_swig.set_str_lower_bound(self, *args)

    def upper_bound(self, *args):
        """upper_bound(set_str self, std::set< std::string >::key_type const & x) -> std::set< std::string >::iterator"""
        return _steps_swig.set_str_upper_bound(self, *args)

    def equal_range(self, *args):
        """equal_range(set_str self, std::set< std::string >::key_type const & x) -> std::pair< std::set< std::string >::iterator,std::set< std::string >::iterator >"""
        return _steps_swig.set_str_equal_range(self, *args)

    def insert(self, *args):
        """insert(set_str self, std::set< std::string >::value_type const & __x) -> std::pair< std::set< std::string >::iterator,bool >"""
        return _steps_swig.set_str_insert(self, *args)

    __swig_destroy__ = _steps_swig.delete_set_str
    __del__ = lambda self : None;
set_str_swigregister = _steps_swig.set_str_swigregister
set_str_swigregister(set_str)

class set_ptc(_object):
    """Proxy of C++ std::set<(p.steps::wm::Patch)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, set_ptc, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, set_ptc, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(set_ptc self) -> SwigPyIterator"""
        return _steps_swig.set_ptc_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(set_ptc self) -> bool"""
        return _steps_swig.set_ptc___nonzero__(self)

    def __bool__(self):
        """__bool__(set_ptc self) -> bool"""
        return _steps_swig.set_ptc___bool__(self)

    def __len__(self):
        """__len__(set_ptc self) -> std::set< steps::wm::Patch * >::size_type"""
        return _steps_swig.set_ptc___len__(self)

    def append(self, *args):
        """append(set_ptc self, Patch x)"""
        return _steps_swig.set_ptc_append(self, *args)

    def __contains__(self, *args):
        """__contains__(set_ptc self, Patch x) -> bool"""
        return _steps_swig.set_ptc___contains__(self, *args)

    def __getitem__(self, *args):
        """__getitem__(set_ptc self, std::set< steps::wm::Patch * >::difference_type i) -> Patch"""
        return _steps_swig.set_ptc___getitem__(self, *args)

    def add(self, *args):
        """add(set_ptc self, Patch x)"""
        return _steps_swig.set_ptc_add(self, *args)

    def discard(self, *args):
        """discard(set_ptc self, Patch x)"""
        return _steps_swig.set_ptc_discard(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::set<(p.steps::wm::Patch)> self, std::less< steps::wm::Patch * > const & arg2) -> set_ptc
        __init__(std::set<(p.steps::wm::Patch)> self) -> set_ptc
        __init__(std::set<(p.steps::wm::Patch)> self, set_ptc arg2) -> set_ptc
        """
        this = _steps_swig.new_set_ptc(*args)
        try: self.this.append(this)
        except: self.this = this
    def empty(self):
        """empty(set_ptc self) -> bool"""
        return _steps_swig.set_ptc_empty(self)

    def size(self):
        """size(set_ptc self) -> std::set< steps::wm::Patch * >::size_type"""
        return _steps_swig.set_ptc_size(self)

    def clear(self):
        """clear(set_ptc self)"""
        return _steps_swig.set_ptc_clear(self)

    def swap(self, *args):
        """swap(set_ptc self, set_ptc v)"""
        return _steps_swig.set_ptc_swap(self, *args)

    def count(self, *args):
        """count(set_ptc self, Patch x) -> std::set< steps::wm::Patch * >::size_type"""
        return _steps_swig.set_ptc_count(self, *args)

    def begin(self):
        """begin(set_ptc self) -> std::set< steps::wm::Patch * >::iterator"""
        return _steps_swig.set_ptc_begin(self)

    def end(self):
        """end(set_ptc self) -> std::set< steps::wm::Patch * >::iterator"""
        return _steps_swig.set_ptc_end(self)

    def rbegin(self):
        """rbegin(set_ptc self) -> std::set< steps::wm::Patch * >::reverse_iterator"""
        return _steps_swig.set_ptc_rbegin(self)

    def rend(self):
        """rend(set_ptc self) -> std::set< steps::wm::Patch * >::reverse_iterator"""
        return _steps_swig.set_ptc_rend(self)

    def erase(self, *args):
        """
        erase(set_ptc self, Patch x) -> std::set< steps::wm::Patch * >::size_type
        erase(set_ptc self, std::set< steps::wm::Patch * >::iterator pos)
        erase(set_ptc self, std::set< steps::wm::Patch * >::iterator first, std::set< steps::wm::Patch * >::iterator last)
        """
        return _steps_swig.set_ptc_erase(self, *args)

    def find(self, *args):
        """find(set_ptc self, Patch x) -> std::set< steps::wm::Patch * >::iterator"""
        return _steps_swig.set_ptc_find(self, *args)

    def lower_bound(self, *args):
        """lower_bound(set_ptc self, Patch x) -> std::set< steps::wm::Patch * >::iterator"""
        return _steps_swig.set_ptc_lower_bound(self, *args)

    def upper_bound(self, *args):
        """upper_bound(set_ptc self, Patch x) -> std::set< steps::wm::Patch * >::iterator"""
        return _steps_swig.set_ptc_upper_bound(self, *args)

    def equal_range(self, *args):
        """equal_range(set_ptc self, Patch x) -> std::pair< std::set< steps::wm::Patch * >::iterator,std::set< steps::wm::Patch * >::iterator >"""
        return _steps_swig.set_ptc_equal_range(self, *args)

    def insert(self, *args):
        """insert(set_ptc self, Patch __x) -> std::pair< std::set< steps::wm::Patch * >::iterator,bool >"""
        return _steps_swig.set_ptc_insert(self, *args)

    __swig_destroy__ = _steps_swig.delete_set_ptc
    __del__ = lambda self : None;
set_ptc_swigregister = _steps_swig.set_ptc_swigregister
set_ptc_swigregister(set_ptc)

class set_uint(_object):
    """Proxy of C++ std::set<(unsigned int)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, set_uint, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, set_uint, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(set_uint self) -> SwigPyIterator"""
        return _steps_swig.set_uint_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(set_uint self) -> bool"""
        return _steps_swig.set_uint___nonzero__(self)

    def __bool__(self):
        """__bool__(set_uint self) -> bool"""
        return _steps_swig.set_uint___bool__(self)

    def __len__(self):
        """__len__(set_uint self) -> std::set< unsigned int >::size_type"""
        return _steps_swig.set_uint___len__(self)

    def append(self, *args):
        """append(set_uint self, std::set< unsigned int >::value_type x)"""
        return _steps_swig.set_uint_append(self, *args)

    def __contains__(self, *args):
        """__contains__(set_uint self, std::set< unsigned int >::value_type x) -> bool"""
        return _steps_swig.set_uint___contains__(self, *args)

    def __getitem__(self, *args):
        """__getitem__(set_uint self, std::set< unsigned int >::difference_type i) -> std::set< unsigned int >::value_type"""
        return _steps_swig.set_uint___getitem__(self, *args)

    def add(self, *args):
        """add(set_uint self, std::set< unsigned int >::value_type x)"""
        return _steps_swig.set_uint_add(self, *args)

    def discard(self, *args):
        """discard(set_uint self, std::set< unsigned int >::value_type x)"""
        return _steps_swig.set_uint_discard(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::set<(unsigned int)> self, std::less< unsigned int > const & arg2) -> set_uint
        __init__(std::set<(unsigned int)> self) -> set_uint
        __init__(std::set<(unsigned int)> self, set_uint arg2) -> set_uint
        """
        this = _steps_swig.new_set_uint(*args)
        try: self.this.append(this)
        except: self.this = this
    def empty(self):
        """empty(set_uint self) -> bool"""
        return _steps_swig.set_uint_empty(self)

    def size(self):
        """size(set_uint self) -> std::set< unsigned int >::size_type"""
        return _steps_swig.set_uint_size(self)

    def clear(self):
        """clear(set_uint self)"""
        return _steps_swig.set_uint_clear(self)

    def swap(self, *args):
        """swap(set_uint self, set_uint v)"""
        return _steps_swig.set_uint_swap(self, *args)

    def count(self, *args):
        """count(set_uint self, std::set< unsigned int >::key_type const & x) -> std::set< unsigned int >::size_type"""
        return _steps_swig.set_uint_count(self, *args)

    def begin(self):
        """begin(set_uint self) -> std::set< unsigned int >::iterator"""
        return _steps_swig.set_uint_begin(self)

    def end(self):
        """end(set_uint self) -> std::set< unsigned int >::iterator"""
        return _steps_swig.set_uint_end(self)

    def rbegin(self):
        """rbegin(set_uint self) -> std::set< unsigned int >::reverse_iterator"""
        return _steps_swig.set_uint_rbegin(self)

    def rend(self):
        """rend(set_uint self) -> std::set< unsigned int >::reverse_iterator"""
        return _steps_swig.set_uint_rend(self)

    def erase(self, *args):
        """
        erase(set_uint self, std::set< unsigned int >::key_type const & x) -> std::set< unsigned int >::size_type
        erase(set_uint self, std::set< unsigned int >::iterator pos)
        erase(set_uint self, std::set< unsigned int >::iterator first, std::set< unsigned int >::iterator last)
        """
        return _steps_swig.set_uint_erase(self, *args)

    def find(self, *args):
        """find(set_uint self, std::set< unsigned int >::key_type const & x) -> std::set< unsigned int >::iterator"""
        return _steps_swig.set_uint_find(self, *args)

    def lower_bound(self, *args):
        """lower_bound(set_uint self, std::set< unsigned int >::key_type const & x) -> std::set< unsigned int >::iterator"""
        return _steps_swig.set_uint_lower_bound(self, *args)

    def upper_bound(self, *args):
        """upper_bound(set_uint self, std::set< unsigned int >::key_type const & x) -> std::set< unsigned int >::iterator"""
        return _steps_swig.set_uint_upper_bound(self, *args)

    def equal_range(self, *args):
        """equal_range(set_uint self, std::set< unsigned int >::key_type const & x) -> std::pair< std::set< unsigned int >::iterator,std::set< unsigned int >::iterator >"""
        return _steps_swig.set_uint_equal_range(self, *args)

    def insert(self, *args):
        """insert(set_uint self, std::set< unsigned int >::value_type const & __x) -> std::pair< std::set< unsigned int >::iterator,bool >"""
        return _steps_swig.set_uint_insert(self, *args)

    __swig_destroy__ = _steps_swig.delete_set_uint
    __del__ = lambda self : None;
set_uint_swigregister = _steps_swig.set_uint_swigregister
set_uint_swigregister(set_uint)

class vector_ptc(_object):
    """Proxy of C++ std::vector<(p.steps::wm::Patch)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_ptc, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_ptc, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(vector_ptc self) -> SwigPyIterator"""
        return _steps_swig.vector_ptc_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(vector_ptc self) -> bool"""
        return _steps_swig.vector_ptc___nonzero__(self)

    def __bool__(self):
        """__bool__(vector_ptc self) -> bool"""
        return _steps_swig.vector_ptc___bool__(self)

    def __len__(self):
        """__len__(vector_ptc self) -> std::vector< steps::wm::Patch * >::size_type"""
        return _steps_swig.vector_ptc___len__(self)

    def pop(self):
        """pop(vector_ptc self) -> Patch"""
        return _steps_swig.vector_ptc_pop(self)

    def __getslice__(self, *args):
        """__getslice__(vector_ptc self, std::vector< steps::wm::Patch * >::difference_type i, std::vector< steps::wm::Patch * >::difference_type j) -> vector_ptc"""
        return _steps_swig.vector_ptc___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(vector_ptc self, std::vector< steps::wm::Patch * >::difference_type i, std::vector< steps::wm::Patch * >::difference_type j, 
            vector_ptc v=std::vector< steps::wm::Patch *,std::allocator< steps::wm::Patch * > >())
        __setslice__(vector_ptc self, std::vector< steps::wm::Patch * >::difference_type i, std::vector< steps::wm::Patch * >::difference_type j)
        """
        return _steps_swig.vector_ptc___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(vector_ptc self, std::vector< steps::wm::Patch * >::difference_type i, std::vector< steps::wm::Patch * >::difference_type j)"""
        return _steps_swig.vector_ptc___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(vector_ptc self, std::vector< steps::wm::Patch * >::difference_type i)
        __delitem__(vector_ptc self, PySliceObject * slice)
        """
        return _steps_swig.vector_ptc___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(vector_ptc self, PySliceObject * slice) -> vector_ptc
        __getitem__(vector_ptc self, std::vector< steps::wm::Patch * >::difference_type i) -> Patch
        """
        return _steps_swig.vector_ptc___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(vector_ptc self, PySliceObject * slice, vector_ptc v)
        __setitem__(vector_ptc self, PySliceObject * slice)
        __setitem__(vector_ptc self, std::vector< steps::wm::Patch * >::difference_type i, Patch x)
        """
        return _steps_swig.vector_ptc___setitem__(self, *args)

    def append(self, *args):
        """append(vector_ptc self, Patch x)"""
        return _steps_swig.vector_ptc_append(self, *args)

    def empty(self):
        """empty(vector_ptc self) -> bool"""
        return _steps_swig.vector_ptc_empty(self)

    def size(self):
        """size(vector_ptc self) -> std::vector< steps::wm::Patch * >::size_type"""
        return _steps_swig.vector_ptc_size(self)

    def clear(self):
        """clear(vector_ptc self)"""
        return _steps_swig.vector_ptc_clear(self)

    def swap(self, *args):
        """swap(vector_ptc self, vector_ptc v)"""
        return _steps_swig.vector_ptc_swap(self, *args)

    def get_allocator(self):
        """get_allocator(vector_ptc self) -> std::vector< steps::wm::Patch * >::allocator_type"""
        return _steps_swig.vector_ptc_get_allocator(self)

    def begin(self):
        """begin(vector_ptc self) -> std::vector< steps::wm::Patch * >::iterator"""
        return _steps_swig.vector_ptc_begin(self)

    def end(self):
        """end(vector_ptc self) -> std::vector< steps::wm::Patch * >::iterator"""
        return _steps_swig.vector_ptc_end(self)

    def rbegin(self):
        """rbegin(vector_ptc self) -> std::vector< steps::wm::Patch * >::reverse_iterator"""
        return _steps_swig.vector_ptc_rbegin(self)

    def rend(self):
        """rend(vector_ptc self) -> std::vector< steps::wm::Patch * >::reverse_iterator"""
        return _steps_swig.vector_ptc_rend(self)

    def pop_back(self):
        """pop_back(vector_ptc self)"""
        return _steps_swig.vector_ptc_pop_back(self)

    def erase(self, *args):
        """
        erase(vector_ptc self, std::vector< steps::wm::Patch * >::iterator pos) -> std::vector< steps::wm::Patch * >::iterator
        erase(vector_ptc self, std::vector< steps::wm::Patch * >::iterator first, std::vector< steps::wm::Patch * >::iterator last) -> std::vector< steps::wm::Patch * >::iterator
        """
        return _steps_swig.vector_ptc_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(p.steps::wm::Patch)> self) -> vector_ptc
        __init__(std::vector<(p.steps::wm::Patch)> self, vector_ptc arg2) -> vector_ptc
        __init__(std::vector<(p.steps::wm::Patch)> self, std::vector< steps::wm::Patch * >::size_type size) -> vector_ptc
        __init__(std::vector<(p.steps::wm::Patch)> self, std::vector< steps::wm::Patch * >::size_type size, Patch value) -> vector_ptc
        """
        this = _steps_swig.new_vector_ptc(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(vector_ptc self, Patch x)"""
        return _steps_swig.vector_ptc_push_back(self, *args)

    def front(self):
        """front(vector_ptc self) -> Patch"""
        return _steps_swig.vector_ptc_front(self)

    def back(self):
        """back(vector_ptc self) -> Patch"""
        return _steps_swig.vector_ptc_back(self)

    def assign(self, *args):
        """assign(vector_ptc self, std::vector< steps::wm::Patch * >::size_type n, Patch x)"""
        return _steps_swig.vector_ptc_assign(self, *args)

    def resize(self, *args):
        """
        resize(vector_ptc self, std::vector< steps::wm::Patch * >::size_type new_size)
        resize(vector_ptc self, std::vector< steps::wm::Patch * >::size_type new_size, Patch x)
        """
        return _steps_swig.vector_ptc_resize(self, *args)

    def insert(self, *args):
        """
        insert(vector_ptc self, std::vector< steps::wm::Patch * >::iterator pos, Patch x) -> std::vector< steps::wm::Patch * >::iterator
        insert(vector_ptc self, std::vector< steps::wm::Patch * >::iterator pos, std::vector< steps::wm::Patch * >::size_type n, 
            Patch x)
        """
        return _steps_swig.vector_ptc_insert(self, *args)

    def reserve(self, *args):
        """reserve(vector_ptc self, std::vector< steps::wm::Patch * >::size_type n)"""
        return _steps_swig.vector_ptc_reserve(self, *args)

    def capacity(self):
        """capacity(vector_ptc self) -> std::vector< steps::wm::Patch * >::size_type"""
        return _steps_swig.vector_ptc_capacity(self)

    __swig_destroy__ = _steps_swig.delete_vector_ptc
    __del__ = lambda self : None;
vector_ptc_swigregister = _steps_swig.vector_ptc_swigregister
vector_ptc_swigregister(vector_ptc)

class vector_cmp(_object):
    """Proxy of C++ std::vector<(p.steps::wm::Comp)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_cmp, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_cmp, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(vector_cmp self) -> SwigPyIterator"""
        return _steps_swig.vector_cmp_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(vector_cmp self) -> bool"""
        return _steps_swig.vector_cmp___nonzero__(self)

    def __bool__(self):
        """__bool__(vector_cmp self) -> bool"""
        return _steps_swig.vector_cmp___bool__(self)

    def __len__(self):
        """__len__(vector_cmp self) -> std::vector< steps::wm::Comp * >::size_type"""
        return _steps_swig.vector_cmp___len__(self)

    def pop(self):
        """pop(vector_cmp self) -> Comp"""
        return _steps_swig.vector_cmp_pop(self)

    def __getslice__(self, *args):
        """__getslice__(vector_cmp self, std::vector< steps::wm::Comp * >::difference_type i, std::vector< steps::wm::Comp * >::difference_type j) -> vector_cmp"""
        return _steps_swig.vector_cmp___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(vector_cmp self, std::vector< steps::wm::Comp * >::difference_type i, std::vector< steps::wm::Comp * >::difference_type j, 
            vector_cmp v=std::vector< steps::wm::Comp *,std::allocator< steps::wm::Comp * > >())
        __setslice__(vector_cmp self, std::vector< steps::wm::Comp * >::difference_type i, std::vector< steps::wm::Comp * >::difference_type j)
        """
        return _steps_swig.vector_cmp___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(vector_cmp self, std::vector< steps::wm::Comp * >::difference_type i, std::vector< steps::wm::Comp * >::difference_type j)"""
        return _steps_swig.vector_cmp___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(vector_cmp self, std::vector< steps::wm::Comp * >::difference_type i)
        __delitem__(vector_cmp self, PySliceObject * slice)
        """
        return _steps_swig.vector_cmp___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(vector_cmp self, PySliceObject * slice) -> vector_cmp
        __getitem__(vector_cmp self, std::vector< steps::wm::Comp * >::difference_type i) -> Comp
        """
        return _steps_swig.vector_cmp___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(vector_cmp self, PySliceObject * slice, vector_cmp v)
        __setitem__(vector_cmp self, PySliceObject * slice)
        __setitem__(vector_cmp self, std::vector< steps::wm::Comp * >::difference_type i, Comp x)
        """
        return _steps_swig.vector_cmp___setitem__(self, *args)

    def append(self, *args):
        """append(vector_cmp self, Comp x)"""
        return _steps_swig.vector_cmp_append(self, *args)

    def empty(self):
        """empty(vector_cmp self) -> bool"""
        return _steps_swig.vector_cmp_empty(self)

    def size(self):
        """size(vector_cmp self) -> std::vector< steps::wm::Comp * >::size_type"""
        return _steps_swig.vector_cmp_size(self)

    def clear(self):
        """clear(vector_cmp self)"""
        return _steps_swig.vector_cmp_clear(self)

    def swap(self, *args):
        """swap(vector_cmp self, vector_cmp v)"""
        return _steps_swig.vector_cmp_swap(self, *args)

    def get_allocator(self):
        """get_allocator(vector_cmp self) -> std::vector< steps::wm::Comp * >::allocator_type"""
        return _steps_swig.vector_cmp_get_allocator(self)

    def begin(self):
        """begin(vector_cmp self) -> std::vector< steps::wm::Comp * >::iterator"""
        return _steps_swig.vector_cmp_begin(self)

    def end(self):
        """end(vector_cmp self) -> std::vector< steps::wm::Comp * >::iterator"""
        return _steps_swig.vector_cmp_end(self)

    def rbegin(self):
        """rbegin(vector_cmp self) -> std::vector< steps::wm::Comp * >::reverse_iterator"""
        return _steps_swig.vector_cmp_rbegin(self)

    def rend(self):
        """rend(vector_cmp self) -> std::vector< steps::wm::Comp * >::reverse_iterator"""
        return _steps_swig.vector_cmp_rend(self)

    def pop_back(self):
        """pop_back(vector_cmp self)"""
        return _steps_swig.vector_cmp_pop_back(self)

    def erase(self, *args):
        """
        erase(vector_cmp self, std::vector< steps::wm::Comp * >::iterator pos) -> std::vector< steps::wm::Comp * >::iterator
        erase(vector_cmp self, std::vector< steps::wm::Comp * >::iterator first, std::vector< steps::wm::Comp * >::iterator last) -> std::vector< steps::wm::Comp * >::iterator
        """
        return _steps_swig.vector_cmp_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(p.steps::wm::Comp)> self) -> vector_cmp
        __init__(std::vector<(p.steps::wm::Comp)> self, vector_cmp arg2) -> vector_cmp
        __init__(std::vector<(p.steps::wm::Comp)> self, std::vector< steps::wm::Comp * >::size_type size) -> vector_cmp
        __init__(std::vector<(p.steps::wm::Comp)> self, std::vector< steps::wm::Comp * >::size_type size, Comp value) -> vector_cmp
        """
        this = _steps_swig.new_vector_cmp(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(vector_cmp self, Comp x)"""
        return _steps_swig.vector_cmp_push_back(self, *args)

    def front(self):
        """front(vector_cmp self) -> Comp"""
        return _steps_swig.vector_cmp_front(self)

    def back(self):
        """back(vector_cmp self) -> Comp"""
        return _steps_swig.vector_cmp_back(self)

    def assign(self, *args):
        """assign(vector_cmp self, std::vector< steps::wm::Comp * >::size_type n, Comp x)"""
        return _steps_swig.vector_cmp_assign(self, *args)

    def resize(self, *args):
        """
        resize(vector_cmp self, std::vector< steps::wm::Comp * >::size_type new_size)
        resize(vector_cmp self, std::vector< steps::wm::Comp * >::size_type new_size, Comp x)
        """
        return _steps_swig.vector_cmp_resize(self, *args)

    def insert(self, *args):
        """
        insert(vector_cmp self, std::vector< steps::wm::Comp * >::iterator pos, Comp x) -> std::vector< steps::wm::Comp * >::iterator
        insert(vector_cmp self, std::vector< steps::wm::Comp * >::iterator pos, std::vector< steps::wm::Comp * >::size_type n, 
            Comp x)
        """
        return _steps_swig.vector_cmp_insert(self, *args)

    def reserve(self, *args):
        """reserve(vector_cmp self, std::vector< steps::wm::Comp * >::size_type n)"""
        return _steps_swig.vector_cmp_reserve(self, *args)

    def capacity(self):
        """capacity(vector_cmp self) -> std::vector< steps::wm::Comp * >::size_type"""
        return _steps_swig.vector_cmp_capacity(self)

    __swig_destroy__ = _steps_swig.delete_vector_cmp
    __del__ = lambda self : None;
vector_cmp_swigregister = _steps_swig.vector_cmp_swigregister
vector_cmp_swigregister(vector_cmp)

class vector_tmp(_object):
    """Proxy of C++ std::vector<(p.steps::tetmesh::TmPatch)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_tmp, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_tmp, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(vector_tmp self) -> SwigPyIterator"""
        return _steps_swig.vector_tmp_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(vector_tmp self) -> bool"""
        return _steps_swig.vector_tmp___nonzero__(self)

    def __bool__(self):
        """__bool__(vector_tmp self) -> bool"""
        return _steps_swig.vector_tmp___bool__(self)

    def __len__(self):
        """__len__(vector_tmp self) -> std::vector< steps::tetmesh::TmPatch * >::size_type"""
        return _steps_swig.vector_tmp___len__(self)

    def pop(self):
        """pop(vector_tmp self) -> TmPatch"""
        return _steps_swig.vector_tmp_pop(self)

    def __getslice__(self, *args):
        """__getslice__(vector_tmp self, std::vector< steps::tetmesh::TmPatch * >::difference_type i, std::vector< steps::tetmesh::TmPatch * >::difference_type j) -> vector_tmp"""
        return _steps_swig.vector_tmp___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(vector_tmp self, std::vector< steps::tetmesh::TmPatch * >::difference_type i, std::vector< steps::tetmesh::TmPatch * >::difference_type j, 
            vector_tmp v=std::vector< steps::tetmesh::TmPatch *,std::allocator< steps::tetmesh::TmPatch * > >())
        __setslice__(vector_tmp self, std::vector< steps::tetmesh::TmPatch * >::difference_type i, std::vector< steps::tetmesh::TmPatch * >::difference_type j)
        """
        return _steps_swig.vector_tmp___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(vector_tmp self, std::vector< steps::tetmesh::TmPatch * >::difference_type i, std::vector< steps::tetmesh::TmPatch * >::difference_type j)"""
        return _steps_swig.vector_tmp___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(vector_tmp self, std::vector< steps::tetmesh::TmPatch * >::difference_type i)
        __delitem__(vector_tmp self, PySliceObject * slice)
        """
        return _steps_swig.vector_tmp___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(vector_tmp self, PySliceObject * slice) -> vector_tmp
        __getitem__(vector_tmp self, std::vector< steps::tetmesh::TmPatch * >::difference_type i) -> TmPatch
        """
        return _steps_swig.vector_tmp___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(vector_tmp self, PySliceObject * slice, vector_tmp v)
        __setitem__(vector_tmp self, PySliceObject * slice)
        __setitem__(vector_tmp self, std::vector< steps::tetmesh::TmPatch * >::difference_type i, TmPatch x)
        """
        return _steps_swig.vector_tmp___setitem__(self, *args)

    def append(self, *args):
        """append(vector_tmp self, TmPatch x)"""
        return _steps_swig.vector_tmp_append(self, *args)

    def empty(self):
        """empty(vector_tmp self) -> bool"""
        return _steps_swig.vector_tmp_empty(self)

    def size(self):
        """size(vector_tmp self) -> std::vector< steps::tetmesh::TmPatch * >::size_type"""
        return _steps_swig.vector_tmp_size(self)

    def clear(self):
        """clear(vector_tmp self)"""
        return _steps_swig.vector_tmp_clear(self)

    def swap(self, *args):
        """swap(vector_tmp self, vector_tmp v)"""
        return _steps_swig.vector_tmp_swap(self, *args)

    def get_allocator(self):
        """get_allocator(vector_tmp self) -> std::vector< steps::tetmesh::TmPatch * >::allocator_type"""
        return _steps_swig.vector_tmp_get_allocator(self)

    def begin(self):
        """begin(vector_tmp self) -> std::vector< steps::tetmesh::TmPatch * >::iterator"""
        return _steps_swig.vector_tmp_begin(self)

    def end(self):
        """end(vector_tmp self) -> std::vector< steps::tetmesh::TmPatch * >::iterator"""
        return _steps_swig.vector_tmp_end(self)

    def rbegin(self):
        """rbegin(vector_tmp self) -> std::vector< steps::tetmesh::TmPatch * >::reverse_iterator"""
        return _steps_swig.vector_tmp_rbegin(self)

    def rend(self):
        """rend(vector_tmp self) -> std::vector< steps::tetmesh::TmPatch * >::reverse_iterator"""
        return _steps_swig.vector_tmp_rend(self)

    def pop_back(self):
        """pop_back(vector_tmp self)"""
        return _steps_swig.vector_tmp_pop_back(self)

    def erase(self, *args):
        """
        erase(vector_tmp self, std::vector< steps::tetmesh::TmPatch * >::iterator pos) -> std::vector< steps::tetmesh::TmPatch * >::iterator
        erase(vector_tmp self, std::vector< steps::tetmesh::TmPatch * >::iterator first, std::vector< steps::tetmesh::TmPatch * >::iterator last) -> std::vector< steps::tetmesh::TmPatch * >::iterator
        """
        return _steps_swig.vector_tmp_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(p.steps::tetmesh::TmPatch)> self) -> vector_tmp
        __init__(std::vector<(p.steps::tetmesh::TmPatch)> self, vector_tmp arg2) -> vector_tmp
        __init__(std::vector<(p.steps::tetmesh::TmPatch)> self, std::vector< steps::tetmesh::TmPatch * >::size_type size) -> vector_tmp
        __init__(std::vector<(p.steps::tetmesh::TmPatch)> self, std::vector< steps::tetmesh::TmPatch * >::size_type size, TmPatch value) -> vector_tmp
        """
        this = _steps_swig.new_vector_tmp(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(vector_tmp self, TmPatch x)"""
        return _steps_swig.vector_tmp_push_back(self, *args)

    def front(self):
        """front(vector_tmp self) -> TmPatch"""
        return _steps_swig.vector_tmp_front(self)

    def back(self):
        """back(vector_tmp self) -> TmPatch"""
        return _steps_swig.vector_tmp_back(self)

    def assign(self, *args):
        """assign(vector_tmp self, std::vector< steps::tetmesh::TmPatch * >::size_type n, TmPatch x)"""
        return _steps_swig.vector_tmp_assign(self, *args)

    def resize(self, *args):
        """
        resize(vector_tmp self, std::vector< steps::tetmesh::TmPatch * >::size_type new_size)
        resize(vector_tmp self, std::vector< steps::tetmesh::TmPatch * >::size_type new_size, TmPatch x)
        """
        return _steps_swig.vector_tmp_resize(self, *args)

    def insert(self, *args):
        """
        insert(vector_tmp self, std::vector< steps::tetmesh::TmPatch * >::iterator pos, TmPatch x) -> std::vector< steps::tetmesh::TmPatch * >::iterator
        insert(vector_tmp self, std::vector< steps::tetmesh::TmPatch * >::iterator pos, std::vector< steps::tetmesh::TmPatch * >::size_type n, 
            TmPatch x)
        """
        return _steps_swig.vector_tmp_insert(self, *args)

    def reserve(self, *args):
        """reserve(vector_tmp self, std::vector< steps::tetmesh::TmPatch * >::size_type n)"""
        return _steps_swig.vector_tmp_reserve(self, *args)

    def capacity(self):
        """capacity(vector_tmp self) -> std::vector< steps::tetmesh::TmPatch * >::size_type"""
        return _steps_swig.vector_tmp_capacity(self)

    __swig_destroy__ = _steps_swig.delete_vector_tmp
    __del__ = lambda self : None;
vector_tmp_swigregister = _steps_swig.vector_tmp_swigregister
vector_tmp_swigregister(vector_tmp)

class vector_db(_object):
    """Proxy of C++ std::vector<(p.steps::tetmesh::DiffBoundary)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_db, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_db, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(vector_db self) -> SwigPyIterator"""
        return _steps_swig.vector_db_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(vector_db self) -> bool"""
        return _steps_swig.vector_db___nonzero__(self)

    def __bool__(self):
        """__bool__(vector_db self) -> bool"""
        return _steps_swig.vector_db___bool__(self)

    def __len__(self):
        """__len__(vector_db self) -> std::vector< steps::tetmesh::DiffBoundary * >::size_type"""
        return _steps_swig.vector_db___len__(self)

    def pop(self):
        """pop(vector_db self) -> DiffBoundary"""
        return _steps_swig.vector_db_pop(self)

    def __getslice__(self, *args):
        """__getslice__(vector_db self, std::vector< steps::tetmesh::DiffBoundary * >::difference_type i, std::vector< steps::tetmesh::DiffBoundary * >::difference_type j) -> vector_db"""
        return _steps_swig.vector_db___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(vector_db self, std::vector< steps::tetmesh::DiffBoundary * >::difference_type i, std::vector< steps::tetmesh::DiffBoundary * >::difference_type j, 
            vector_db v=std::vector< steps::tetmesh::DiffBoundary *,std::allocator< steps::tetmesh::DiffBoundary * > >())
        __setslice__(vector_db self, std::vector< steps::tetmesh::DiffBoundary * >::difference_type i, std::vector< steps::tetmesh::DiffBoundary * >::difference_type j)
        """
        return _steps_swig.vector_db___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(vector_db self, std::vector< steps::tetmesh::DiffBoundary * >::difference_type i, std::vector< steps::tetmesh::DiffBoundary * >::difference_type j)"""
        return _steps_swig.vector_db___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(vector_db self, std::vector< steps::tetmesh::DiffBoundary * >::difference_type i)
        __delitem__(vector_db self, PySliceObject * slice)
        """
        return _steps_swig.vector_db___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(vector_db self, PySliceObject * slice) -> vector_db
        __getitem__(vector_db self, std::vector< steps::tetmesh::DiffBoundary * >::difference_type i) -> DiffBoundary
        """
        return _steps_swig.vector_db___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(vector_db self, PySliceObject * slice, vector_db v)
        __setitem__(vector_db self, PySliceObject * slice)
        __setitem__(vector_db self, std::vector< steps::tetmesh::DiffBoundary * >::difference_type i, DiffBoundary x)
        """
        return _steps_swig.vector_db___setitem__(self, *args)

    def append(self, *args):
        """append(vector_db self, DiffBoundary x)"""
        return _steps_swig.vector_db_append(self, *args)

    def empty(self):
        """empty(vector_db self) -> bool"""
        return _steps_swig.vector_db_empty(self)

    def size(self):
        """size(vector_db self) -> std::vector< steps::tetmesh::DiffBoundary * >::size_type"""
        return _steps_swig.vector_db_size(self)

    def clear(self):
        """clear(vector_db self)"""
        return _steps_swig.vector_db_clear(self)

    def swap(self, *args):
        """swap(vector_db self, vector_db v)"""
        return _steps_swig.vector_db_swap(self, *args)

    def get_allocator(self):
        """get_allocator(vector_db self) -> std::vector< steps::tetmesh::DiffBoundary * >::allocator_type"""
        return _steps_swig.vector_db_get_allocator(self)

    def begin(self):
        """begin(vector_db self) -> std::vector< steps::tetmesh::DiffBoundary * >::iterator"""
        return _steps_swig.vector_db_begin(self)

    def end(self):
        """end(vector_db self) -> std::vector< steps::tetmesh::DiffBoundary * >::iterator"""
        return _steps_swig.vector_db_end(self)

    def rbegin(self):
        """rbegin(vector_db self) -> std::vector< steps::tetmesh::DiffBoundary * >::reverse_iterator"""
        return _steps_swig.vector_db_rbegin(self)

    def rend(self):
        """rend(vector_db self) -> std::vector< steps::tetmesh::DiffBoundary * >::reverse_iterator"""
        return _steps_swig.vector_db_rend(self)

    def pop_back(self):
        """pop_back(vector_db self)"""
        return _steps_swig.vector_db_pop_back(self)

    def erase(self, *args):
        """
        erase(vector_db self, std::vector< steps::tetmesh::DiffBoundary * >::iterator pos) -> std::vector< steps::tetmesh::DiffBoundary * >::iterator
        erase(vector_db self, std::vector< steps::tetmesh::DiffBoundary * >::iterator first, std::vector< steps::tetmesh::DiffBoundary * >::iterator last) -> std::vector< steps::tetmesh::DiffBoundary * >::iterator
        """
        return _steps_swig.vector_db_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(p.steps::tetmesh::DiffBoundary)> self) -> vector_db
        __init__(std::vector<(p.steps::tetmesh::DiffBoundary)> self, vector_db arg2) -> vector_db
        __init__(std::vector<(p.steps::tetmesh::DiffBoundary)> self, std::vector< steps::tetmesh::DiffBoundary * >::size_type size) -> vector_db
        __init__(std::vector<(p.steps::tetmesh::DiffBoundary)> self, std::vector< steps::tetmesh::DiffBoundary * >::size_type size, DiffBoundary value) -> vector_db
        """
        this = _steps_swig.new_vector_db(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(vector_db self, DiffBoundary x)"""
        return _steps_swig.vector_db_push_back(self, *args)

    def front(self):
        """front(vector_db self) -> DiffBoundary"""
        return _steps_swig.vector_db_front(self)

    def back(self):
        """back(vector_db self) -> DiffBoundary"""
        return _steps_swig.vector_db_back(self)

    def assign(self, *args):
        """assign(vector_db self, std::vector< steps::tetmesh::DiffBoundary * >::size_type n, DiffBoundary x)"""
        return _steps_swig.vector_db_assign(self, *args)

    def resize(self, *args):
        """
        resize(vector_db self, std::vector< steps::tetmesh::DiffBoundary * >::size_type new_size)
        resize(vector_db self, std::vector< steps::tetmesh::DiffBoundary * >::size_type new_size, DiffBoundary x)
        """
        return _steps_swig.vector_db_resize(self, *args)

    def insert(self, *args):
        """
        insert(vector_db self, std::vector< steps::tetmesh::DiffBoundary * >::iterator pos, DiffBoundary x) -> std::vector< steps::tetmesh::DiffBoundary * >::iterator
        insert(vector_db self, std::vector< steps::tetmesh::DiffBoundary * >::iterator pos, std::vector< steps::tetmesh::DiffBoundary * >::size_type n, 
            DiffBoundary x)
        """
        return _steps_swig.vector_db_insert(self, *args)

    def reserve(self, *args):
        """reserve(vector_db self, std::vector< steps::tetmesh::DiffBoundary * >::size_type n)"""
        return _steps_swig.vector_db_reserve(self, *args)

    def capacity(self):
        """capacity(vector_db self) -> std::vector< steps::tetmesh::DiffBoundary * >::size_type"""
        return _steps_swig.vector_db_capacity(self)

    __swig_destroy__ = _steps_swig.delete_vector_db
    __del__ = lambda self : None;
vector_db_swigregister = _steps_swig.vector_db_swigregister
vector_db_swigregister(vector_db)

class vector_str(_object):
    """Proxy of C++ std::vector<(std::string)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_str, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_str, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(vector_str self) -> SwigPyIterator"""
        return _steps_swig.vector_str_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(vector_str self) -> bool"""
        return _steps_swig.vector_str___nonzero__(self)

    def __bool__(self):
        """__bool__(vector_str self) -> bool"""
        return _steps_swig.vector_str___bool__(self)

    def __len__(self):
        """__len__(vector_str self) -> std::vector< std::string >::size_type"""
        return _steps_swig.vector_str___len__(self)

    def pop(self):
        """pop(vector_str self) -> std::vector< std::string >::value_type"""
        return _steps_swig.vector_str_pop(self)

    def __getslice__(self, *args):
        """__getslice__(vector_str self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j) -> vector_str"""
        return _steps_swig.vector_str___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(vector_str self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j, 
            vector_str v=std::vector< std::string,std::allocator< std::string > >())
        __setslice__(vector_str self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)
        """
        return _steps_swig.vector_str___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(vector_str self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)"""
        return _steps_swig.vector_str___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(vector_str self, std::vector< std::string >::difference_type i)
        __delitem__(vector_str self, PySliceObject * slice)
        """
        return _steps_swig.vector_str___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(vector_str self, PySliceObject * slice) -> vector_str
        __getitem__(vector_str self, std::vector< std::string >::difference_type i) -> std::vector< std::string >::value_type const &
        """
        return _steps_swig.vector_str___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(vector_str self, PySliceObject * slice, vector_str v)
        __setitem__(vector_str self, PySliceObject * slice)
        __setitem__(vector_str self, std::vector< std::string >::difference_type i, std::vector< std::string >::value_type const & x)
        """
        return _steps_swig.vector_str___setitem__(self, *args)

    def append(self, *args):
        """append(vector_str self, std::vector< std::string >::value_type const & x)"""
        return _steps_swig.vector_str_append(self, *args)

    def empty(self):
        """empty(vector_str self) -> bool"""
        return _steps_swig.vector_str_empty(self)

    def size(self):
        """size(vector_str self) -> std::vector< std::string >::size_type"""
        return _steps_swig.vector_str_size(self)

    def clear(self):
        """clear(vector_str self)"""
        return _steps_swig.vector_str_clear(self)

    def swap(self, *args):
        """swap(vector_str self, vector_str v)"""
        return _steps_swig.vector_str_swap(self, *args)

    def get_allocator(self):
        """get_allocator(vector_str self) -> std::vector< std::string >::allocator_type"""
        return _steps_swig.vector_str_get_allocator(self)

    def begin(self):
        """begin(vector_str self) -> std::vector< std::string >::iterator"""
        return _steps_swig.vector_str_begin(self)

    def end(self):
        """end(vector_str self) -> std::vector< std::string >::iterator"""
        return _steps_swig.vector_str_end(self)

    def rbegin(self):
        """rbegin(vector_str self) -> std::vector< std::string >::reverse_iterator"""
        return _steps_swig.vector_str_rbegin(self)

    def rend(self):
        """rend(vector_str self) -> std::vector< std::string >::reverse_iterator"""
        return _steps_swig.vector_str_rend(self)

    def pop_back(self):
        """pop_back(vector_str self)"""
        return _steps_swig.vector_str_pop_back(self)

    def erase(self, *args):
        """
        erase(vector_str self, std::vector< std::string >::iterator pos) -> std::vector< std::string >::iterator
        erase(vector_str self, std::vector< std::string >::iterator first, std::vector< std::string >::iterator last) -> std::vector< std::string >::iterator
        """
        return _steps_swig.vector_str_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(std::string)> self) -> vector_str
        __init__(std::vector<(std::string)> self, vector_str arg2) -> vector_str
        __init__(std::vector<(std::string)> self, std::vector< std::string >::size_type size) -> vector_str
        __init__(std::vector<(std::string)> self, std::vector< std::string >::size_type size, std::vector< std::string >::value_type const & value) -> vector_str
        """
        this = _steps_swig.new_vector_str(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(vector_str self, std::vector< std::string >::value_type const & x)"""
        return _steps_swig.vector_str_push_back(self, *args)

    def front(self):
        """front(vector_str self) -> std::vector< std::string >::value_type const &"""
        return _steps_swig.vector_str_front(self)

    def back(self):
        """back(vector_str self) -> std::vector< std::string >::value_type const &"""
        return _steps_swig.vector_str_back(self)

    def assign(self, *args):
        """assign(vector_str self, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const & x)"""
        return _steps_swig.vector_str_assign(self, *args)

    def resize(self, *args):
        """
        resize(vector_str self, std::vector< std::string >::size_type new_size)
        resize(vector_str self, std::vector< std::string >::size_type new_size, std::vector< std::string >::value_type const & x)
        """
        return _steps_swig.vector_str_resize(self, *args)

    def insert(self, *args):
        """
        insert(vector_str self, std::vector< std::string >::iterator pos, std::vector< std::string >::value_type const & x) -> std::vector< std::string >::iterator
        insert(vector_str self, std::vector< std::string >::iterator pos, std::vector< std::string >::size_type n, 
            std::vector< std::string >::value_type const & x)
        """
        return _steps_swig.vector_str_insert(self, *args)

    def reserve(self, *args):
        """reserve(vector_str self, std::vector< std::string >::size_type n)"""
        return _steps_swig.vector_str_reserve(self, *args)

    def capacity(self):
        """capacity(vector_str self) -> std::vector< std::string >::size_type"""
        return _steps_swig.vector_str_capacity(self)

    __swig_destroy__ = _steps_swig.delete_vector_str
    __del__ = lambda self : None;
vector_str_swigregister = _steps_swig.vector_str_swigregister
vector_str_swigregister(vector_str)

class vector_int(_object):
    """Proxy of C++ std::vector<(int)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_int, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_int, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(vector_int self) -> SwigPyIterator"""
        return _steps_swig.vector_int_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(vector_int self) -> bool"""
        return _steps_swig.vector_int___nonzero__(self)

    def __bool__(self):
        """__bool__(vector_int self) -> bool"""
        return _steps_swig.vector_int___bool__(self)

    def __len__(self):
        """__len__(vector_int self) -> std::vector< int >::size_type"""
        return _steps_swig.vector_int___len__(self)

    def pop(self):
        """pop(vector_int self) -> std::vector< int >::value_type"""
        return _steps_swig.vector_int_pop(self)

    def __getslice__(self, *args):
        """__getslice__(vector_int self, std::vector< int >::difference_type i, std::vector< int >::difference_type j) -> vector_int"""
        return _steps_swig.vector_int___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(vector_int self, std::vector< int >::difference_type i, std::vector< int >::difference_type j, vector_int v=std::vector< int,std::allocator< int > >())
        __setslice__(vector_int self, std::vector< int >::difference_type i, std::vector< int >::difference_type j)
        """
        return _steps_swig.vector_int___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(vector_int self, std::vector< int >::difference_type i, std::vector< int >::difference_type j)"""
        return _steps_swig.vector_int___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(vector_int self, std::vector< int >::difference_type i)
        __delitem__(vector_int self, PySliceObject * slice)
        """
        return _steps_swig.vector_int___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(vector_int self, PySliceObject * slice) -> vector_int
        __getitem__(vector_int self, std::vector< int >::difference_type i) -> std::vector< int >::value_type const &
        """
        return _steps_swig.vector_int___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(vector_int self, PySliceObject * slice, vector_int v)
        __setitem__(vector_int self, PySliceObject * slice)
        __setitem__(vector_int self, std::vector< int >::difference_type i, std::vector< int >::value_type const & x)
        """
        return _steps_swig.vector_int___setitem__(self, *args)

    def append(self, *args):
        """append(vector_int self, std::vector< int >::value_type const & x)"""
        return _steps_swig.vector_int_append(self, *args)

    def empty(self):
        """empty(vector_int self) -> bool"""
        return _steps_swig.vector_int_empty(self)

    def size(self):
        """size(vector_int self) -> std::vector< int >::size_type"""
        return _steps_swig.vector_int_size(self)

    def clear(self):
        """clear(vector_int self)"""
        return _steps_swig.vector_int_clear(self)

    def swap(self, *args):
        """swap(vector_int self, vector_int v)"""
        return _steps_swig.vector_int_swap(self, *args)

    def get_allocator(self):
        """get_allocator(vector_int self) -> std::vector< int >::allocator_type"""
        return _steps_swig.vector_int_get_allocator(self)

    def begin(self):
        """begin(vector_int self) -> std::vector< int >::iterator"""
        return _steps_swig.vector_int_begin(self)

    def end(self):
        """end(vector_int self) -> std::vector< int >::iterator"""
        return _steps_swig.vector_int_end(self)

    def rbegin(self):
        """rbegin(vector_int self) -> std::vector< int >::reverse_iterator"""
        return _steps_swig.vector_int_rbegin(self)

    def rend(self):
        """rend(vector_int self) -> std::vector< int >::reverse_iterator"""
        return _steps_swig.vector_int_rend(self)

    def pop_back(self):
        """pop_back(vector_int self)"""
        return _steps_swig.vector_int_pop_back(self)

    def erase(self, *args):
        """
        erase(vector_int self, std::vector< int >::iterator pos) -> std::vector< int >::iterator
        erase(vector_int self, std::vector< int >::iterator first, std::vector< int >::iterator last) -> std::vector< int >::iterator
        """
        return _steps_swig.vector_int_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(int)> self) -> vector_int
        __init__(std::vector<(int)> self, vector_int arg2) -> vector_int
        __init__(std::vector<(int)> self, std::vector< int >::size_type size) -> vector_int
        __init__(std::vector<(int)> self, std::vector< int >::size_type size, std::vector< int >::value_type const & value) -> vector_int
        """
        this = _steps_swig.new_vector_int(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(vector_int self, std::vector< int >::value_type const & x)"""
        return _steps_swig.vector_int_push_back(self, *args)

    def front(self):
        """front(vector_int self) -> std::vector< int >::value_type const &"""
        return _steps_swig.vector_int_front(self)

    def back(self):
        """back(vector_int self) -> std::vector< int >::value_type const &"""
        return _steps_swig.vector_int_back(self)

    def assign(self, *args):
        """assign(vector_int self, std::vector< int >::size_type n, std::vector< int >::value_type const & x)"""
        return _steps_swig.vector_int_assign(self, *args)

    def resize(self, *args):
        """
        resize(vector_int self, std::vector< int >::size_type new_size)
        resize(vector_int self, std::vector< int >::size_type new_size, std::vector< int >::value_type const & x)
        """
        return _steps_swig.vector_int_resize(self, *args)

    def insert(self, *args):
        """
        insert(vector_int self, std::vector< int >::iterator pos, std::vector< int >::value_type const & x) -> std::vector< int >::iterator
        insert(vector_int self, std::vector< int >::iterator pos, std::vector< int >::size_type n, std::vector< int >::value_type const & x)
        """
        return _steps_swig.vector_int_insert(self, *args)

    def reserve(self, *args):
        """reserve(vector_int self, std::vector< int >::size_type n)"""
        return _steps_swig.vector_int_reserve(self, *args)

    def capacity(self):
        """capacity(vector_int self) -> std::vector< int >::size_type"""
        return _steps_swig.vector_int_capacity(self)

    __swig_destroy__ = _steps_swig.delete_vector_int
    __del__ = lambda self : None;
vector_int_swigregister = _steps_swig.vector_int_swigregister
vector_int_swigregister(vector_int)

class vector_uint(_object):
    """Proxy of C++ std::vector<(unsigned int)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_uint, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_uint, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(vector_uint self) -> SwigPyIterator"""
        return _steps_swig.vector_uint_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(vector_uint self) -> bool"""
        return _steps_swig.vector_uint___nonzero__(self)

    def __bool__(self):
        """__bool__(vector_uint self) -> bool"""
        return _steps_swig.vector_uint___bool__(self)

    def __len__(self):
        """__len__(vector_uint self) -> std::vector< unsigned int >::size_type"""
        return _steps_swig.vector_uint___len__(self)

    def pop(self):
        """pop(vector_uint self) -> std::vector< unsigned int >::value_type"""
        return _steps_swig.vector_uint_pop(self)

    def __getslice__(self, *args):
        """__getslice__(vector_uint self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j) -> vector_uint"""
        return _steps_swig.vector_uint___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(vector_uint self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j, 
            vector_uint v=std::vector< unsigned int,std::allocator< unsigned int > >())
        __setslice__(vector_uint self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j)
        """
        return _steps_swig.vector_uint___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(vector_uint self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j)"""
        return _steps_swig.vector_uint___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(vector_uint self, std::vector< unsigned int >::difference_type i)
        __delitem__(vector_uint self, PySliceObject * slice)
        """
        return _steps_swig.vector_uint___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(vector_uint self, PySliceObject * slice) -> vector_uint
        __getitem__(vector_uint self, std::vector< unsigned int >::difference_type i) -> std::vector< unsigned int >::value_type const &
        """
        return _steps_swig.vector_uint___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(vector_uint self, PySliceObject * slice, vector_uint v)
        __setitem__(vector_uint self, PySliceObject * slice)
        __setitem__(vector_uint self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::value_type const & x)
        """
        return _steps_swig.vector_uint___setitem__(self, *args)

    def append(self, *args):
        """append(vector_uint self, std::vector< unsigned int >::value_type const & x)"""
        return _steps_swig.vector_uint_append(self, *args)

    def empty(self):
        """empty(vector_uint self) -> bool"""
        return _steps_swig.vector_uint_empty(self)

    def size(self):
        """size(vector_uint self) -> std::vector< unsigned int >::size_type"""
        return _steps_swig.vector_uint_size(self)

    def clear(self):
        """clear(vector_uint self)"""
        return _steps_swig.vector_uint_clear(self)

    def swap(self, *args):
        """swap(vector_uint self, vector_uint v)"""
        return _steps_swig.vector_uint_swap(self, *args)

    def get_allocator(self):
        """get_allocator(vector_uint self) -> std::vector< unsigned int >::allocator_type"""
        return _steps_swig.vector_uint_get_allocator(self)

    def begin(self):
        """begin(vector_uint self) -> std::vector< unsigned int >::iterator"""
        return _steps_swig.vector_uint_begin(self)

    def end(self):
        """end(vector_uint self) -> std::vector< unsigned int >::iterator"""
        return _steps_swig.vector_uint_end(self)

    def rbegin(self):
        """rbegin(vector_uint self) -> std::vector< unsigned int >::reverse_iterator"""
        return _steps_swig.vector_uint_rbegin(self)

    def rend(self):
        """rend(vector_uint self) -> std::vector< unsigned int >::reverse_iterator"""
        return _steps_swig.vector_uint_rend(self)

    def pop_back(self):
        """pop_back(vector_uint self)"""
        return _steps_swig.vector_uint_pop_back(self)

    def erase(self, *args):
        """
        erase(vector_uint self, std::vector< unsigned int >::iterator pos) -> std::vector< unsigned int >::iterator
        erase(vector_uint self, std::vector< unsigned int >::iterator first, std::vector< unsigned int >::iterator last) -> std::vector< unsigned int >::iterator
        """
        return _steps_swig.vector_uint_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(unsigned int)> self) -> vector_uint
        __init__(std::vector<(unsigned int)> self, vector_uint arg2) -> vector_uint
        __init__(std::vector<(unsigned int)> self, std::vector< unsigned int >::size_type size) -> vector_uint
        __init__(std::vector<(unsigned int)> self, std::vector< unsigned int >::size_type size, std::vector< unsigned int >::value_type const & value) -> vector_uint
        """
        this = _steps_swig.new_vector_uint(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(vector_uint self, std::vector< unsigned int >::value_type const & x)"""
        return _steps_swig.vector_uint_push_back(self, *args)

    def front(self):
        """front(vector_uint self) -> std::vector< unsigned int >::value_type const &"""
        return _steps_swig.vector_uint_front(self)

    def back(self):
        """back(vector_uint self) -> std::vector< unsigned int >::value_type const &"""
        return _steps_swig.vector_uint_back(self)

    def assign(self, *args):
        """assign(vector_uint self, std::vector< unsigned int >::size_type n, std::vector< unsigned int >::value_type const & x)"""
        return _steps_swig.vector_uint_assign(self, *args)

    def resize(self, *args):
        """
        resize(vector_uint self, std::vector< unsigned int >::size_type new_size)
        resize(vector_uint self, std::vector< unsigned int >::size_type new_size, std::vector< unsigned int >::value_type const & x)
        """
        return _steps_swig.vector_uint_resize(self, *args)

    def insert(self, *args):
        """
        insert(vector_uint self, std::vector< unsigned int >::iterator pos, std::vector< unsigned int >::value_type const & x) -> std::vector< unsigned int >::iterator
        insert(vector_uint self, std::vector< unsigned int >::iterator pos, std::vector< unsigned int >::size_type n, 
            std::vector< unsigned int >::value_type const & x)
        """
        return _steps_swig.vector_uint_insert(self, *args)

    def reserve(self, *args):
        """reserve(vector_uint self, std::vector< unsigned int >::size_type n)"""
        return _steps_swig.vector_uint_reserve(self, *args)

    def capacity(self):
        """capacity(vector_uint self) -> std::vector< unsigned int >::size_type"""
        return _steps_swig.vector_uint_capacity(self)

    __swig_destroy__ = _steps_swig.delete_vector_uint
    __del__ = lambda self : None;
vector_uint_swigregister = _steps_swig.vector_uint_swigregister
vector_uint_swigregister(vector_uint)

class vector_bool(_object):
    """Proxy of C++ std::vector<(bool)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_bool, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_bool, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(vector_bool self) -> SwigPyIterator"""
        return _steps_swig.vector_bool_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(vector_bool self) -> bool"""
        return _steps_swig.vector_bool___nonzero__(self)

    def __bool__(self):
        """__bool__(vector_bool self) -> bool"""
        return _steps_swig.vector_bool___bool__(self)

    def __len__(self):
        """__len__(vector_bool self) -> std::vector< bool >::size_type"""
        return _steps_swig.vector_bool___len__(self)

    def pop(self):
        """pop(vector_bool self) -> std::vector< bool >::value_type"""
        return _steps_swig.vector_bool_pop(self)

    def __getslice__(self, *args):
        """__getslice__(vector_bool self, std::vector< bool >::difference_type i, std::vector< bool >::difference_type j) -> vector_bool"""
        return _steps_swig.vector_bool___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(vector_bool self, std::vector< bool >::difference_type i, std::vector< bool >::difference_type j, vector_bool v=std::vector< bool,std::allocator< bool > >())
        __setslice__(vector_bool self, std::vector< bool >::difference_type i, std::vector< bool >::difference_type j)
        """
        return _steps_swig.vector_bool___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(vector_bool self, std::vector< bool >::difference_type i, std::vector< bool >::difference_type j)"""
        return _steps_swig.vector_bool___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(vector_bool self, std::vector< bool >::difference_type i)
        __delitem__(vector_bool self, PySliceObject * slice)
        """
        return _steps_swig.vector_bool___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(vector_bool self, PySliceObject * slice) -> vector_bool
        __getitem__(vector_bool self, std::vector< bool >::difference_type i) -> std::vector< bool >::value_type
        """
        return _steps_swig.vector_bool___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(vector_bool self, PySliceObject * slice, vector_bool v)
        __setitem__(vector_bool self, PySliceObject * slice)
        __setitem__(vector_bool self, std::vector< bool >::difference_type i, std::vector< bool >::value_type x)
        """
        return _steps_swig.vector_bool___setitem__(self, *args)

    def append(self, *args):
        """append(vector_bool self, std::vector< bool >::value_type x)"""
        return _steps_swig.vector_bool_append(self, *args)

    def empty(self):
        """empty(vector_bool self) -> bool"""
        return _steps_swig.vector_bool_empty(self)

    def size(self):
        """size(vector_bool self) -> std::vector< bool >::size_type"""
        return _steps_swig.vector_bool_size(self)

    def clear(self):
        """clear(vector_bool self)"""
        return _steps_swig.vector_bool_clear(self)

    def swap(self, *args):
        """swap(vector_bool self, vector_bool v)"""
        return _steps_swig.vector_bool_swap(self, *args)

    def get_allocator(self):
        """get_allocator(vector_bool self) -> std::vector< bool >::allocator_type"""
        return _steps_swig.vector_bool_get_allocator(self)

    def begin(self):
        """begin(vector_bool self) -> std::vector< bool >::iterator"""
        return _steps_swig.vector_bool_begin(self)

    def end(self):
        """end(vector_bool self) -> std::vector< bool >::iterator"""
        return _steps_swig.vector_bool_end(self)

    def rbegin(self):
        """rbegin(vector_bool self) -> std::vector< bool >::reverse_iterator"""
        return _steps_swig.vector_bool_rbegin(self)

    def rend(self):
        """rend(vector_bool self) -> std::vector< bool >::reverse_iterator"""
        return _steps_swig.vector_bool_rend(self)

    def pop_back(self):
        """pop_back(vector_bool self)"""
        return _steps_swig.vector_bool_pop_back(self)

    def erase(self, *args):
        """
        erase(vector_bool self, std::vector< bool >::iterator pos) -> std::vector< bool >::iterator
        erase(vector_bool self, std::vector< bool >::iterator first, std::vector< bool >::iterator last) -> std::vector< bool >::iterator
        """
        return _steps_swig.vector_bool_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(bool)> self) -> vector_bool
        __init__(std::vector<(bool)> self, vector_bool arg2) -> vector_bool
        __init__(std::vector<(bool)> self, std::vector< bool >::size_type size) -> vector_bool
        __init__(std::vector<(bool)> self, std::vector< bool >::size_type size, std::vector< bool >::value_type value) -> vector_bool
        """
        this = _steps_swig.new_vector_bool(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(vector_bool self, std::vector< bool >::value_type x)"""
        return _steps_swig.vector_bool_push_back(self, *args)

    def front(self):
        """front(vector_bool self) -> std::vector< bool >::value_type"""
        return _steps_swig.vector_bool_front(self)

    def back(self):
        """back(vector_bool self) -> std::vector< bool >::value_type"""
        return _steps_swig.vector_bool_back(self)

    def assign(self, *args):
        """assign(vector_bool self, std::vector< bool >::size_type n, std::vector< bool >::value_type x)"""
        return _steps_swig.vector_bool_assign(self, *args)

    def resize(self, *args):
        """
        resize(vector_bool self, std::vector< bool >::size_type new_size)
        resize(vector_bool self, std::vector< bool >::size_type new_size, std::vector< bool >::value_type x)
        """
        return _steps_swig.vector_bool_resize(self, *args)

    def insert(self, *args):
        """
        insert(vector_bool self, std::vector< bool >::iterator pos, std::vector< bool >::value_type x) -> std::vector< bool >::iterator
        insert(vector_bool self, std::vector< bool >::iterator pos, std::vector< bool >::size_type n, std::vector< bool >::value_type x)
        """
        return _steps_swig.vector_bool_insert(self, *args)

    def reserve(self, *args):
        """reserve(vector_bool self, std::vector< bool >::size_type n)"""
        return _steps_swig.vector_bool_reserve(self, *args)

    def capacity(self):
        """capacity(vector_bool self) -> std::vector< bool >::size_type"""
        return _steps_swig.vector_bool_capacity(self)

    __swig_destroy__ = _steps_swig.delete_vector_bool
    __del__ = lambda self : None;
vector_bool_swigregister = _steps_swig.vector_bool_swigregister
vector_bool_swigregister(vector_bool)

ELEM_VERTEX = _steps_swig.ELEM_VERTEX
ELEM_TRI = _steps_swig.ELEM_TRI
ELEM_TET = _steps_swig.ELEM_TET
ELEM_UNDEFINED = _steps_swig.ELEM_UNDEFINED
class ROISet(_object):
    """Proxy of C++ steps::tetmesh::ROISet class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ROISet, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ROISet, name)
    __repr__ = _swig_repr
    __swig_setmethods__["type"] = _steps_swig.ROISet_type_set
    __swig_getmethods__["type"] = _steps_swig.ROISet_type_get
    if _newclass:type = _swig_property(_steps_swig.ROISet_type_get, _steps_swig.ROISet_type_set)
    __swig_setmethods__["indices"] = _steps_swig.ROISet_indices_set
    __swig_getmethods__["indices"] = _steps_swig.ROISet_indices_get
    if _newclass:indices = _swig_property(_steps_swig.ROISet_indices_get, _steps_swig.ROISet_indices_set)
    def __init__(self): 
        """__init__(steps::tetmesh::ROISet self) -> ROISet"""
        this = _steps_swig.new_ROISet()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_ROISet
    __del__ = lambda self : None;
ROISet_swigregister = _steps_swig.ROISet_swigregister
ROISet_swigregister(ROISet)


def castToTmComp(*args):
  """castToTmComp(Comp base) -> TmComp"""
  return _steps_swig.castToTmComp(*args)

def castToTmPatch(*args):
  """castToTmPatch(Patch base) -> TmPatch"""
  return _steps_swig.castToTmPatch(*args)
class Geom(_object):
    """Proxy of C++ steps::wm::Geom class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Geom, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Geom, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(steps::wm::Geom self) -> Geom"""
        this = _steps_swig.new_Geom()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_Geom
    __del__ = lambda self : None;
    def getComp(self, *args):
        """
        Returns a reference to the steps.model.Comp compartment object with 
        identifier string comp_id (if defined).

        Syntax::

            getComp(comp_id)
            
        Arguments:
            string comp_id
                     
        Return:
            steps.model.Comp

        """
        return _steps_swig.Geom_getComp(self, *args)

    def delComp(self, *args):
        """
        Removes the steps.geom.Comp object with identifier string comp_id (if defined) 
        from the geometry container.

        Syntax::

            delComp(comp_id)
            
        Arguments:
            string comp_id
                     
        Return:
            None

        """
        return _steps_swig.Geom_delComp(self, *args)

    def getAllComps(self):
        """
        Returns a list of references to all steps.geom.Comp compartment objects in the 
        geometry container.

        Syntax::

            getAllComps()
            
        Arguments:
            None
                     
        Return:
            list<steps.geom.Comp>

        """
        return _steps_swig.Geom_getAllComps(self)

    def getPatch(self, *args):
        """
        Removes the steps.geom.Patch object with identifier string patch_id (if defined) 
        from the geometry container.

        Syntax::

            getPatch(patch_id)
            
        Arguments:
            string patch_id
                     
        Return:
            steps.geom.Patch

        """
        return _steps_swig.Geom_getPatch(self, *args)

    def delPatch(self, *args):
        """
        Removes the steps.geom.Patch object with identifier string patch_id (if defined) 
        from the geometry container.

        Syntax::

            delPatch(patch_id)
            
        Arguments:
            string patch_id
                     
        Return:
            None

        """
        return _steps_swig.Geom_delPatch(self, *args)

    def getAllPatches(self):
        """
        Returns a list of references to all steps.geom.Patch patch objects in the 
        geometry container.

        Syntax::

            getAllPatches()
            
        Arguments:
            None
                     
        Return:
            list<steps.geom.Patch>

        """
        return _steps_swig.Geom_getAllPatches(self)

Geom_swigregister = _steps_swig.Geom_swigregister
Geom_swigregister(Geom)

class Patch(_object):
    """Proxy of C++ steps::wm::Patch class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Patch, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Patch, name)
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """__init__(steps::wm::Patch self, std::string const & id, Geom container, Comp icomp, Comp ocomp=None, double area=0.0) -> Patch"""
        this = _steps_swig.new_Patch(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_Patch
    __del__ = lambda self : None;
    def getID(self):
        """
        Get the identifier string of the patch.

        Syntax::

            getID()
            
        Arguments:
            None
                     
        Return:
            string

        """
        return _steps_swig.Patch_getID(self)

    def setID(self, *args):
        """
        Set the identifier string of the patch.

        Syntax::

            setID(name)
            
        Arguments:
            string name
                     
        Return:
            None

        """
        return _steps_swig.Patch_setID(self, *args)

    def getContainer(self):
        """
        Returns a reference to the parent steps.geom.Geom container object.

        Syntax::

            getContainer()
            
        Arguments:
            None
                     
        Return:
            steps.geom.Geom

        """
        return _steps_swig.Patch_getContainer(self)

    def getArea(self):
        """
        Get the area of the patch (in m^2).

        Syntax::

            getArea()

        Arguments:
            None
                     
        Return:
            float

        """
        return _steps_swig.Patch_getArea(self)

    def setArea(self, *args):
        """
        Set the area of the patch (in m^2).

        Syntax::

            setArea(area)
            
        Arguments:
            float area
                     
        Return:
            None

        """
        return _steps_swig.Patch_setArea(self, *args)

    def addSurfsys(self, *args):
        """
        Add surface system identifier string surfsys_id to the patch object.

        Syntax::

            addSurfsys(surfsys_id)
            
        Arguments:
            string surfsys_id
                     
        Return:
            None

        """
        return _steps_swig.Patch_addSurfsys(self, *args)

    def getSurfsys(self):
        """
        Returns a list of the surface system identifier strings which have 
        been added to the patch.

        Syntax::

            getSurfsys()
            
        Arguments:
            None
                     
        Return:
            list<string>

        """
        return _steps_swig.Patch_getSurfsys(self)

    def delSurfsys(self, *args):
        """
        Removes surface system identifier string surfsys_id from this patch.

        Syntax::

            delSurfsys(surfsys_id)

        Arguments:
            string surfsys_id
                     
        Return:
            None

        """
        return _steps_swig.Patch_delSurfsys(self, *args)

    def getAllSpecs(self, *args):
        """
        Giving a steps.model.Model, return all species in the compartment.

        Syntax::

            getAllSpecs(model)

        Arguments:
            steps.model.Model model

        Return:
            list<steps.model.Spec>

        """
        return _steps_swig.Patch_getAllSpecs(self, *args)

    def getAllSReacs(self, *args):
        """
        Giving a steps.model.Model, return all surface reactions in the compartment.

        Syntax::

            getAllSReacs(model)

        Arguments:
            steps.model.Model model

        Return:
            list<steps.model.SReac>

        """
        return _steps_swig.Patch_getAllSReacs(self, *args)

    def getIComp(self):
        """
        Returns a reference to the steps.geom.Comp compartment object representing
        the inner compartment.

        Syntax::

            getIComp()

        Arguments:
            None
                     
        Return:
            steps.geom.Comp

        """
        return _steps_swig.Patch_getIComp(self)

    def getOComp(self):
        """
        Returns a reference to the steps.geom.Comp compartment object representing
        the outer compartment.

        Syntax::
            
            getOComp()

        Arguments:
            None
                     
        Return:
            steps.geom.Comp

        """
        return _steps_swig.Patch_getOComp(self)

Patch_swigregister = _steps_swig.Patch_swigregister
Patch_swigregister(Patch)

class Comp(_object):
    """Proxy of C++ steps::wm::Comp class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Comp, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Comp, name)
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """__init__(steps::wm::Comp self, std::string const & id, Geom container, double vol=0.0) -> Comp"""
        this = _steps_swig.new_Comp(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_Comp
    __del__ = lambda self : None;
    def getID(self):
        """
        Get the identifier string of the compartment.

        Syntax::

            getID()

        Arguments:
            None
                     
        Return:
            string

        """
        return _steps_swig.Comp_getID(self)

    def setID(self, *args):
        """
        Set the identifier string of the compartment.

        Syntax::

            setID(name)

        Arguments:
            string name
                     
        Return:
            None

        """
        return _steps_swig.Comp_setID(self, *args)

    def getContainer(self):
        """
        Returns a reference to the parent steps.geom.Geom container object.

        Syntax::

            getContainer()

        Arguments:
            None
                     
        Return:
            steps.geom.Geom

        """
        return _steps_swig.Comp_getContainer(self)

    def getVol(self):
        """
        Get the volume of the compartment (in m^3).

        Syntax::

            getVol()
            
        Arguments:
            None
                     
        Return:
            float

        """
        return _steps_swig.Comp_getVol(self)

    def setVol(self, *args):
        """
        Set the volume of the compartment (in m^3).

        Syntax::

            setVol(vol)

        Arguments:
            float vol
                     
        Return:
            None

        """
        return _steps_swig.Comp_setVol(self, *args)

    def addVolsys(self, *args):
        """
        Add volume system identifier string volsys_id to the compartment object.

        Syntax::

            addVolsys(volsys_id)

        Arguments:
            string volsys_id
                     
        Return:
            None

        """
        return _steps_swig.Comp_addVolsys(self, *args)

    def getVolsys(self):
        """
        Returns a list of the volume system identifier strings which have been 
        added to the compartment.

        Syntax::

            getVolsys()

        Arguments:
            None
                     
        Return:
            list<string>

        """
        return _steps_swig.Comp_getVolsys(self)

    def delVolsys(self, *args):
        """
        Removes volume system identifier string volsys_id from this compartment.

        Syntax::

            delVolsys(volsys_id)

        Arguments:
            string volsys_id
                     
        Return:
            None

        """
        return _steps_swig.Comp_delVolsys(self, *args)

    def getAllSpecs(self, *args):
        """
        Giving a steps.model.Model, return all species in the compartment.
            
        Syntax::
            
            getAllSpecs(model)
            
        Arguments:
            steps.model.Model model
            
        Return:
            list<steps.model.Spec>

        """
        return _steps_swig.Comp_getAllSpecs(self, *args)

    def getAllReacs(self, *args):
        """
        Giving a steps.model.Model, return all reactions in the compartment.

        Syntax::

            getAllReacs(model)

        Arguments:
            steps.model.Model model

        Return:
            list<steps.model.Reac>

        """
        return _steps_swig.Comp_getAllReacs(self, *args)

    def getAllDiffs(self, *args):
        """
        Giving a steps.model.Model, return all diffusions in the compartment.

        Syntax::

            getAllDiffs(model)

        Arguments:
            steps.model.Model model

        Return:
            list<steps.model.Diff>

        """
        return _steps_swig.Comp_getAllDiffs(self, *args)

    def getIPatches(self):
        """
        Returns a list of references to steps.geom.Patch patch objects: 
        the 'inner' patches.

        Syntax::

            getIPatches()

        Arguments:
            None
                     
        Return:
            list<steps.geom.Patch>

        """
        return _steps_swig.Comp_getIPatches(self)

    def getOPatches(self):
        """
        Returns a list of references to steps.geom.Patch patch objects: 
        the 'outer' patches.

        Syntax::

            getOPatches()

        Arguments:
            None
                     
        Return:
            list<steps.geom.Patch>

        """
        return _steps_swig.Comp_getOPatches(self)

Comp_swigregister = _steps_swig.Comp_swigregister
Comp_swigregister(Comp)

class Tetmesh(Geom):
    """Proxy of C++ steps::tetmesh::Tetmesh class"""
    __swig_setmethods__ = {}
    for _s in [Geom]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Tetmesh, name, value)
    __swig_getmethods__ = {}
    for _s in [Geom]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Tetmesh, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        Returns a list of references to all steps.geom.Patch patch objects in the 
        geometry container.

        Syntax::

            getAllPatches()
            
        Arguments:
            None
                     
        Return:
            list<steps.geom.Patch>


        Returns a list of references to all steps.geom.Patch patch objects in the 
        geometry container.

        Syntax::

            getAllPatches()
            
        Arguments:
            None
                     
        Return:
            list<steps.geom.Patch>


        Returns a list of references to all steps.geom.Patch patch objects in the 
        geometry container.

        Syntax::

            getAllPatches()
            
        Arguments:
            None
                     
        Return:
            list<steps.geom.Patch>

        """
        this = _steps_swig.new_Tetmesh(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_Tetmesh
    __del__ = lambda self : None;
    def setup(self):
        """
        Setup the Tetmesh object by computing the auxiliary data. This method should 
        be called when the second constructor is used and all vertex, tetrahedron and 
        triangle information has been supplied with the set methods. The first constructor 
        calls this method internally, so setup does not have to be called when using the 
        first constructor.

        Syntax::

            setup()

        Arguments:
            None
                     
        Return:
            None

        """
        return _steps_swig.Tetmesh_setup(self)

    def isSetupDone(self):
        """
        Check if setup() has been called, either internally by the first constructor, 
        or by the user if the second constructor was used.

        Syntax::

            isSetupDone()

        Arguments:
            None
                     
        Return:
            True if setup is done.
            False if setup is not done.

        """
        return _steps_swig.Tetmesh_isSetupDone(self)

    def getVertex(self, *args):
        """
        Returns the coordinates of vertex with index vidx in the container.

        Syntax::

            getVertex(vidx)

        Arguments:
            uint vidx
                     
        Return:
            list<float, length = 3>

        """
        return _steps_swig.Tetmesh_getVertex(self, *args)

    def countVertices(self):
        """
        Returns the total number of vertices in the mesh.

        Syntax::

            countVertices()

        Arguments:
            None
                     
        Return:
            uint

        """
        return _steps_swig.Tetmesh_countVertices(self)

    def getBar(self, *args):
        """
        Returns the vertices of bar with index bidx in the container.

        Syntax::
        			 
        	getBar(bidx)

        Arguments:
        	uint bidx

        Return:
        	list<uint, length = 2>

        """
        return _steps_swig.Tetmesh_getBar(self, *args)

    def countBars(self):
        """
        Returns the total nubmer of bars in the mesh.

        Syntax::
        	
        	countBars()
        			 
        Arguments:
        	None

        Return:
        	uint

        """
        return _steps_swig.Tetmesh_countBars(self)

    def getTri(self, *args):
        """
        Returns the triangle with index tidx in the container by its three vertex indices.

        Syntax::

            getTri(tidx)

        Arguments:
            uint tidx
                     
        Return:
            list<uint, length = 3>

        """
        return _steps_swig.Tetmesh_getTri(self, *args)

    def countTris(self):
        """
        Returns the total number of triangles in the mesh.

        Syntax::

            countTris()

        Arguments:
            None
                     
        Return:
            uint

        """
        return _steps_swig.Tetmesh_countTris(self)

    def getTriArea(self, *args):
        """
        Returns the area of the triangle with index tidx.

        Syntax::

            getTriArea(tidx)

        Arguments:
            uint tidx
                     
        Return:
            float

        """
        return _steps_swig.Tetmesh_getTriArea(self, *args)

    def getTriBarycenter(self, *args):
        """
        Returns the Cartesian coordinates of the barycenter of triangle with index tidx.

        Syntax::

            getTriBarycenter(tidx)

        Arguments:
            uint tidx
                     
        Return:
            list<float, length = 3>

        """
        return _steps_swig.Tetmesh_getTriBarycenter(self, *args)

    def getTriBars(self, *args):
        """
        Returns the index of the bars that comprise the triangle.
        	
        Syntax::
        			 
        	getTriBars(tidx)
        			 
        Arguments:
        	uint tidx

        Return:
        	list<uint, length = 3>

        """
        return _steps_swig.Tetmesh_getTriBars(self, *args)

    def getTetQualityRER(self, *args):
        """
        Returns the radius-edge-ratio (a quality measurement) of tetrahedron with index tidx.

        Syntax::
            
            getTetQualityRER(tidx)

        Arguments:
            uint tidx
                     
        Return:
            float

        """
        return _steps_swig.Tetmesh_getTetQualityRER(self, *args)

    def getTriNorm(self, *args):
        """
        Returns the normal vector of the triangle with index tidx.

        Syntax::

            getTriNorm(tidx)

        Arguments:
            uint tidx
                     
        Return:
            list<float, length = 3>

        """
        return _steps_swig.Tetmesh_getTriNorm(self, *args)

    def getTriPatch(self, *args):
        """
        Returns a reference to a step.geom.TmPatch object: the patch which triangle 
        with index tidx belongs to. Returns None if triangle not assigned to a patch.

        Syntax::

            getTriPatch(tidx)

        Arguments:
            uint tidx
                     
        Return:
            steps.geom.TmPatch

        """
        return _steps_swig.Tetmesh_getTriPatch(self, *args)

    def getTriDiffBoundary(self, *args):
        """
        Returns a reference to a step.geom.Diffboundary object: the diffusion boundary triangle 
        with index tidx belongs to. Returns None if triangle not assigned to a diffusion boundary.

        Syntax::
                     
            getTriDiffBoundary(tidx)
                     
        Arguments:
            uint tidx
                     
        Return:
            steps.geom.DiffBoundary

        """
        return _steps_swig.Tetmesh_getTriDiffBoundary(self, *args)

    def getTriTetNeighb(self, *args):
        """
        Returns the indices of the two neighbouring tetrahedrons of triangle with 
        index tidx. An index of -1 indicates no neighbour (triangle is on the mesh border). 

        Syntax::

            getTriTetNeighb(tidx)

        Arguments:
            uint tidx
                     
        Return:
            list<int, length = 2>

        """
        return _steps_swig.Tetmesh_getTriTetNeighb(self, *args)

    def getTriTriNeighbs(self, *args):
        """
        Returns the indices of the neighbouring triangles (that is all triangles that
        share a 'bar') of triangle with index tidx. 

        Syntax::
        	
        	getTriTriNeighbs(uint)
        	
        Arguments:
        	uint tidx
        	
        Returns:
        	list<uint>

        """
        return _steps_swig.Tetmesh_getTriTriNeighbs(self, *args)

    def getTriTriNeighb(self, *args):
        """
        Returns the indices of the neighbouring triangles (that is all triangles that
        share a 'bar') of triangle with index tidx within the same patch. 
                     
        Syntax::
                     
            getTriTriNeighb(uint)
                     
        Arguments:
            uint tidx
                     
        Returns:
            list<uint>

        """
        return _steps_swig.Tetmesh_getTriTriNeighb(self, *args)

    def getSurfTris(self):
        """
        Returns a list of triangles that form the mesh boundary.
        Support function for steps.utilities.visual.

        Syntax::

            getTriBoundary()

        Arguments:
            None
                     
        Return:
            list<int>

        """
        return _steps_swig.Tetmesh_getSurfTris(self)

    def getTet(self, *args):
        """
        Returns the tetrahedron with index tidx in the container by its four vertex indices.

        Syntax::
            getTet(tidx)
            
        Arguments:
            uint tidx
                     
        Return:
            list<uint, length = 4>

        """
        return _steps_swig.Tetmesh_getTet(self, *args)

    def countTets(self):
        """
        Returns the total number of tetrahedrons in the mesh.

        Syntax::

            countTets()

        Arguments:
            None
                     
        Return:
            uint

        """
        return _steps_swig.Tetmesh_countTets(self)

    def getTetVol(self, *args):
        """
        Returns the volume of the tetrahedron with index tidx.

        Syntax::

            getTetVol(tidx)

        Arguments:
            uint tidx
                     
        Return:
            float

        """
        return _steps_swig.Tetmesh_getTetVol(self, *args)

    def getTetBarycenter(self, *args):
        """
        Returns the barycenter of the tetrahedron with index tidx.

        Syntax::

            getTetBarycenter(tidx)

        Arguments:
            uint tidx
                     
        Return:
            list<float, length = 3>

        """
        return _steps_swig.Tetmesh_getTetBarycenter(self, *args)

    def getTetComp(self, *args):
        """
        Returns a reference to a steps.geom.Comp object: the compartment which 
        tetrahedron with index tidx belongs to. Returns None if tetrahedron not 
        assigned to a compartment.

        Syntax::

            getTetComp(tidx)

        Arguments:
            uint tidx
                     
        Return:
            steps.geom.TmComp

        """
        return _steps_swig.Tetmesh_getTetComp(self, *args)

    def getTetTriNeighb(self, *args):
        """
        Returns the indices of the four neighbouring triangles of tetrahedron with index tidx.

        Syntax::

            getTetTriNeighb(tidx)

        Arguments:
            uint tidx
                     
        Return:
            list<uint, length = 4>

        """
        return _steps_swig.Tetmesh_getTetTriNeighb(self, *args)

    def getTetTetNeighb(self, *args):
        """
        Returns the indices of the four neighbouring tetrahedrons of tetrahedron with index tidx. 
        An index of -1 indicates no neighbour (tetrahedron is on the mesh border).

        Syntax::

            getTetTetNeighb(tidx)

        Arguments:
            uint tidx
                     
        Return:
            list<int, length = 4>

        """
        return _steps_swig.Tetmesh_getTetTetNeighb(self, *args)

    def findTetByPoint(self, *args):
        """
        Returns the index of the tetrahedron which encompasses a given point 
        p (given in Cartesian coordinates x,y,z). Returns -1 if p is a position 
        outside the mesh.

        Syntax::

            findTetByPoint(p)

        Arguments:
            list<float, length = 3> p
                     
        Return:
            int

        """
        return _steps_swig.Tetmesh_findTetByPoint(self, *args)

    def getBoundMin(self):
        """
        Returns the minimal Cartesian coordinate of the rectangular bounding box of the mesh. 

        Syntax::

            getBoundMin()

        Arguments:
            None
                     
        Return:
            list<float, length = 3>

        """
        return _steps_swig.Tetmesh_getBoundMin(self)

    def getBoundMax(self):
        """
        Returns the maximal Cartesian coordinate of the rectangular bounding box of the mesh. 

        Syntax::

            getBoundMax()

        Arguments:
            None
                     
        Return:
            list<float, length = 3>

        """
        return _steps_swig.Tetmesh_getBoundMax(self)

    def getMeshVolume(self):
        """
        Returns the total volume of the mesh. 

        Syntax::

            getMeshVolume()

        Arguments:
            None
                     
        Return:
            float

        """
        return _steps_swig.Tetmesh_getMeshVolume(self)

    def getBatchTetBarycentres(self, *args):
        """
        Returns the barycentres of a list of tetrahedrons.

        Syntax::

            getBatchTetBarycentres(tets)

        Arguments:
            * list<uint> tets
                     
        Return:
            list<float, length = len(tets) * 3>

        """
        return _steps_swig.Tetmesh_getBatchTetBarycentres(self, *args)

    def getBatchTriBarycentres(self, *args):
        """
        Returns the barycentres of a list of triangles.

        Syntax::

            getBatchTetBarycentres(tris)

        Arguments:
            * list<uint> tris
                     
        Return:
            list<float, length = len(tris) * 3>

        """
        return _steps_swig.Tetmesh_getBatchTriBarycentres(self, *args)

    def getBatchTetBarycentresNP(self, *args):
        """
        Returns the barycentres of a list of tetrahedrons in numpy arrays.

        Syntax::

            import numpy as np
            indices = np.array([0, 1, 2], dtype= np.uint32)
            centres = np.zeros(len(indices) * 3)
            getBatchTetBarycentres(indices, centres)

        Arguments:
            * numpy.array<uint> indices
            * numpy.array<double, length = len(indices) * 3> centres
            
        Return:
            None

        """
        return _steps_swig.Tetmesh_getBatchTetBarycentresNP(self, *args)

    def getBatchTriBarycentresNP(self, *args):
        """
        Returns the barycentres of a list of triangles in numpy arrays.

        Syntax::

            import numpy as np
            indices = np.array([0, 1, 2], dtype= np.uint32)
            centres = np.zeros(len(indices) * 3)
            getBatchTriBarycentres(indices, centres)

        Arguments:
            * numpy.array<uint> indices
            * numpy.array<double, length = len(indices) * 3> centres
            
        Return:
            None

        """
        return _steps_swig.Tetmesh_getBatchTriBarycentresNP(self, *args)

    def getBatchVertices(self, *args):
        """
        Get coordinates of a list of vertices.

        Syntax::

            getBatchVertices(verts)

        Arguments:
            * list<uint> verts
                     
        Return:
            list<float, length = len(verts) * 3>

        """
        return _steps_swig.Tetmesh_getBatchVertices(self, *args)

    def getBatchVerticesNP(self, *args):
        """
        Get coordinates of a list of vertices.

        Syntax::

            import numpy as np
            indices = np.array([0, 1, 2], dtype= np.uint32)
            coordinates = np.zeros(len(indices) * 3)
            getBatchVertices(indices, coordinates)

        Arguments:
            * numpy.array<uint> indices
            * numpy.array<double, length = len(indices) * 3> coordinates
            
        Return:
            None

        """
        return _steps_swig.Tetmesh_getBatchVerticesNP(self, *args)

    def getBatchTris(self, *args):
        """
        Get vertex indices of a list of triangles.

        Syntax::

            getBatchTris(tris)

        Arguments:
            * list<uint> tris
                     
        Return:
            list<uint, length = len(tris) * 3>

        """
        return _steps_swig.Tetmesh_getBatchTris(self, *args)

    def getBatchTrisNP(self, *args):
        """
        Get vertex indices of a list of triangles.

        Syntax::

            getBatchTrisNP(t_indices, v_indices)

        Arguments:
            * numpy.array<uint> t_indices
            * numpy.array<uint, length = len(t_indices) * 3> v_indices
            
        Return:
            None

        """
        return _steps_swig.Tetmesh_getBatchTrisNP(self, *args)

    def getBatchTets(self, *args):
        """
        Get vertex indices of a list of tetrahedrons.

        Syntax::

            getBatchTets(tets)

        Arguments:
            * list<uint> tets
                     
        Return:
            list<uint, length = len(tets) * 4>

        """
        return _steps_swig.Tetmesh_getBatchTets(self, *args)

    def getBatchTetsNP(self, *args):
        """
        Get vertex indices of a list of triangles.

        Syntax::

            getBatchTetsNP(t_indices, v_indices)

        Arguments:
            * numpy.array<uint> t_indices
            * numpy.array<uint, length = len(t_indices) * 4> v_indices
            
        Return:
            None

        """
        return _steps_swig.Tetmesh_getBatchTetsNP(self, *args)

    def getTriVerticesSetSizeNP(self, *args):
        """
        Return the size of a set with unique vertex indices of a list of triangles,
        preparation function for furture numpy data access.

        Syntax::

            getTriVerticesSetSizeNP(t_indices)

        Arguments:
            * numpy.array<uint> t_indices
            
        Return:
            uint

        """
        return _steps_swig.Tetmesh_getTriVerticesSetSizeNP(self, *args)

    def getTetVerticesSetSizeNP(self, *args):
        """
        Return the size of a set with unique vertex indices of a list of tetrahedrons,
        preparation function for furture numpy data access.

        Syntax::

            getTetVerticesSetSizeNP(t_indices)

        Arguments:
            * numpy.array<uint> t_indices
            
        Return:
            uint

        """
        return _steps_swig.Tetmesh_getTetVerticesSetSizeNP(self, *args)

    def getTriVerticesMappingSetNP(self, *args):
        """
        Get the vertex indices of a list of triangles.
        The vertex indices are reindexed, with their oringinal STEPS indices stored in a given array,
        whose size is provided by getTriVerticesSetSizeNP().

        Syntax::

            getTriVerticesMappingSetNP(t_indices, t_vertices, v_set)

        Arguments:
            * numpy.array<uint> t_indices
            * numpy.array<uint, length = length(t_indices) * 3> t_vertices
            * numpy.array<uint, length = getTriVerticesSetSizeNP(t_indices)> v_set
            
        Return:
            None

        """
        return _steps_swig.Tetmesh_getTriVerticesMappingSetNP(self, *args)

    def getTetVerticesMappingSetNP(self, *args):
        """
        Get the vertex indices of a list of tetrahedrons.
        The vertex indices are reindexed, with their oringinal STEPS indices stored in a given array,
        whose size is provided by getTriVerticesSetSizeNP().

        Syntax::

            getTetVerticesMappingSetNP(t_indices, t_vertices, v_set)

        Arguments:
            * numpy.array<uint> t_indices
            * numpy.array<uint, length = length(t_indices) * 4> t_vertices
            * numpy.array<uint, length = getTriVerticesSetSizeNP(t_indices)> v_set
            
        Return:
            None

        """
        return _steps_swig.Tetmesh_getTetVerticesMappingSetNP(self, *args)

    def genPointsInTet(self, *args):
        """
        Generate npnts random point coordinates x,y,z within a tetraedron with index tidx, export it to NumPy array cords

        Syntax::

            genPointsInTet(t_idx, npnts, coords)

        Arguments:
            * unsigned tidx
            * unsigned npnts
            * numpy.array<double, length = npnts * 3> coords
            
        Return:
            None

        """
        return _steps_swig.Tetmesh_genPointsInTet(self, *args)

    def genPointsInTri(self, *args):
        """
        Generate npnts random point coordinates x,y,z within a triangle with index tidx, export it to NumPy array cords

        Syntax::

            genPointsInTri(t_idx, npnts, coords)

        Arguments:
            * unsigned tidx
            * unsigned npnts
            * numpy.array<double, length = npnts * 3> coords
            
        Return:
            None

        """
        return _steps_swig.Tetmesh_genPointsInTri(self, *args)

    def genTetVisualPointsNP(self, *args):
        """
        For each tetrahedron index in indices, randomly generate a set of point coordinates x,y,z within the tetrahedron, where n is
        stored in point_counts. The number of points required to be generated for tetrahedron indices[i] is point_counts[i].
        All generated points are stored in cords.

        Syntax::

            genTetVisualPointsNP(indices, point_counts, coords)

        Arguments:
            * numpy.array<uint> indices
            * numpy.array<uint, length = length(indices)> point_counts
            * numpy.array<double, length = sum(point_counts) * 3> coords
            
        Return:
            None

        """
        return _steps_swig.Tetmesh_genTetVisualPointsNP(self, *args)

    def genTriVisualPointsNP(self, *args):
        """
        For each triangle index in indices, randomly generate a set of point coordinates x,y,z within the triangle, where n is
        stored in point_counts. The number of points required to be generated for triangle indices[i] is point_counts[i].
        All generated points are stored in cords.

        Syntax::

            genTriVisualPointsNP(indices, point_counts, coords)

        Arguments:
            * numpy.array<uint> indices
            * numpy.array<uint, length = length(indices)> point_counts
            * numpy.array<double, length = sum(point_counts) * 3> coords
            
        Return:
            None

        """
        return _steps_swig.Tetmesh_genTriVisualPointsNP(self, *args)

    def getBatchTetVolsNP(self, *args):
        """
        Get the volumes of a list of tetrahedrons in indices and stored in volumes.

        Syntax::

            getBatchTetVolsNP(indices, volumes)

        Arguments:
            * numpy.array<uint> indices
            * numpy.array<double, length = length(indices)> volumes
            
        Return:
            None

        """
        return _steps_swig.Tetmesh_getBatchTetVolsNP(self, *args)

    def getBatchTriAreasNP(self, *args):
        """
        Get the areas of a list of triangles in indices and stored in areas.

        Syntax::

            getBatchTriAreasNP(indices, areas)

        Arguments:
            * numpy.array<uint> indices
            * numpy.array<double, length = length(indices)> areas
            
        Return:
            None

        """
        return _steps_swig.Tetmesh_getBatchTriAreasNP(self, *args)

    def reduceBatchTetPointCountsNP(self, *args):
        """
        Reduce the number of random point coordinates generated for each tetrahedron in indices so that the point density of the tetrahedron is below max_density. If the density is already below max_density for that tetrahedron, the count stored in point_counts is intacted.

        Syntax::

            reduceBatchTetPointCountsNP(indices, point_counts, max_density)

        Arguments:
            * numpy.array<uint> indices
            * numpy.array<double, length = length(indices)> point_counts
            * double max_density
            
        Return:
            None

        """
        return _steps_swig.Tetmesh_reduceBatchTetPointCountsNP(self, *args)

    def reduceBatchTriPointCountsNP(self, *args):
        """
        Reduce the number of random point coordinates generated for each triangle in indices so that the point density of the triangle is below max_density. If the density is already below max_density for that triangle, the count stored in point_counts is intacted.

        Syntax::

            reduceBatchTriPointCountsNP(indices, point_counts, max_density)

        Arguments:
            * numpy.array<uint> indices
            * numpy.array<double, length = length(indices)> point_counts
            * double max_density
            
        Return:
            None

        """
        return _steps_swig.Tetmesh_reduceBatchTriPointCountsNP(self, *args)

    def addROI(self, *args):
        """
        Add a Region of Interest data record with name id to the ROI dataset.
        The type of elements stored in the ROI data can be one of the follows:
        steps.geom.ELEM_VERTEX, steps.geom.ELEM_TET, steps.geom.ELEM_TRI, steps.geom.ELEM_UNDEFINED.

        Syntax::

            addROI(id, type, indices)

        Arguments:
            * string id
            * ElementType type
            * list<uint> indices
            
        Return:
            None

        """
        return _steps_swig.Tetmesh_addROI(self, *args)

    def removeROI(self, *args):
        """
        Remove a Region of Interest data record with name id.

        Syntax::

            removeROI(id)

        Arguments:
            * string id
            
        Return:
            None

        """
        return _steps_swig.Tetmesh_removeROI(self, *args)

    def replaceROI(self, *args):
        """
        Replace a Region of Interest data record with name id with new data.

        Syntax::

            replaceROI(id, type, indices)

        Arguments:
            * string id
            * ElementType type
            * list<uint> indices
            
        Return:
            None

        """
        return _steps_swig.Tetmesh_replaceROI(self, *args)

    def getROIType(self, *args):
        """
        Get the element type of a Region of Interest data record with name id.

        Syntax::

            getROIType(id)

        Arguments:
            * string id
            
        Return:
            ElementType

        """
        return _steps_swig.Tetmesh_getROIType(self, *args)

    def getROIData(self, *args):
        """
        Get the stored data of a Region of Interest data record with name id.

        Syntax::

            getROIData(id)

        Arguments:
            * string id
            
        Return:
            list<uint>

        """
        return _steps_swig.Tetmesh_getROIData(self, *args)

    def getROIDataSize(self, *args):
        """
        Get the number of elements stored in a Region of Interest data record with name id.

        Syntax::

            getROIDataSize(id)

        Arguments:
            * string id
            
        Return:
            uint

        """
        return _steps_swig.Tetmesh_getROIDataSize(self, *args)

    def getNROIs(self):
        """
        Get the number of Region of Interest data stored in the ROI dataset.

        Syntax::

            getNROIs()

        Arguments:
            None
            
        Return:
            uint

        """
        return _steps_swig.Tetmesh_getNROIs(self)

    def getROI(self, *args):
        """
        Get a Region of Interest data record with name id.

        Syntax::

            getROI(id)

        Arguments:
            * string id
            
        Return:
            ROISet

        """
        return _steps_swig.Tetmesh_getROI(self, *args)

    def getAllROINames(self):
        """
        Get a list of the names of all Region of Interest data stored in ROI dataset.

        Syntax::

            getAllROINames(id)

        Arguments:
            None
            
        Return:
            list<string>

        """
        return _steps_swig.Tetmesh_getAllROINames(self)

    def getROITetBarycentres(self, *args):
        """
        Get barycentres of elements stored in a tetrahedral ROI.

        Syntax::

            getROITetBarycentres(ROI_id)

        Arguments:
            * string ROI_id
            
        Return:
            list<double>

        """
        return _steps_swig.Tetmesh_getROITetBarycentres(self, *args)

    def getROITetBarycentresNP(self, *args):
        """
        Get barycentres of elements stored in a tetrahedral ROI and write to a NumPy array centres.
        The size of centres should be the same as the number of elements stored in the ROI.

        Syntax::

            getROITetBarycentresNP(ROI_id, centres)

        Arguments:
            * string ROI_id
            * numpy.array<double> centres
            
        Return:
            None

        """
        return _steps_swig.Tetmesh_getROITetBarycentresNP(self, *args)

    def getROITriBarycentres(self, *args):
        """
        Get barycentres of elements stored in a triangular ROI.

        Syntax::

            getROITriBarycentres(ROI_id)

        Arguments:
            * string ROI_id
            
        Return:
            list<double>

        """
        return _steps_swig.Tetmesh_getROITriBarycentres(self, *args)

    def getROITriBarycentresNP(self, *args):
        """
        Get barycentres of elements stored in a triangular ROI and write to a NumPy array centres.
        The size of centres should be the same as the number of elements stored in the ROI.

        Syntax::

            getROITriBarycentresNP(ROI_id, centres)

        Arguments:
            * string ROI_id
            * numpy.array<double> centres
            
        Return:
            None

        """
        return _steps_swig.Tetmesh_getROITriBarycentresNP(self, *args)

    def getROIVertices(self, *args):
        """
        Get coordinates of elements stored in a vertices ROI.

        Syntax::

            getROIVertices(ROI_id)

        Arguments:
            * string ROI_id
            
        Return:
            list<double>

        """
        return _steps_swig.Tetmesh_getROIVertices(self, *args)

    def getROIVerticesNP(self, *args):
        """
        Get coordinates of elements stored in a vertices ROI and write to a NumPy array coordinates.
        The size of coordinates should be the same as the number of elements stored in the ROI.

        Syntax::

            getROIVerticesNP(ROI_id, coordinates)

        Arguments:
            * string ROI_id
            * numpy.array<double> coordinates
            
        Return:
            None

        """
        return _steps_swig.Tetmesh_getROIVerticesNP(self, *args)

    def getROITris(self, *args):
        """
        Get vertices of elements stored in a triangular ROI.

        Syntax::

            getROITris(ROI_id)

        Arguments:
            * string ROI_id
            
        Return:
            list<uint>

        """
        return _steps_swig.Tetmesh_getROITris(self, *args)

    def getROITrisNP(self, *args):
        """
        Get vertices of elements stored in a triangular ROI and write to a NumPy array v_indices.
        The size of v_indices should be 3 * the number of elements stored in the ROI.

        Syntax::

            getROITrisNP(ROI_id, v_indices)

        Arguments:
            * string ROI_id
            * numpy.array<uint> v_indices
            
        Return:
            None

        """
        return _steps_swig.Tetmesh_getROITrisNP(self, *args)

    def getROITets(self, *args):
        """
        Get vertices of elements stored in a tetrahedral ROI.

        Syntax::

            getROITets(ROI_id)

        Arguments:
            * string ROI_id
            
        Return:
            list<uint>

        """
        return _steps_swig.Tetmesh_getROITets(self, *args)

    def getROITetsNP(self, *args):
        """
        Get vertices of elements stored in a tetrahedral ROI and write to a NumPy array v_indices.
        The size of v_indices should be 3 * the number of elements stored in the ROI.

        Syntax::

            getROITetsNP(ROI_id, v_indices)

        Arguments:
            * string ROI_id
            * numpy.array<uint> v_indices
            
        Return:
            None

        """
        return _steps_swig.Tetmesh_getROITetsNP(self, *args)

    def getROITriVerticesSetSizeNP(self, *args):
        """
        Add all vertex indices of a list of triangles in a ROI to a set and return its size.

        Syntax::

            getROITriVerticesSetSizeNP(ROI_id)

        Arguments:
            * string ROI_id
            
        Return:
            uint

        """
        return _steps_swig.Tetmesh_getROITriVerticesSetSizeNP(self, *args)

    def getROITetVerticesSetSizeNP(self, *args):
        """
        Add all vertex indices of a list of tetrahedrons in a ROI to a set and return its size.

        Syntax::

            getROITetVerticesSetSizeNP(ROI_id)

        Arguments:
            * string ROI_id
            
        Return:
            uint

        """
        return _steps_swig.Tetmesh_getROITetVerticesSetSizeNP(self, *args)

    def getROITriVerticesMappingSetNP(self, *args):
        """
        Add all vertex indices of a list of triangles in a ROI to a set and write it to a NumPy array v_set.
        For each of the triangle, t_vertices records the positions of its vertices in v_set.
        i.e. For the i triangle in the ROI, the STEPS indices of its vertices are
        v_set[t_vertices[3*i]], v_set[t_vertices[3*i + 1]], v_set[t_vertices[3*i + 2]]

        Syntax::

            getROITriVerticesMappingSetNP(ROI_id, t_vertices, v_set)

        Arguments:
            * string ROI_id
            * numpy.array<uint> v_indices
            * numpy.array<uint> v_set
            
        Return:
            None

        """
        return _steps_swig.Tetmesh_getROITriVerticesMappingSetNP(self, *args)

    def getROITetVerticesMappingSetNP(self, *args):
        """
        Add all vertex indices of a list of tetrahedrons in a ROI to a set and write it to a NumPy array v_set.
        For each of the tetrahedron, t_vertices records the positions of its vertices in v_set.
        i.e. For the i tetrahedron in the ROI, the STEPS indices of its vertices are
        v_set[t_vertices[4*i]], v_set[t_vertices[4*i + 1]], v_set[t_vertices[4*i + 2]], v_set[t_vertices[4*i + 3]]

        Syntax::

            getROITetVerticesMappingSetNP(ROI_id, t_vertices, v_set)

        Arguments:
            * string ROI_id
            * numpy.array<uint> v_indices
            * numpy.array<uint> v_set
            
        Return:
            None

        """
        return _steps_swig.Tetmesh_getROITetVerticesMappingSetNP(self, *args)

    def genROITetVisualPointsNP(self, *args):
        """
        For each tetrahedron index in a ROI, randomly generate a set of point coordinates x,y,z within the tetrahedron, where n is
        stored in point_counts. The number of points required to be generated for tetrahedron i in the ROI is point_counts[i].
        All generated points are stored in cords.

        Syntax::

            genTetVisualPointsNP(ROI_id, point_counts, coords)

        Arguments:
            * string ROI_id
            * numpy.array<uint> point_counts
            * numpy.array<double> coords
            
        Return:
            None

        """
        return _steps_swig.Tetmesh_genROITetVisualPointsNP(self, *args)

    def genROITriVisualPointsNP(self, *args):
        """
        For each triangle index in a ROI, randomly generate a set of point coordinates x,y,z within the triangle, where n is
        stored in point_counts. The number of points required to be generated for triangle i in the ROI is point_counts[i].
        All generated points are stored in cords.

        Syntax::

            genROITriVisualPointsNP(ROI_id, point_counts, coords)

        Arguments:
            * string ROI_id
            * numpy.array<uint> point_counts
            * numpy.array<double> coords
            
        Return:
            None

        """
        return _steps_swig.Tetmesh_genROITriVisualPointsNP(self, *args)

    def getROITetVolsNP(self, *args):
        """
        Get the volumes of a list of tetrahedrons in a ROI and stored in volumes.

        Syntax::

            getROITetVolsNP(indices, volumes)

        Arguments:
            * string ROI_id
            * numpy.array<double> volumes
            
        Return:
            None

        """
        return _steps_swig.Tetmesh_getROITetVolsNP(self, *args)

    def getROITriAreasNP(self, *args):
        """
        Get the areas of a list of triangles in a ROI and stored in areas.

        Syntax::

            getROITriAreasNP(indices, areas)

        Arguments:
            * string ROI_id
            * numpy.array<double> areas
            
        Return:
            None

        """
        return _steps_swig.Tetmesh_getROITriAreasNP(self, *args)

    def reduceROITetPointCountsNP(self, *args):
        """
        Reduce the number of random point coordinates generated for each tetrahedron in a ROI so that the point density of the tetrahedron is below max_density. If the density is already below max_density for that tetrahedron, the count stored in point_counts is intacted.

        Syntax::

            reduceROITetPointCountsNP(indices, point_counts, max_density)

        Arguments:
            * string ROI_id
            * numpy.array<double> point_counts
            * double max_density
            
        Return:
            None

        """
        return _steps_swig.Tetmesh_reduceROITetPointCountsNP(self, *args)

    def reduceROITriPointCountsNP(self, *args):
        """
        Reduce the number of random point coordinates generated for each triangle in a ROI so that the point density of the triangle is below max_density. If the density is already below max_density for that triangle, the count stored in point_counts is intacted.

        Syntax::

            reduceROITriPointCountsNP(ROI_id, point_counts, max_density)

        Arguments:
            * string ROI_id
            * numpy.array<double, length = length(indices)> point_counts
            * double max_density
            
        Return:
            None

        """
        return _steps_swig.Tetmesh_reduceROITriPointCountsNP(self, *args)

Tetmesh_swigregister = _steps_swig.Tetmesh_swigregister
Tetmesh_swigregister(Tetmesh)

class TmComp(Comp):
    """Proxy of C++ steps::tetmesh::TmComp class"""
    __swig_setmethods__ = {}
    for _s in [Comp]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TmComp, name, value)
    __swig_getmethods__ = {}
    for _s in [Comp]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TmComp, name)
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """
        Returns a list of references to steps.geom.Patch patch objects: 
        the 'outer' patches.

        Syntax::

            getOPatches()

        Arguments:
            None
                     
        Return:
            list<steps.geom.Patch>

        """
        this = _steps_swig.new_TmComp(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_TmComp
    __del__ = lambda self : None;
    def setVol(self, *args):
        """Obsolete"""
        return _steps_swig.TmComp_setVol(self, *args)

    def getAllTetIndices(self):
        """
        Returns a list of indices of all tetrahedrons assigned to the compartment. 

        Syntax::

            getAllTetIndices()

        Arguments:
            None
                     
        Return:
            list<uint>

        """
        return _steps_swig.TmComp_getAllTetIndices(self)

    def countTets(self):
        """
        Returns the number of tetrahedrons assigned to the compartment. 

        Syntax::

            countTets()

        Arguments:
            None
                     
        Return:
            uint

        """
        return _steps_swig.TmComp_countTets(self)

    def isTetInside(self, *args):
        """
        Returns a list of Booleans describing if tetrahedrons tets are 
        assigned to the compartment.

        Syntax::
            
            isTetInside(tets)

        Arguments:
            list<uint> tets
                     
        Return:
            list<bool, length = length(tets)>

        """
        return _steps_swig.TmComp_isTetInside(self, *args)

    def getBoundMin(self):
        """
        Returns the minimal Cartesian coordinate of the rectangular bounding box 
        of the compartment. 

        Syntax::

            getBoundMin()

        Arguments:
            None
                     
        Return:
            list<float, length = 3>

        """
        return _steps_swig.TmComp_getBoundMin(self)

    def getBoundMax(self):
        """
        Returns the maximal Cartesian coordinate of the rectangular bounding box 
        of the compartment. 

        Syntax::

            getBoundMax()

        Arguments:
            None
                     
        Return:
            list<float, length = 3>

        """
        return _steps_swig.TmComp_getBoundMax(self)

TmComp_swigregister = _steps_swig.TmComp_swigregister
TmComp_swigregister(TmComp)

class TmPatch(Patch):
    """Proxy of C++ steps::tetmesh::TmPatch class"""
    __swig_setmethods__ = {}
    for _s in [Patch]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TmPatch, name, value)
    __swig_getmethods__ = {}
    for _s in [Patch]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TmPatch, name)
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """
        Returns a reference to the steps.geom.Comp compartment object representing
        the outer compartment.

        Syntax::
            
            getOComp()

        Arguments:
            None
                     
        Return:
            steps.geom.Comp

        """
        this = _steps_swig.new_TmPatch(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_TmPatch
    __del__ = lambda self : None;
    def getAllTriIndices(self):
        """
        Returns a list of indices of all triangles assigned to the patch.

        Syntax::

            getAllTriIndices()

        Arguments:
            None
                     
        Return:
            list<uint>

        """
        return _steps_swig.TmPatch_getAllTriIndices(self)

    def isTriInside(self, *args):
        """
        Returns a list of Booleans describing if triangles tris are 
        assigned to the patch.

        Syntax::

            isTriInside(tris)

        Arguments:
            list<uint> tris
                     
        Return:
            list<bool, length = length(tris)>

        """
        return _steps_swig.TmPatch_isTriInside(self, *args)

    def getBoundMin(self):
        """
        Returns the minimal Cartesian coordinate of the rectangular bounding box 
        of the compartment. 

        Syntax::

            getBoundMin()

        Arguments:
            None
                     
        Return:
            list<float, length = 3>

        """
        return _steps_swig.TmPatch_getBoundMin(self)

    def getBoundMax(self):
        """
        Returns the maximal Cartesian coordinate of the rectangular bounding box 
        of the compartment. 

        Syntax::

            getBoundMax()

        Arguments:
            None
                     
        Return:
            list<float, length = 3>

        """
        return _steps_swig.TmPatch_getBoundMax(self)

TmPatch_swigregister = _steps_swig.TmPatch_swigregister
TmPatch_swigregister(TmPatch)

class Memb(_object):
    """Proxy of C++ steps::tetmesh::Memb class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Memb, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Memb, name)
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """
        __init__(steps::tetmesh::Memb self, std::string const & id, Tetmesh container, vector_tmp patches, bool verify=False, 
            uint opt_method=1, double search_percent=100.0, std::string const & opt_file_name="") -> Memb
        """
        this = _steps_swig.new_Memb(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_Memb
    __del__ = lambda self : None;
    def getID(self):
        """
        Get the identifier string of the membrane.
        			 
        Syntax::
        			 
            getID()
        			 
        Arguments:
            None
                     
        Return:
            string

        """
        return _steps_swig.Memb_getID(self)

    def getContainer(self):
        """
        Returns a reference to the parent steps.geom.Tetmesh container object.
        			 
        Syntax::
        			 
            getTetmesh()
        			 
        Arguments:
            None
                     
        Return:
            steps.tetmesh.Tetmesh

        """
        return _steps_swig.Memb_getContainer(self)

    def isTriInside(self, *args):
        """
        Returns a list of Booleans describing if triangles tris are 
        assigned to the membrane.

        Syntax::

            isTriInside(tris)

        Arguments:
            list<uint> tris
                     
        Return:
            list<bool, length = length(tris)>

        """
        return _steps_swig.Memb_isTriInside(self, *args)

    def getAllTriIndices(self):
        """
        Returns a list of indices of all triangles assigned to the membrane.

        Syntax::

            getAllTriIndices()

        Arguments:
            None
                     
        Return:
            list<uint>

        """
        return _steps_swig.Memb_getAllTriIndices(self)

    def getAllVolTetIndices(self):
        """
        Returns a list of indices of all tetrahedrons assigned to the conduction volume.

        Syntax::
        			 
            getAllVolTetIndices()
        			 
        Arguments:
            None

        Return:
            list<uint>

        """
        return _steps_swig.Memb_getAllVolTetIndices(self)

    def getAllVertIndices(self):
        """
        Returns a list of all vertices in the conduction volume.

        Syntax:
        			
            getAllVertices()

        Arguments:
        	None

        Return:
        	list<uint>

        """
        return _steps_swig.Memb_getAllVertIndices(self)

    def getAllVirtTriIndices(self):
        """
        Returns a list of all virtual triangles for the membrane forming a closed surface.

        Syntax:

            getAllVirtTris()

        Arguments:
            None

        Return:
            list<uint>


        """
        return _steps_swig.Memb_getAllVirtTriIndices(self)

    def countVolTets(self):
        """
        Returns the number of tetrahedrons assigned to the conduction volume.
        	
        Syntax::
        	
        	countVolTets()
        	
        Arguments:
        	None

        Return:
        	uint
        	

        """
        return _steps_swig.Memb_countVolTets(self)

    def countVirtTris(self):
        """
        Returns the number of virtual triangles for the membrane forming a closed surface.

        Syntax:
        	
        	countTris()
        	
        Arguments:
        	None
        	
        Return:
        	uint


        """
        return _steps_swig.Memb_countVirtTris(self)

    def countTris(self):
        """
        Returns the number of triangles assigned to the membrane.
        			 
        Syntax:
        			 
            countTris()
        			 
        Arguments:
            None
        			 
        Return:
            uint
        			 

        """
        return _steps_swig.Memb_countTris(self)

    def countVerts(self):
        """
        Returns the number of vertices in the conduction volume and membrane surface.
        	
        Syntax:
        	
        	countVertices()

        Arguments:
        	None
        	
        Returns:
        	uint
        	

        """
        return _steps_swig.Memb_countVerts(self)

Memb_swigregister = _steps_swig.Memb_swigregister
Memb_swigregister(Memb)

class DiffBoundary(_object):
    """Proxy of C++ steps::tetmesh::DiffBoundary class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DiffBoundary, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DiffBoundary, name)
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """__init__(steps::tetmesh::DiffBoundary self, std::string const & id, Tetmesh container, vector_uint tris) -> DiffBoundary"""
        this = _steps_swig.new_DiffBoundary(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_DiffBoundary
    __del__ = lambda self : None;
    def getID(self):
        """
        Get the identifier string of the diffusion boundary.

        Syntax::

            getID()

        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.DiffBoundary_getID(self)

    def setID(self, *args):
        """
        Set the identifier string of the diffusion boundary.

        Syntax::

            setID(name)

        Arguments:
            string name

        Return:
            None

        """
        return _steps_swig.DiffBoundary_setID(self, *args)

    def getContainer(self):
        """
        Returns a reference to the parent steps.tetmesh.Tetmesh container object.

        Syntax::

            getContainer()

        Arguments:
            None

        Return:
            steps.tetmesh.Tetmesh

        """
        return _steps_swig.DiffBoundary_getContainer(self)

    def getComps(self):
        """
        Returns a list of the two compartments this diffusion boundary connects.

        Syntax::

            getComps()

        Arguments:
            None

        Return:
            list<steps::wm::Comp, length = 2>

        """
        return _steps_swig.DiffBoundary_getComps(self)

    def isTriInside(self, *args):
        """
        Returns a list of Booleans describing if triangles tris are 
        assigned to the Diffusion Boundary.

        Syntax::

            isTriInside(tris)

        Arguments:
            list<uint> tris

        Return:
            list<bool, length = length(tris)>

        """
        return _steps_swig.DiffBoundary_isTriInside(self, *args)

    def getAllTriIndices(self):
        """
        Returns a list of indices of all triangles assigned to the patch.

        Syntax::

            getAllTriIndices()

        Arguments:
            None

        Return:
            list<uint>

        """
        return _steps_swig.DiffBoundary_getAllTriIndices(self)

DiffBoundary_swigregister = _steps_swig.DiffBoundary_swigregister
DiffBoundary_swigregister(DiffBoundary)

class RNG(_object):
    """
    Proxy of C++ random number generator.


    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RNG, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RNG, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _steps_swig.delete_RNG
    __del__ = lambda self : None;
    def initialize(self, *args):
        """
        Initialize the random number generator with given seed value.


        Syntax::
            
            initialize(seed)
            
        Arguments:
            uint seed

        Return:
            None

        """
        return _steps_swig.RNG_initialize(self, *args)

    def get(self):
        """
        Initialize the random number generator with given seed value.


        Syntax::
            
            initialize(seed)
            
        Arguments:
            uint seed

        Return:
            None

        """
        return _steps_swig.RNG_get(self)

    def getUnfII(self):
        """
        Initialize the random number generator with given seed value.


        Syntax::
            
            initialize(seed)
            
        Arguments:
            uint seed

        Return:
            None

        """
        return _steps_swig.RNG_getUnfII(self)

    def getUnfIE(self):
        """
        Initialize the random number generator with given seed value.


        Syntax::
            
            initialize(seed)
            
        Arguments:
            uint seed

        Return:
            None

        """
        return _steps_swig.RNG_getUnfIE(self)

    def getUnfEE(self):
        """
        Initialize the random number generator with given seed value.


        Syntax::
            
            initialize(seed)
            
        Arguments:
            uint seed

        Return:
            None

        """
        return _steps_swig.RNG_getUnfEE(self)

    def getUnfIE53(self):
        """
        Initialize the random number generator with given seed value.


        Syntax::
            
            initialize(seed)
            
        Arguments:
            uint seed

        Return:
            None

        """
        return _steps_swig.RNG_getUnfIE53(self)

    def getStdExp(self):
        """
        Initialize the random number generator with given seed value.


        Syntax::
            
            initialize(seed)
            
        Arguments:
            uint seed

        Return:
            None

        """
        return _steps_swig.RNG_getStdExp(self)

    def getExp(self, *args):
        """
        Initialize the random number generator with given seed value.


        Syntax::
            
            initialize(seed)
            
        Arguments:
            uint seed

        Return:
            None

        """
        return _steps_swig.RNG_getExp(self, *args)

    def getPsn(self, *args):
        """
        Initialize the random number generator with given seed value.


        Syntax::
            
            initialize(seed)
            
        Arguments:
            uint seed

        Return:
            None

        """
        return _steps_swig.RNG_getPsn(self, *args)

    def getStdNrm(self):
        """
        Initialize the random number generator with given seed value.


        Syntax::
            
            initialize(seed)
            
        Arguments:
            uint seed

        Return:
            None

        """
        return _steps_swig.RNG_getStdNrm(self)

RNG_swigregister = _steps_swig.RNG_swigregister
RNG_swigregister(RNG)


def create_mt19937(*args):
  """
    Equivalent to: create('mt19937', buffer_size)

    Syntax::

        create_mt19937(buffer_size)
        
    Arguments:
        uint buffer_size

    Return:
        steps.rng.RNG

    """
  return _steps_swig.create_mt19937(*args)

def create(*args):
  """
    Creates and returns a reference to a steps.rng.RNG random number generator object, 
    which is specified by type and pre-allocates a buffer list with size of buffer_size.

    Syntax::
        
        create(type, buffer_size)

    Arguments:
        * string type
        * uint buffer_size

    Return:
        steps.rng.RNG

    """
  return _steps_swig.create(*args)
class structC(_object):
    """Proxy of C++ steps::tetode::structC class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, structC, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, structC, name)
    __repr__ = _swig_repr
    __swig_setmethods__["order"] = _steps_swig.structC_order_set
    __swig_getmethods__["order"] = _steps_swig.structC_order_get
    if _newclass:order = _swig_property(_steps_swig.structC_order_get, _steps_swig.structC_order_set)
    __swig_setmethods__["spec_idx"] = _steps_swig.structC_spec_idx_set
    __swig_getmethods__["spec_idx"] = _steps_swig.structC_spec_idx_get
    if _newclass:spec_idx = _swig_property(_steps_swig.structC_spec_idx_get, _steps_swig.structC_spec_idx_set)
    def __init__(self): 
        """__init__(steps::tetode::structC self) -> structC"""
        this = _steps_swig.new_structC()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_structC
    __del__ = lambda self : None;
structC_swigregister = _steps_swig.structC_swigregister
structC_swigregister(structC)

class structB(_object):
    """Proxy of C++ steps::tetode::structB class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, structB, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, structB, name)
    __repr__ = _swig_repr
    __swig_setmethods__["info"] = _steps_swig.structB_info_set
    __swig_getmethods__["info"] = _steps_swig.structB_info_get
    if _newclass:info = _swig_property(_steps_swig.structB_info_get, _steps_swig.structB_info_set)
    def __init__(self): 
        """__init__(steps::tetode::structB self) -> structB"""
        this = _steps_swig.new_structB()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_structB
    __del__ = lambda self : None;
structB_swigregister = _steps_swig.structB_swigregister
structB_swigregister(structB)

class structA(_object):
    """Proxy of C++ steps::tetode::structA class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, structA, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, structA, name)
    __repr__ = _swig_repr
    __swig_setmethods__["ccst"] = _steps_swig.structA_ccst_set
    __swig_getmethods__["ccst"] = _steps_swig.structA_ccst_get
    if _newclass:ccst = _swig_property(_steps_swig.structA_ccst_get, _steps_swig.structA_ccst_set)
    __swig_setmethods__["upd"] = _steps_swig.structA_upd_set
    __swig_getmethods__["upd"] = _steps_swig.structA_upd_get
    if _newclass:upd = _swig_property(_steps_swig.structA_upd_get, _steps_swig.structA_upd_set)
    __swig_setmethods__["players"] = _steps_swig.structA_players_set
    __swig_getmethods__["players"] = _steps_swig.structA_players_get
    if _newclass:players = _swig_property(_steps_swig.structA_players_get, _steps_swig.structA_players_set)
    def __init__(self): 
        """__init__(steps::tetode::structA self) -> structA"""
        this = _steps_swig.new_structA()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_structA
    __del__ = lambda self : None;
structA_swigregister = _steps_swig.structA_swigregister
structA_swigregister(structA)

class vector_strb(_object):
    """Proxy of C++ std::vector<(steps::tetode::structB)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_strb, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_strb, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(vector_strb self) -> SwigPyIterator"""
        return _steps_swig.vector_strb_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(vector_strb self) -> bool"""
        return _steps_swig.vector_strb___nonzero__(self)

    def __bool__(self):
        """__bool__(vector_strb self) -> bool"""
        return _steps_swig.vector_strb___bool__(self)

    def __len__(self):
        """__len__(vector_strb self) -> std::vector< steps::tetode::structB >::size_type"""
        return _steps_swig.vector_strb___len__(self)

    def pop(self):
        """pop(vector_strb self) -> structB"""
        return _steps_swig.vector_strb_pop(self)

    def __getslice__(self, *args):
        """__getslice__(vector_strb self, std::vector< steps::tetode::structB >::difference_type i, std::vector< steps::tetode::structB >::difference_type j) -> vector_strb"""
        return _steps_swig.vector_strb___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(vector_strb self, std::vector< steps::tetode::structB >::difference_type i, std::vector< steps::tetode::structB >::difference_type j, 
            vector_strb v=std::vector< steps::tetode::structB,std::allocator< steps::tetode::structB > >())
        __setslice__(vector_strb self, std::vector< steps::tetode::structB >::difference_type i, std::vector< steps::tetode::structB >::difference_type j)
        """
        return _steps_swig.vector_strb___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(vector_strb self, std::vector< steps::tetode::structB >::difference_type i, std::vector< steps::tetode::structB >::difference_type j)"""
        return _steps_swig.vector_strb___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(vector_strb self, std::vector< steps::tetode::structB >::difference_type i)
        __delitem__(vector_strb self, PySliceObject * slice)
        """
        return _steps_swig.vector_strb___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(vector_strb self, PySliceObject * slice) -> vector_strb
        __getitem__(vector_strb self, std::vector< steps::tetode::structB >::difference_type i) -> structB
        """
        return _steps_swig.vector_strb___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(vector_strb self, PySliceObject * slice, vector_strb v)
        __setitem__(vector_strb self, PySliceObject * slice)
        __setitem__(vector_strb self, std::vector< steps::tetode::structB >::difference_type i, structB x)
        """
        return _steps_swig.vector_strb___setitem__(self, *args)

    def append(self, *args):
        """append(vector_strb self, structB x)"""
        return _steps_swig.vector_strb_append(self, *args)

    def empty(self):
        """empty(vector_strb self) -> bool"""
        return _steps_swig.vector_strb_empty(self)

    def size(self):
        """size(vector_strb self) -> std::vector< steps::tetode::structB >::size_type"""
        return _steps_swig.vector_strb_size(self)

    def clear(self):
        """clear(vector_strb self)"""
        return _steps_swig.vector_strb_clear(self)

    def swap(self, *args):
        """swap(vector_strb self, vector_strb v)"""
        return _steps_swig.vector_strb_swap(self, *args)

    def get_allocator(self):
        """get_allocator(vector_strb self) -> std::vector< steps::tetode::structB >::allocator_type"""
        return _steps_swig.vector_strb_get_allocator(self)

    def begin(self):
        """begin(vector_strb self) -> std::vector< steps::tetode::structB >::iterator"""
        return _steps_swig.vector_strb_begin(self)

    def end(self):
        """end(vector_strb self) -> std::vector< steps::tetode::structB >::iterator"""
        return _steps_swig.vector_strb_end(self)

    def rbegin(self):
        """rbegin(vector_strb self) -> std::vector< steps::tetode::structB >::reverse_iterator"""
        return _steps_swig.vector_strb_rbegin(self)

    def rend(self):
        """rend(vector_strb self) -> std::vector< steps::tetode::structB >::reverse_iterator"""
        return _steps_swig.vector_strb_rend(self)

    def pop_back(self):
        """pop_back(vector_strb self)"""
        return _steps_swig.vector_strb_pop_back(self)

    def erase(self, *args):
        """
        erase(vector_strb self, std::vector< steps::tetode::structB >::iterator pos) -> std::vector< steps::tetode::structB >::iterator
        erase(vector_strb self, std::vector< steps::tetode::structB >::iterator first, std::vector< steps::tetode::structB >::iterator last) -> std::vector< steps::tetode::structB >::iterator
        """
        return _steps_swig.vector_strb_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(steps::tetode::structB)> self) -> vector_strb
        __init__(std::vector<(steps::tetode::structB)> self, vector_strb arg2) -> vector_strb
        __init__(std::vector<(steps::tetode::structB)> self, std::vector< steps::tetode::structB >::size_type size) -> vector_strb
        __init__(std::vector<(steps::tetode::structB)> self, std::vector< steps::tetode::structB >::size_type size, structB value) -> vector_strb
        """
        this = _steps_swig.new_vector_strb(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(vector_strb self, structB x)"""
        return _steps_swig.vector_strb_push_back(self, *args)

    def front(self):
        """front(vector_strb self) -> structB"""
        return _steps_swig.vector_strb_front(self)

    def back(self):
        """back(vector_strb self) -> structB"""
        return _steps_swig.vector_strb_back(self)

    def assign(self, *args):
        """assign(vector_strb self, std::vector< steps::tetode::structB >::size_type n, structB x)"""
        return _steps_swig.vector_strb_assign(self, *args)

    def resize(self, *args):
        """
        resize(vector_strb self, std::vector< steps::tetode::structB >::size_type new_size)
        resize(vector_strb self, std::vector< steps::tetode::structB >::size_type new_size, structB x)
        """
        return _steps_swig.vector_strb_resize(self, *args)

    def insert(self, *args):
        """
        insert(vector_strb self, std::vector< steps::tetode::structB >::iterator pos, structB x) -> std::vector< steps::tetode::structB >::iterator
        insert(vector_strb self, std::vector< steps::tetode::structB >::iterator pos, std::vector< steps::tetode::structB >::size_type n, 
            structB x)
        """
        return _steps_swig.vector_strb_insert(self, *args)

    def reserve(self, *args):
        """reserve(vector_strb self, std::vector< steps::tetode::structB >::size_type n)"""
        return _steps_swig.vector_strb_reserve(self, *args)

    def capacity(self):
        """capacity(vector_strb self) -> std::vector< steps::tetode::structB >::size_type"""
        return _steps_swig.vector_strb_capacity(self)

    __swig_destroy__ = _steps_swig.delete_vector_strb
    __del__ = lambda self : None;
vector_strb_swigregister = _steps_swig.vector_strb_swigregister
vector_strb_swigregister(vector_strb)

class API(_object):
    """Proxy of C++ steps::solver::API class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, API, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, API, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _steps_swig.delete_API
    __del__ = lambda self : None;
    def getSolverName(self):
        """
        Returns a string of the solver's name.

        Syntax::
            
            getSolverName()
            
        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.API_getSolverName(self)

    def getSolverDesc(self):
        """
        Returns a string giving a short description of the solver.

        Syntax::
            
            getSolverDesc()
            
        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.API_getSolverDesc(self)

    def getSolverAuthors(self):
        """
        Returns a string of the solver authors names.

        Syntax::
            
            getSolverAuthors()
            
        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.API_getSolverAuthors(self)

    def getSolverEmail(self):
        """
        Returns a string giving the author's email address.

        Syntax::
            
            getSolverEmail()
            
        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.API_getSolverEmail(self)

    def checkpoint(self, *args):
        """
        Checkpoint data to a file.
            
        Syntax::
            
            checkpoint(file_name)
            
        Arguments:
            string file_name
            
        Return:
            None

        """
        return _steps_swig.API_checkpoint(self, *args)

    def restore(self, *args):
        """
        Restore data from a file.
            
        Syntax::
            
            restore(file_name)
            
        Arguments:
            string file_name
            
        Return:
            None

        """
        return _steps_swig.API_restore(self, *args)

    def reset(self):
        """
        Reset the simulation to the state the solver was initialised to. 
        Typically, this resets all concentrations of all chemical species in 
        all elements (whether compartments and patches in a well-mixed solver 
        or tetrahedrons and triangles in a mesh-based solver) to zero, 
        resets the simulation time to zero and resets reaction (and diffusion) 
        rates to the default values described in the steps.model objects. 
        All reaction (and diffusion) rules are reset to active and all 
        compartment volumes and patch areas are reset to default values 
        described in steps.geom objects (for well-mixed solvers). 
        Usually, this method should be called before starting each simulation iteration.

        Syntax::
            
            reset()
            
        Arguments:
            None

        Return:
            None

        """
        return _steps_swig.API_reset(self)

    def run(self, *args):
        """
        Advance the simulation until endtime (given in seconds) is reached. 
        The endtime must be larger or equal to the current simulation time.

        Syntax::
            
            run(endtime)
            
        Arguments:
            float endtime

        Return:
            None

        """
        return _steps_swig.API_run(self, *args)

    def getTime(self):
        """
        Returns the current simulation time in seconds.

        Syntax::
            
            getTime()
            
        Arguments:
            None

        Return:
            float

        """
        return _steps_swig.API_getTime(self)

    def advance(self, *args):
        """
        Advance the simulation for secs seconds. 

        Syntax::
            
            advance(adv)
            
        Arguments:
            float adv

        Return:
            None

        """
        return _steps_swig.API_advance(self, *args)

    def step(self):
        """
        Advance the simulation for one 'step'. In stochastic solvers this is one 
        'realization' of the Gillespie SSA (one reaction 'event'). 
        In numerical solvers (currently Wmrk4) this is one time-step, with the 
        stepsize defined with the setDT method.

        Syntax::
            
            step()
            
        Arguments:
            None

        Return:
            None

        """
        return _steps_swig.API_step(self)

    def setRk4DT(self, *args):
        """
        Set the stepsize for numerical solvers. Must be called before running a 
        simulation with these solvers (currently Wmrk4) since there is no default 
        stepsize. The deterministic solver Wmrk4 implements a fixed stepsize 
        (i.e. not adaptive), although the stepsize can be altered at any point 
        during the simulation with this method.

        Syntax::
            
            setRk4tDT(dt)
            
        Arguments:
            float dt

        Return:
            None

        """
        return _steps_swig.API_setRk4DT(self, *args)

    def getRk4DT(self):
        """
        Returns the stepsize for numerical solvers.

        Syntax::
            
            getRk4DT()
            
        Arguments:
            None

        Return:
            float

        """
        return _steps_swig.API_getRk4DT(self)

    def setDT(self, *args):
        """
        Set the stepsize for numerical solvers. Superceded by setRk4DT, but
        Included for backwards compatability.
         
        Syntax::
         
            setDT(dt)
         
        Arguments:
            float dt
         
        Return:
            None

        """
        return _steps_swig.API_setDT(self, *args)

    def getDT(self):
        """
        Returns the stepsize for numerical solvers.
        Superceded by getRk4DT, but included for backwards compatibility.

        Syntax::
            
            getDT()
            
        Arguments:
            None

        Return:
            float

        """
        return _steps_swig.API_getDT(self)

    def setEfieldDT(self, *args):
        """
        Set the stepsize for membrane potential solver (default 1us).
        This is the time for each voltage calculation step. The SSA will
        run until passing this stepsize, so in fact each membrane potential 
        time step will vary slightly around the dt so as to be aligned with the SSA.

        Syntax::
            
            setEFieldDT(dt)
            
        Arguments:
            float dt

        Return:
            None

        """
        return _steps_swig.API_setEfieldDT(self, *args)

    def setTime(self, *args):
        """
        Set the current simulation time.

        Syntax::
            
            setTime(time)
            
        Arguments:
            float time

        Return:
            None

        """
        return _steps_swig.API_setTime(self, *args)

    def getA0(self):
        """
        Returns the total propensity of the current simulation state 
        (the total propensity multiplied by an infinitesimally small 
        time dt gives the probability that a reaction will occur in that dt). 
        For Tetexact this includes the propensity from the extension of the SSA 
        for diffusive flux between tetrahedral elements in the mesh.

        Syntax::
            
            getA0()
            
        Arguments:
            None

        Return:
            float

        """
        return _steps_swig.API_getA0(self)

    def setTemp(self, *args):
        """
        Set the simulation temperature. Currently, this will only
        influence the GHK flux rate, so will only influence simulations
        including membrane potential calculation.
        	
        Syntax::
        	
        	setTemp(temp)
        	
        Arguments:
        	float temp

        Return:
        	None

        """
        return _steps_swig.API_setTemp(self, *args)

    def getTemp(self):
        """
        Return the simulation temperature.
        			 
        Syntax::
        			 
        	getTemp()
        		
        Arguments:
        	None
        	
        Return:
        	float

        """
        return _steps_swig.API_getTemp(self)

    def getNSteps(self):
        """
        Return the number of 'realizations' of the SSA, the number of reaction 
        (and diffusion) events in stochastic solvers.

        Syntax::
            
            getNSteps()
            
        Arguments:
            None

        Return:
            uint

        """
        return _steps_swig.API_getNSteps(self)

    def setNSteps(self, *args):
        """
        Set the number of 'realizations' of the SSA, the number of reaction 
        (and diffusion) events in stochastic solvers.

        Syntax::
            
            setNSteps(nsteps)
            
        Arguments:
            uint nsteps

        Return:
            None

        """
        return _steps_swig.API_setNSteps(self, *args)

    def getCompVol(self, *args):
        """
        Returns the volume of compartment with identifier string comp (in m^3).

        Syntax::
            
            getCompVol(comp)
            
        Arguments:
            string comp

        Return:
            float

        """
        return _steps_swig.API_getCompVol(self, *args)

    def setCompVol(self, *args):
        """
        Set the volume of compartment with identifier string comp (in m^3).

        Syntax::
            
            setCompVol(comp, vol)
            
        Arguments:
            * string comp
            * float vol

        Return:
            None

        """
        return _steps_swig.API_setCompVol(self, *args)

    def getCompCount(self, *args):
        """
        Returns the number of molecules of a species with identifier string spec 
        in compartment with identifier string comp.

        In a mesh-based simulation this is the combined count from 
        all tetrahedral elements in the compartment.

        Syntax::
            
            getCompCount(comp, spec)
            
        Arguments:
            * string comp
            * string spec

        Return:
            float

        """
        return _steps_swig.API_getCompCount(self, *args)

    def setCompCount(self, *args):
        """
        Set the number of molecules of a species with identifier string spec 
        in compartment with identifier string comp.

        In a mesh-based simulation this is the combined count from 
        all tetrahedral elements in the compartment.

        Syntax::
            
            setCompCount(comp, spec, nspec)
            
        Arguments:
            * string comp
            * string spec
            * uint nspec

        Return:
            None

        """
        return _steps_swig.API_setCompCount(self, *args)

    def getCompAmount(self, *args):
        """
        Returns the amount (in mols) of species with identifier string spec in compartment 
        with identifier string comp.

        In a mesh-based simulation this is the combined amount from all 
        tetrahedral elements in the compartment.

        Syntax::
            
            getCompAmount(comp, spec)
            
        Arguments:
            * string comp
            * string spec

        Return:
            float

        """
        return _steps_swig.API_getCompAmount(self, *args)

    def setCompAmount(self, *args):
        """
        Set the amount (in mols) of species with identifier string spec in compartment 
        with identifier string comp.

        In a mesh-based simulation this is the combined amount from all 
        tetrahedral elements in the compartment.

        Syntax::
            
            setCompAmount(comp, spec, amount)
            
        Arguments:
            * string comp
            * string spec
            * float amount

        Return:
            None

        """
        return _steps_swig.API_setCompAmount(self, *args)

    def getCompConc(self, *args):
        """
        Returns the concentration (in Molar units) of species with identifier string spec 
        in compartment with identifier string comp.

        Note: in a mesh-based simulation this is calculated from the combined 
        number of molecules from all tetrahedral elements in the compartment and the total 
        volume of the tetrahedrons.

        Syntax::
            
            getCompConc(comp, spec)
            
        Arguments:
            * string comp
            * string spec

        Return:
            float

        """
        return _steps_swig.API_getCompConc(self, *args)

    def setCompConc(self, *args):
        """
        Sets the concentration (in Molar units) of species with identifier string spec 
        in compartment with identifier string comp to conc. In a discrete solver the 
        continuous concentration is converted to a discrete number of 
        molecules.

        Note: in a mesh-based simulation the molecules are divided as 
        equally as possible over all tetrahedral elements in the compartment (i.e. a 
        uniform distribution).

        Syntax::

            setCompConc(comp, spec, conc)
            
        Arguments:
            * string comp
            * string spec
            * float conc

        Return:
            None

        """
        return _steps_swig.API_setCompConc(self, *args)

    def getCompClamped(self, *args):
        """
        Returns True if species with identifier string spec in compartment with identifier 
        string comp is clamped, which means the concentration remains the same 
        regardless of reactions that consume or produce molecules of this species. 
        Returns False if not.

        Note: in a mesh-based simulation it returns True only if the species 
        is clamped in all tetrahedral elements of the compartment.

        Syntax::
            
            getCompClamped(comp, spec)
            
        Arguments:
            * string comp
            * string spec

        Return:
            bool

        """
        return _steps_swig.API_getCompClamped(self, *args)

    def setCompClamped(self, *args):
        """
        Sets whether the concentration of species with identifier string spec in compartment 
        with identifier string comp is clamped (clamped = True) or not (clamped = False). 
        If a species is clamped the concentration stays the same regardless of reactions 
        that consume or produce molecules of the species.

        Note: in a mesh-based simulation this will set the species to be 
        clamped or not in all tetrahedral elements of the compartment.

        Syntax::
            
            setCompClamped(comp, spec, clamped)
            
        Arguments:
            * string comp
            * string spec
            * bool clamped

        Return:
            bool

        """
        return _steps_swig.API_setCompClamped(self, *args)

    def getCompReacK(self, *args):
        """
        Returns the macroscopic reaction constant of reaction with identifier string reac 
        in compartment with identifier string comp. The unit of the reaction constant depends 
        on the order of the reaction.

        Note: In a mesh-based simulation the value for the compartment is 
        returned, although individual tetrahedral elements may have different values 
        (set with setTetReacK).

        Syntax::
            
            getCompReacK(comp, reac)
            
        Arguments:
            * string comp
            * string reac

        Return:
            float

        """
        return _steps_swig.API_getCompReacK(self, *args)

    def setCompReacK(self, *args):
        """
        Sets the macroscopic reaction constant of reaction with identifier string reac 
        in compartment with identifier string comp to kf. The unit of the reaction constant 
        depends on the order of the reaction.

        Note: In a mesh-based simulation this method sets the reaction 
        constant in all tetrahedral elements of the compartment to kf

        Note: The default value still comes from the steps.model description, so 
        calling reset() will return the reaction constant to that value.

        Syntax::
            
            setCompReacK(comp, reac, kf)
            
        Arguments:
            * string comp
            * string reac
            * float kf

        Return:
            None

        """
        return _steps_swig.API_setCompReacK(self, *args)

    def getCompReacActive(self, *args):
        """
        Returns whether a reaction with identifier string reac in compartment with identifier 
        string comp is active (True) or not (False). If it's not active this means that a 
        reaction will never occur regardless of whether the reactants are present in 
        sufficient numbers or not. 

        Note: In a mesh-based simulation this method will return True only 
        if the reaction is active in all tetrahedral elements in the compartment. 

        Syntax::
            
            getCompReacActive(comp, reac)
            
        Arguments:
            * string comp
            * string reac

        Return:
            bool

        """
        return _steps_swig.API_getCompReacActive(self, *args)

    def setCompReacActive(self, *args):
        """
        Activate (active = True) or deactivate (active = False) a reaction with identifier 
        string reac in compartment with identifier string comp. If a reaction is not active 
        this means that a reaction will never occur regardless of whether the reactants are 
        present in sufficient numbers or not.

        Note: In a mesh-based simulation this will activate/deactivate the 
        reaction in all tetrahedral elements in the compartment. 

        Syntax::
            
            setCompReacActive(comp, reac, active)
            
        Arguments:
            * string comp
            * string reac
            * bool active

        Return:
            None

        """
        return _steps_swig.API_setCompReacActive(self, *args)

    def getCompDiffD(self, *args):
        """
        Returns the diffusion constant of diffusion rule with identifier string diff 
        in compartment with identifier string comp. This constant is in units m^2/s.

        Note: In a mesh-based solver the value for the compartment is 
        returned, although individual or groups of tetrahedral elements may have different 
        values (set with setTetDiffD). 

        Syntax::
            
            getCompDiffD(comp, diff)
            
        Arguments:
            * string comp
            * string diff

        Return:
            float

        """
        return _steps_swig.API_getCompDiffD(self, *args)

    def setCompDiffD(self, *args):
        """
        Sets the diffusion constant of diffusion rule with identifier string diff 
        in compartment with identifier string comp to dcst (in m^2/s).

        Note: This method will set the diffusion constant in all tetrahedral elements 
        in the compartment.

        Note: The default value still comes from the steps.model description, 
        so calling reset() will return the diffusion constants to that value. 

        Syntax::
            
            setCompDiffD(comp, diff, dcst)
            
        Arguments:
            * string comp
            * string diff
            * float dcst

        Return:
            None

        """
        return _steps_swig.API_setCompDiffD(self, *args)

    def getCompDiffActive(self, *args):
        """
        Returns whether a diffusion rule with identifier string diff in compartment with 
        identifier string comp is active (True) or not (False). If diffusion of a species 
        is inactive this means the molecules will remain in place and has the same effect 
        as a diffusion constant of zero. 

        Syntax::
            
            getCompDiffActive(comp, diff)
            
        Arguments:
            * string comp
            * string diff

        Return:
            bool

        """
        return _steps_swig.API_getCompDiffActive(self, *args)

    def setCompDiffActive(self, *args):
        """
        Activate (active = True) or deactivate (active = False) a diffusion rule with 
        identifier string diff in compartment with identifier string comp. If diffusion 
        of a species is inactive this means the molecules will remain in place and is 
        effectively the same as setting the diffusion constant to zero

        Syntax::
            
            setCompDiffActive(comp, diff, active)
            
        Arguments:
            * string comp
            * string diff
            * bool active

        Return:
            None

        """
        return _steps_swig.API_setCompDiffActive(self, *args)

    def getCompReacC(self, *args):
        """
        Returns the 'stochastic reaction constant' (or 'specific probability rate constant') 
        of reaction with identifier string reac in compartment with identifier string comp.

        The 'stochastic reaction constant' multiplied by infinitesimal time interval dt 
        gives the average probability that one reaction channel of this reaction type 
        will react accordingly in dt.

        Note: in a mesh-based simulation (i.e. Tetexact), the stochastic reaction constant 
        is computed as the weighted mean of the stochastic reaction constants in all 
        tetrahedral elements of the compartment.

        Syntax::
            
            getCompReacC(comp, reac)
            
        Arguments:
            * string comp
            * string reac

        Return:
            float

        """
        return _steps_swig.API_getCompReacC(self, *args)

    def getCompReacH(self, *args):
        """
        Returns h_mu, the distinct number of ways in which reaction with identifier string 
        reac can occur in compartment with identifier string comp, by computing the product 
        of its reactants. Note: in a mesh-based simulation (i.e. Tetexact), returns the sum 
        of the h_mu's over all tetrahedral elements in the compartment. 

        Syntax::
            
            getCompReacH(comp, reac)
            
        Arguments:
            * string comp
            * string reac

        Return:
            float

        """
        return _steps_swig.API_getCompReacH(self, *args)

    def getCompReacA(self, *args):
        """
        Returns the propensity of reaction with identifier string reac in compartment 
        with identifier string comp. 

        The propensity of a reaction is a function of state and is defined as the 
        function whose product with infinitesimal time dt gives the probability 
        that the reaction will occur in the next dt. It is the 'stochastic reaction 
        constant' multiplied by 'h_mu'. 

        Note: in a mesh-based simulation (i.e. Tetexact), the propensity of a reaction 
        in a compartment is computed as the sum of the propensities in all tetrahedral 
        elements of the compartment. 

        Syntax::
            
            getCompReacA(comp, reac)
            
        Arguments:
            * string comp
            * string reac

        Return:
            float

        """
        return _steps_swig.API_getCompReacA(self, *args)

    def getCompReacExtent(self, *args):
        """
        Return the extent of reaction with identifier string reac in compartment with 
        identifier string comp, that is the number of times the reaction has occurred up 
        to the current simulation time. 

        Note: in a mesh-based simulation (i.e. Tetexact), returns the sum of the reaction 
        extents in all tetrahedral elements of the compartment.

        Syntax::
            
            getCompReacExtent(comp, reac)
            
        Arguments:
            * string comp
            * string reac

        Return:
            uint

        """
        return _steps_swig.API_getCompReacExtent(self, *args)

    def resetCompReacExtent(self, *args):
        """
        Resets the extent of reaction with identifier string reac in compartment with 
        identifier string comp to zero. 

        Note: in a mesh-based simulation (i.e. Tetexact), 
        resets the extents of the reaction in all tetrahedral elements of the compartment.

        Syntax::
            
            resetCompReacExtent(comp, reac)
            
        Arguments:
            * string comp
            * string reac

        Return:
            None

        """
        return _steps_swig.API_resetCompReacExtent(self, *args)

    def getTetVol(self, *args):
        """
        Returns the volume (in m^3) of the tetrahedral element with index idx.

        Syntax::
            
            getTetVol(idx)
            
        Arguments:
            * uint idx

        Return:
            float

        """
        return _steps_swig.API_getTetVol(self, *args)

    def getTetSpecDefined(self, *args):
        """
        Returns whether species with identifier string spec is defined
        in the tetrahedral element with index idx.

        Syntax::
            
            getTetSpecDefined(idx, spec)
            
        Arguments:
            * uint idx
            * string spec

        Return:
            bool

        """
        return _steps_swig.API_getTetSpecDefined(self, *args)

    def getTetCount(self, *args):
        """
        Returns the number of molecules of species with identifier string spec 
        in the tetrahedral element with index idx.

        Syntax::
            
            getTetCount(idx, spec)
            
        Arguments:
            * uint idx
            * string spec

        Return:
            uint

        """
        return _steps_swig.API_getTetCount(self, *args)

    def setTetCount(self, *args):
        """
        Sets the number of molecules of species with identifier string spec in 
        tetrahedral element with index idx to n.

        Syntax::
            
            setTetCount(idx, spec, n)
            
        Arguments:
            * uint idx
            * string spec
            * uint n

        Return:
            None

        """
        return _steps_swig.API_setTetCount(self, *args)

    def getTetAmount(self, *args):
        """
        Returns the amount (in mols) of species with identifier string spec in 
        tetrahedral element with index idx.

        Syntax::
            
            getTetAmount(idx, spec)
            
        Arguments:
            * uint idx
            * string spec

        Return:
            float

        """
        return _steps_swig.API_getTetAmount(self, *args)

    def setTetAmount(self, *args):
        """
        Sets the amount (in mols) of species with identifier string spec in tetrahedral 
        element with index idx to a. This continuous value must be converted internally 
        to a discrete number of molecules by multiplication with Avogadro's 
        number. 

        Due to the small volumes of tetrahedral elements the difference 
        between 'rounding up' and 'rounding down' can be a significant difference in 
        concentration.

        Syntax::
            
            setTetAmount(idx, spec, a)
            
        Arguments:
            * uint idx
            * string spec
            * float a

        Return:
            None

        """
        return _steps_swig.API_setTetAmount(self, *args)

    def getTetConc(self, *args):
        """
        Returns the concentration (in Molar units) of species with identifier 
        string spec in a tetrahedral element with index idx.

        Syntax::
            
            getTetConc(idx, spec)
            
        Arguments:
            * uint idx
            * string spec

        Return:
            float

        """
        return _steps_swig.API_getTetConc(self, *args)

    def setTetConc(self, *args):
        """
        Sets the concentration (in Molar units) of species with identifier string spec 
        in a tetrahedral element with index idx to conc.This continuous value must be 
        converted internally to a discrete number of molecules. 

        Due to the small volumes of tetrahedral elements the difference between 'rounding 
        up' and 'rounding down' can be a large difference in concentration.

        Syntax::
            
            setTetConc(idx, spec, conc)
            
        Arguments:
            * uint idx
            * string spec
            * conc

        Return:
            None

        """
        return _steps_swig.API_setTetConc(self, *args)

    def getTetClamped(self, *args):
        """
        Returns True if concentration of species with identifier string spec in tetrahedral 
        element with index idx is clamped, which means the concentration stays the 
        same regardless of reactions that consume or produce molecules of this species or 
        diffusion of this species into or out of the tetrahedral element. Returns False if 
        not.

        Syntax::
            
            getTetClamped(idx, spec)
            
        Arguments:
            * uint idx
            * string spec

        Return:
            bool

        """
        return _steps_swig.API_getTetClamped(self, *args)

    def setTetClamped(self, *args):
        """
        Sets whether the concentration of species spec in tetrahedral element with 
        index idx is clamped (clamped = True) or not (clamped = False). 
        If a species is clamped the concentration stays the same regardless 
        of reactions that consume or produce molecules of the species or 
        diffusion of the species into or out of the tetrahedral element.

        Syntax::
            
            setTetClamped(idx, spec, clamped)
            
        Arguments:
            * uint idx
            * string spec
            * bool clamped

        Return:
            None

        """
        return _steps_swig.API_setTetClamped(self, *args)

    def getTetReacK(self, *args):
        """
        Returns the macroscopic reaction constant of reaction with identifier string reac 
        in tetrahedral element with index idx. The unit of the reaction constant depends 
        on the order of the reaction.

        Syntax::
            
            getTetReacK(idx, reac)
            
        Arguments:
            * uint idx
            * string reac

        Return:
            float

        """
        return _steps_swig.API_getTetReacK(self, *args)

    def setTetReacK(self, *args):
        """
        Sets the macroscopic reaction constant of reaction with identifier string reac 
        in tetrahedral element with index idx to kf. The units of the reaction constant 
        depends on the order of the reaction.

        Syntax::
            
            setTetReacK(idx, reac, kf)
            
        Arguments:
            * uint idx
            * string reac
            * float kf

        Return:
            None

        """
        return _steps_swig.API_setTetReacK(self, *args)

    def getTetReacActive(self, *args):
        """
        Returns whether reaction with identifier string reac in tetrahedral element 
        with index idx is active (True) or not (False). If it's not active this means 
        that the reaction will never occur regardless of whether reactants are present 
        in sufficient numbers or not.

        Syntax::
            
            getTetReacActive(idx, reac)
            
        Arguments:
            * uint idx
            * string reac

        Return:
            bool

        """
        return _steps_swig.API_getTetReacActive(self, *args)

    def setTetReacActive(self, *args):
        """
        Activate (active = True) or deactivate (active = False) a reaction with identifier 
        string reac in tetrahedral element with index idx. If it's not active this means 
        that the reaction will never occur regardless of whether reactants are present 
        in sufficient numbers or not.

        Syntax::
            
            setTetReacActive(idx, reac, active)
            
        Arguments:
            * uint idx
            * string reac
            * bool active

        Return:
            None

        """
        return _steps_swig.API_setTetReacActive(self, *args)

    def getTetDiffD(self, *args):
        """
        Returns the diffusion constant of diffusion rule with identifier string diff 
        in tetrahedral element with index idx. This constant is in units m^2/s. If direction_tet is specified, return the diffusion constant towards that direction.

        Syntax::
            
            getTetDiffD(idx, diff, direction_tet = UINT_MAX)
            
        Arguments:
            * uint idx
            * string diff
            * direction_tet
            
        Return:
            float


        Returns the diffusion constant of diffusion rule with identifier string diff 
        in tetrahedral element with index idx. This constant is in units m^2/s. If direction_tet is specified, return the diffusion constant towards that direction.

        Syntax::
            
            getTetDiffD(idx, diff, direction_tet = UINT_MAX)
            
        Arguments:
            * uint idx
            * string diff
            * direction_tet
            
        Return:
            float

        """
        return _steps_swig.API_getTetDiffD(self, *args)

    def setTetDiffD(self, *args):
        """
        Sets the diffusion constant of diffusion rule with identifier string diff in 
        tetrahedral element with index idx to dcst (in m^2/s). Specify direction_tet to set the constant only towards a given tetrahedron direction.
        Syntax::
            
            setTetDiffD(idx, diff, dcst, direction_tet = UINT_MAX)
            
        Arguments:
            * uint idx
            * string diff
            * dcst
            * direction_tet

        Return:
            None


        Sets the diffusion constant of diffusion rule with identifier string diff in 
        tetrahedral element with index idx to dcst (in m^2/s). Specify direction_tet to set the constant only towards a given tetrahedron direction.
        Syntax::
            
            setTetDiffD(idx, diff, dcst, direction_tet = UINT_MAX)
            
        Arguments:
            * uint idx
            * string diff
            * dcst
            * direction_tet

        Return:
            None

        """
        return _steps_swig.API_setTetDiffD(self, *args)

    def getTriDiffD(self, *args):
        """
        Returns the diffusion constant of diffusion rule with identifier string diff 
        in triangle element with index idx. If direction_tri is specified, return the diffusion constant towards that direction.

        Syntax::
            
            getTriDiffD(idx, diff, direction_tri = UINT_MAX)
            
        Arguments:
            * uint idx
            * string diff
            * direction_tri
            
        Return:
            float


        Returns the diffusion constant of diffusion rule with identifier string diff 
        in triangle element with index idx. If direction_tri is specified, return the diffusion constant towards that direction.

        Syntax::
            
            getTriDiffD(idx, diff, direction_tri = UINT_MAX)
            
        Arguments:
            * uint idx
            * string diff
            * direction_tri
            
        Return:
            float

        """
        return _steps_swig.API_getTriDiffD(self, *args)

    def setTriDiffD(self, *args):
        """
        Sets the diffusion constant of diffusion rule with identifier string diff in 
        triangle element with index idx to dcst. Specify direction_tri to set the constant only towards a given triangle direction.
        Syntax::
            
            setTriDiffD(idx, diff, dcst, direction_tri = UINT_MAX)
            
        Arguments:
            * uint idx
            * string diff
            * dcst
            * direction_tri

        Return:
            None


        Sets the diffusion constant of diffusion rule with identifier string diff in 
        triangle element with index idx to dcst. Specify direction_tri to set the constant only towards a given triangle direction.
        Syntax::
            
            setTriDiffD(idx, diff, dcst, direction_tri = UINT_MAX)
            
        Arguments:
            * uint idx
            * string diff
            * dcst
            * direction_tri

        Return:
            None

        """
        return _steps_swig.API_setTriDiffD(self, *args)

    def getTetDiffActive(self, *args):
        """
        Returns whether diffusion with identifier string diff in tetrahedral element 
        with index idx is active (True) or not (False). If diffusion of a species 
        is inactive this means the molecules will never diffuse out of the tetrahedron 
        and has the same effect as a diffusion constant of zero.

        Syntax::
            
            getTetDiffActive(idx, diff)
            
        Arguments:
            * uint idx
            * string diff

        Return:
            bool

        """
        return _steps_swig.API_getTetDiffActive(self, *args)

    def setTetDiffActive(self, *args):
        """
        Activate (active = True) or deactivate (active = False) diffusion rule with 
        identifier string diff in tetrahedral element with index idx. If diffusion of 
        a species is inactive this means the molecules will never diffuse out of the 
        tetrahedron and has the same effect as a diffusion constant of zero. 

        Syntax::
            
            setTetDiffActive(idx, diff, active)
            
        Arguments:
            * uint idx
            * string diff
            * bool active

        Return:
            None

        """
        return _steps_swig.API_setTetDiffActive(self, *args)

    def getTetReacC(self, *args):
        """
        Returns the 'stochastic reaction constant' (or 'specific probability rate constant') 
        of reaction with identifier string reac in tetrahedral element with index idx.

        Syntax::
            
            getTetReacC(idx, reac)
            
        Arguments:
            * uint idx
            * string reac

        Return:
            float

        """
        return _steps_swig.API_getTetReacC(self, *args)

    def getTetReacH(self, *args):
        """
        Returns h_mu, the distinct number of ways in which reaction with identifier string 
        reac can occur in tetrahedral element with index idx, by computing the product of 
        its reactants.

        Syntax::
            
            getTetReacH(idx, reac)
            
        Arguments:
            * uint idx
            * string reac

        Return:
            float

        """
        return _steps_swig.API_getTetReacH(self, *args)

    def getTetReacA(self, *args):
        """
        Returns the propensity of reaction with identifier string reac in tetrahedral 
        element with index idx.

        Syntax::
            
            getTetReacA(idx, reac)
            
        Arguments:
            * uint idx
            * string reac

        Return:
            float

        """
        return _steps_swig.API_getTetReacA(self, *args)

    def getTetDiffA(self, *args):
        """
        Returns the propensity of diffusion rule with identifier string diff in 
        tetrahedral element with index idx. 

        Syntax::
            
            getTetDiffA(idx, reac)
            
        Arguments:
            * uint idx
            * string reac

        Return:
            float

        """
        return _steps_swig.API_getTetDiffA(self, *args)

    def getTetV(self, *args):
        """
        Returns the potential (in volts) of tetrahedral element with index idx, taken at the barycenter.
        			
        Syntax::
        			 
        	getTetV(idx)
        			 
        Arguments:
        	uint idx
        		
        Returns:
        	float

        """
        return _steps_swig.API_getTetV(self, *args)

    def setTetV(self, *args):
        """
        Set the potential (in volts) of tetrahedral element with index idx.
        			
        Syntax::
        			 
        	setTetV(idx, v)
        			 
        Arguments:
        	* uint idx
        	* float v
        			 
        Returns:
        	None

        """
        return _steps_swig.API_setTetV(self, *args)

    def getTetVClamped(self, *args):
        """
        Returns true if the potential of tetrahedral element with index idx is clamped
        to some voltage.
        			
        Syntax::
        			 
        	getTetVClamped(idx)
        			 
        Arguments:
        	uint idx
        		
        Returns:
        	bool

        """
        return _steps_swig.API_getTetVClamped(self, *args)

    def setTetVClamped(self, *args):
        """
        Sets whether the potential of tetrahedral element with index idx is clamped
        (clamped = True) or not (clamped = False).
        			
        Syntax::
        			 
        	setTetVClamped(idx, clamped)
        			 
        Arguments:
        	* uint idx
        	* bool clamped
        			 
        Returns:
        	None

        """
        return _steps_swig.API_setTetVClamped(self, *args)

    def getPatchArea(self, *args):
        """
        Returns the area of patch with identifier string pat (in m^2).

        Syntax::
            
            getPatchArea(pat)
            
        Arguments:
            * string pat

        Return:
            float

        """
        return _steps_swig.API_getPatchArea(self, *args)

    def setPatchArea(self, *args):
        """
        Sets the area of patch with identifier string pat to area a (in m^2).

        Syntax::
            
            setPatchArea(pat, area)
            
        Arguments:
            * string pat
            * float area

        Return:
            None

        """
        return _steps_swig.API_setPatchArea(self, *args)

    def getPatchCount(self, *args):
        """
        Returns the number of molecules of species with identifier string spec in patch 
        with identifier string pat.Note: in a mesh-based simulation this 
        is the combined count from all triangular elements in the patch. 

        Syntax::
            
            getPatchCount(pat, spec)
            
        Arguments:
            * string pat
            * string spec

        Return:
            float

        """
        return _steps_swig.API_getPatchCount(self, *args)

    def setPatchCount(self, *args):
        """
        Sets the number of molecules of species with identifier string spec in patch 
        with identifier string pat to n. Note: in a mesh-based simulation the molecules 
        are divided as equally as possible over all triangular elements in 
        the patch (i.e. a uniform distribution). 

        Syntax::
            
            setPatchCount(pat, spec, n)
            
        Arguments:
            * string pat
            * string spec
            * uint n

        Return:
            float

        """
        return _steps_swig.API_setPatchCount(self, *args)

    def getPatchAmount(self, *args):
        """
        Returns the amount (in mols) of species with identifier string spec in patch 
        with identifier string pat.

        Note: in a mesh-based simulation this is the combined amount 
        from all triangular elements in the patch. 

        Syntax::
            
            getPatchAmount(pat, spec)
            
        Arguments:
            * string pat
            * string spec

        Return:
            float

        """
        return _steps_swig.API_getPatchAmount(self, *args)

    def setPatchAmount(self, *args):
        """
        Sets the amount (in mols) of species with identifier string spec in patch with 
        identifier string pat to a. In a discrete solver, such as Wmdirect and Tetexact, 
        this continuous value is converted internally into a discrete number of molecules 
        by multiplication with Avogadro's number. 

        Note: in a mesh-based simulation the molecules are divided as 
        equally as possible over all triangular elements in the patch (i.e. a uniform 
        distribution).

        Syntax::
            
            setPatchAmount(pat, spec, a)
            
        Arguments:
            * string pat
            * string spec
            * float a

        Return:
            None

        """
        return _steps_swig.API_setPatchAmount(self, *args)

    def getPatchClamped(self, *args):
        """
        Sets the amount (in mols) of species with identifier string spec in patch with 
        identifier string pat to a. In a discrete solver, such as Wmdirect and Tetexact, 
        this continuous value is converted internally into a discrete number of molecules 
        by multiplication with Avogadro's number. 

        Note: in a mesh-based simulation the molecules are divided as equally 
        as possible over all triangular elements in the patch (i.e. a uniform distribution).

        Syntax::
            
            getPatchClamped(pat, spec)
            
        Arguments:
            * string pat
            * string spec

        Return:
            bool

        """
        return _steps_swig.API_getPatchClamped(self, *args)

    def setPatchClamped(self, *args):
        """
        Sets whether the species with identifier string spec in patch with identifier 
        string pat is clamped (clamped = True) or not (clamped = False). If a species 
        is clamped the number of molecules stays the same regardless of surface reactions 
        that consume or produce molecules of the species.

        Note: in a mesh-based simulation this will set the species to be clamped in all 
        triangular elements of the patch.

        Syntax::
            
            setPatchClamped(pat, spec, clamped)
            
        Arguments:
            * string pat
            * string spec
            * bool clamped

        Return:
            None

        """
        return _steps_swig.API_setPatchClamped(self, *args)

    def getPatchSReacK(self, *args):
        """
        Returns the macroscopic reaction constant of surface reaction with identifier 
        string sreac in patch with identifier string pat. The unit of the reaction constant 
        depends on the order of the reaction.

        Note: In a mesh-based solver the value for the patch is returned, 
        although individual triangle elements may have different values 
        (set with setTriSReacK).

        Syntax::
            
            getPatchSReacK(pat, reac)
            
        Arguments:
            * string pat
            * string reac

        Return:
            float

        """
        return _steps_swig.API_getPatchSReacK(self, *args)

    def setPatchSReacK(self, *args):
        """
        Sets the macroscopic reaction constant of surface reaction with identifier 
        string sreac in patch with identifier string pat to kf. The unit of the reaction 
        constant depends on the order of the reaction. 

        Note: In a mesh-based simulation this method sets the surface 
        reaction constant in all triangular elements of the patch to kf.

        Note: The default value still comes from the steps.model description, so calling 
        reset() will return the surface reaction constant to that value.

        Syntax::
            
            setPatchSReacK(pat, reac, kf)
            
        Arguments:
            * string pat
            * string reac
            * float kf

        Return:
            None

        """
        return _steps_swig.API_setPatchSReacK(self, *args)

    def getPatchSReacActive(self, *args):
        """
        Returns whether a surface reaction with identifier string sreac in patch with 
        identifier string pat is active (True) or not (False). If it's not active this means 
        that a surface reaction will never occur regardless of whether the reactants are 
        present in sufficient numbers or not. 

        Note: In a mesh-based simulation this method will return True only 
        if the surface reaction is active in all triangular elements in the patch.

        Syntax::
            
            getPatchSReacActive(pat, reac)
            
        Arguments:
            * string pat
            * string reac

        Return:
            bool

        """
        return _steps_swig.API_getPatchSReacActive(self, *args)

    def setPatchSReacActive(self, *args):
        """
        Activate (active = True) or deactivate (active = False) a surface reaction with 
        identifier string sreac in patch with identifier string pat. If a surface reaction 
        is not active this means that a reaction will never occur regardless of whether the 
        reactants are present in sufficient numbers or not.

        Note: In a mesh-based simulation this will activate/ deactivate the 
        reaction in all triangular elements in the patch.

        Syntax::
            
            setPatchSReacActive(pat, reac, active)
            
        Arguments:
            * string pat
            * string reac
            * bool active

        Return:
            None

        """
        return _steps_swig.API_setPatchSReacActive(self, *args)

    def getPatchSReacC(self, *args):
        """
        Returns the 'stochastic reaction constant' (or 'specific probability rate constant') 
        of surface reaction with identifier string sreac in patch with identifier string pat.

        Note: in a mesh-based simulation (i.e. Tetexact), the stochastic reaction constant is 
        computed as the weighted mean of the stochastic reaction constants in all triangular 
        elements of the patch.

        Syntax::
            
            getPatchSReacC(pat, reac)
            
        Arguments:
            * string pat
            * string reac

        Return:
            float

        """
        return _steps_swig.API_getPatchSReacC(self, *args)

    def getPatchSReacH(self, *args):
        """
        Returns h_mu, the distinct number of ways in which surface reaction with identifier 
        string sreac can occur in patch with identifier string pat, by computing the product 
        of its reactants. Note: in a mesh-based simulation (i.e. Tetexact), returns the sum 
        of the h_mu's over all triangular elements in the patch. 

        Syntax::
            
            getPatchSReacH(pat, reac)
            
        Arguments:
            * string pat
            * string reac

        Return:
            float

        """
        return _steps_swig.API_getPatchSReacH(self, *args)

    def getPatchSReacA(self, *args):
        """
        Returns the propensity of surface reaction with identifier string sreac in patch 
        with identifier string pat. Note: in a mesh-based simulation (i.e. Tetexact), 
        the propensity of a surface reaction in a patch is computed as the sum of the 
        propensities in all triangular elements of the patch.

        Syntax::
            
            getPatchSReacA(pat, reac)
            
        Arguments:
            * string pat
            * string reac

        Return:
            float

        """
        return _steps_swig.API_getPatchSReacA(self, *args)

    def getPatchSReacExtent(self, *args):
        """
        Returns the extent of surface reaction with identifier string sreac in patch 
        with identifier string pat, that is the number of times the surface reaction 
        has occurred up to the current simulation time. 

        Note: in a mesh-based simulation (i.e. Tetexact), returns the sum of the reaction 
        extents in all triangular elements of the patch.

        Syntax::
            
            getPatchSReacExtent(pat,reac)
            
        Arguments:
            * string pat
            * string reac

        Return:
            uint

        """
        return _steps_swig.API_getPatchSReacExtent(self, *args)

    def resetPatchSReacExtent(self, *args):
        """
        Resets the extent of reaction with identifier string sreac in patch with identifier 
        string pat to zero. 

        Note: in a mesh-based simulation (i.e. Tetexact), resets the extents of the reaction 
        in all triangular elements of the patch.

        Syntax::
            
            resetPatchSReacExtent(pat, reac)
            
        Arguments:
            * string pat
            * string reac

        Return:
            None

        """
        return _steps_swig.API_resetPatchSReacExtent(self, *args)

    def getPatchVDepSReacActive(self, *args):
        """
        Returns whether a voltage-dependent surface reaction with identifier string vsreac in patch with 
        identifier string pat is active (True) or not (False). If it's not active this means 
        that the voltage-dependent surface reaction will never occur regardless of whether the reactants are 
        present in sufficient numbers or not. 

        Note: In a mesh-based simulation this method will return True only 
        if the voltage-dependent surface reaction is active in all triangular elements in the patch.

        Syntax::

            getPatchVDepSReacActive(pat, vsreac)

        Arguments:
            * string pat
            * string vsreac

        Return:
            bool

        """
        return _steps_swig.API_getPatchVDepSReacActive(self, *args)

    def setPatchVDepSReacActive(self, *args):
        """
        Activate (active = True) or deactivate (active = False) a voltage-dependent surface reaction with 
        identifier string vsreac in patch with identifier string pat. If a voltage-dependent surface reaction 
        is not active this means that a reaction will never occur regardless of whether the 
        reactants are present in sufficient numbers or not.

        Note: In a mesh-based simulation this will activate/ deactivate the 
        reaction in all triangular elements in the patch.

        Syntax::

            setPatchVDepSReacActive(pat, vsreac, active)

        Arguments:
            * string pat
            * string vsreac
            * bool active

        Return:
            None

        """
        return _steps_swig.API_setPatchVDepSReacActive(self, *args)

    def setDiffBoundaryDiffusionActive(self, *args):
        """
        Activates or inactivates diffusion across a diffusion boundary for a species.
                     
        Syntax::
                     
            setDiffBoundaryDiffusionActive(diffb, spec, act)
                     
        Arguments:
            * string diffb
            * string spec
            * bool act
                     
        Return:
            None

        """
        return _steps_swig.API_setDiffBoundaryDiffusionActive(self, *args)

    def getDiffBoundaryDiffusionActive(self, *args):
        """
        Returns whether diffusion is active across a diffusion boundary for a species.
                     
        Syntax::
                     
            getDiffBoundaryDiffusionActive(diffb, spec)
                     
        Arguments:
            * string diffb
            * string spec
                     
        Return:
            bool

        """
        return _steps_swig.API_getDiffBoundaryDiffusionActive(self, *args)

    def setDiffBoundaryDcst(self, *args):
        """
        Set the diffusion constant of tetrahedrons across a diffusion boundary. If direction_comp is provided, only set dcsts of diffusion towards it (Directional dcsts of diffusions in tetrahedrons in the other compartment of the diffusion boundary towards tetrahedons in the direction compartment).
                     
        Syntax::
                     
            setDiffBoundaryDcst(diffb, spec, dcst, direction_comp = '')
                     
        Arguments:
            * string diffb
            * string spec
            * double dcst
            * direction_comp
                     
        Return:
            None


        Set the diffusion constant of tetrahedrons across a diffusion boundary. If direction_comp is provided, only set dcsts of diffusion towards it (Directional dcsts of diffusions in tetrahedrons in the other compartment of the diffusion boundary towards tetrahedons in the direction compartment).
                     
        Syntax::
                     
            setDiffBoundaryDcst(diffb, spec, dcst, direction_comp = '')
                     
        Arguments:
            * string diffb
            * string spec
            * double dcst
            * direction_comp
                     
        Return:
            None

        """
        return _steps_swig.API_setDiffBoundaryDcst(self, *args)

    def getTriArea(self, *args):
        """
        Returns the area (in m^2) of the triangular element with index idx.

        Syntax::
            
            getTriArea(idx)
            
        Arguments:
            * uint idx

        Return:
            float

        """
        return _steps_swig.API_getTriArea(self, *args)

    def getTriSpecDefined(self, *args):
        """
        Returns whether species with identifier string spec is defined
        in the triangle element with index idx.

        Syntax::
            
            getTriSpecDefined(idx, spec)
            
        Arguments:
            * uint idx
            * string spec

        Return:
            bool

        """
        return _steps_swig.API_getTriSpecDefined(self, *args)

    def getTriCount(self, *args):
        """
        Returns the number of molecules of species with identifier string spec 
        in the triangular element with index idx.

        Syntax::
            
            getTriCount(idx, spec)
            
        Arguments:
            * uint idx
            * string spec

        Return:
            float

        """
        return _steps_swig.API_getTriCount(self, *args)

    def setTriCount(self, *args):
        """
        Sets the number of molecules of species with identifier string spec in 
        triangular element with index idx to n. 

        Syntax::
            
            setTriCount(idx, spec, n)
            
        Arguments:
            * uint idx
            * string spec
            * uint n

        Return:
            None

        """
        return _steps_swig.API_setTriCount(self, *args)

    def getTriAmount(self, *args):
        """
        Returns the amount (in mols) of species with identifier string spec in triangular 
        element with index idx.  

        Syntax::
            
            getTriAmount(idx, spec)
            
        Arguments:
            * uint idx
            * string spec

        Return:
            float

        """
        return _steps_swig.API_getTriAmount(self, *args)

    def setTriAmount(self, *args):
        """
        Sets the amount (in mols) of species with identifier string spec in triangular 
        element with index idx to a. This continuous value must be converted internally 
        to a discrete number of molecules by multiplication with Avogadro's number. 

        Syntax::
            
            setTriAmount(idx, spec, a)
            
        Arguments:
            * uint idx
            * string spec
            * float a

        Return:
            None

        """
        return _steps_swig.API_setTriAmount(self, *args)

    def getTriClamped(self, *args):
        """
        Returns True if the species with identifier string spec in triangular element 
        with index idx is clamped, which means the number of molecules stays 
        the same regardless of reactions that consume or produce molecules of this species. 
        Returns False if not.

        Syntax::
            
            getTriClamped(idx, spec)
            
        Arguments:
            * uint idx
            * string spec

        Return:
            bool

        """
        return _steps_swig.API_getTriClamped(self, *args)

    def setTriClamped(self, *args):
        """
        Sets whether the concentration of species spec in triangular element with index idx 
        is clamped (clamped = True) or not (clamped = False). If a species is clamped the 
        concentration stays the same regardless of reactions that consume or produce 
        molecules of the species. 

        Syntax::
            
            setTriClamped(idx, spec, clamped)
            
        Arguments:
            * uint idx
            * string spec
            * bool clamped

        Return:
            None

        """
        return _steps_swig.API_setTriClamped(self, *args)

    def getTriSReacK(self, *args):
        """
        Returns the macroscopic reaction constant of surface reaction with identifier 
        string sreac in triangular element with index idx. The units of the reaction 
        constant depends on the order of the reaction. 

        Syntax::
            
            getTriSReacK(idx, reac)
            
        Arguments:
            * uint idx
            * string reac

        Return:
            float

        """
        return _steps_swig.API_getTriSReacK(self, *args)

    def setTriSReacK(self, *args):
        """
        Sets the macroscopic reaction constant of surface reaction with identifier 
        string sreac in triangular element with index idx to kf. The units of the 
        reaction constant depends on the order of the reaction.

        Syntax::
            
            setTriSReacK(idx, reac, kf)
            
        Arguments:
            * uint idx
            * string reac
            * float kf

        Return:
            None

        """
        return _steps_swig.API_setTriSReacK(self, *args)

    def getTriSReacActive(self, *args):
        """
        Returns whether surface reaction with identifier string sreac in triangular 
        element with index idx is active (True) or not (False). If it's not active 
        this means that the surface reaction will never occur regardless of whether 
        reactants are present in sufficient numbers or not. 

        Syntax::
            
            getTriSReacActive(idx, reac)
            
        Arguments:
            * uint idx
            * string reac

        Return:
            bool

        """
        return _steps_swig.API_getTriSReacActive(self, *args)

    def setTriSReacActive(self, *args):
        """
        Activate (active = True) or deactivate (active = False) a surface reaction 
        with identifier string sreac in triangular element with index idx. If it's 
        not active this means that the surface reaction will never occur regardless 
        of whether reactants are present in sufficient numbers or not.  

        Syntax::
            
            setTriSReacActive(idx, reac, active)
            
        Arguments:
            * uint idx
            * string reac
            * active

        Return:
            None

        """
        return _steps_swig.API_setTriSReacActive(self, *args)

    def getTriSReacC(self, *args):
        """
        Returns the 'stochastic reaction constant' (or 'specific probability rate constant') 
        of surface reaction with identifier string sreac in triangular element with index idx.  

        Syntax::
            
            getTriSReacC(idx, reac)
            
        Arguments:
            * uint idx
            * string reac

        Return:
           float

        """
        return _steps_swig.API_getTriSReacC(self, *args)

    def getTriSReacH(self, *args):
        """
        Returns h_mu, the distinct number of ways in which surface reaction with identifier 
        string sreac can occur in triangular element with index idx, by computing the product 
        of its reactants. 

        Syntax::
            
            getTriSReacH(idx, reac)
            
        Arguments:
            * uint idx
            * string reac

        Return:
           float

        """
        return _steps_swig.API_getTriSReacH(self, *args)

    def getTriSReacA(self, *args):
        """
        Returns the propensity of surface reaction with identifier string sreac 
        in triangular element with index idx. 

        Syntax::
            
            getTriSReacA(idx, reac)
            
        Arguments:
            * uint idx
            * string reac

        Return:
           float

        """
        return _steps_swig.API_getTriSReacA(self, *args)

    def getTriV(self, *args):
        """
        Returns the potential (in volts) of triangle element with index idx, taken at the barycenter.
        			
        Syntax::
        			 
        	getTriV(idx)
        			 
        Arguments:
        	* uint idx
        		
        Returns:
        	float

        """
        return _steps_swig.API_getTriV(self, *args)

    def setTriV(self, *args):
        """
        Set the potential (in volts) of triangle element with index idx.
        			
        Syntax::
        			 
        	setTriV(idx, v)
        			 
        Arguments:
        	* uint idx
        	* float v
        			 
        Returns:
        	None

        """
        return _steps_swig.API_setTriV(self, *args)

    def getTriVClamped(self, *args):
        """
        Returns true if the potential of triangle element with index idx is clamped
        to some voltage.
        			
        Syntax::
        			 
        	getTriVClamped(idx)
        			 
        Arguments:
        	* uint idx
        		
        Returns:
        	bool

        """
        return _steps_swig.API_getTriVClamped(self, *args)

    def setTriVClamped(self, *args):
        """
        Sets whether the potential of triangle element with index idx is clamped
        (clamped = True) or not (clamped = False).
        			
        Syntax::
        			 
        	setTriVClamped(idx, clamped)
        			 
        Arguments:
        	* uint idx
        	* bool clamped
        			 
        Returns:
        	None

        """
        return _steps_swig.API_setTriVClamped(self, *args)

    def getTriOhmicI(self, *args):
        """
        Returns the ohmic current of triangle element with index idx, in amps.
        			
        Syntax::
        			 
        	getTriOhmicI(idx)
        			 
        Arguments:
        	* uint idx
        		
        Returns:
        	float

         
        Returns the ohmic current with identifier string oc of triangle element with index idx, in amps.
                     
        Syntax::
        			 
            getTriOhmicI(idx, oc)
        			 
        Arguments:
            * uint idx
            * string oc

        Returns:
            float

        """
        return _steps_swig.API_getTriOhmicI(self, *args)

    def getTriGHKI(self, *args):
        """
        Returns the GHK current of triangle element with index idx, in amps.
                     
        Syntax::
        			 
            getTriGHKI(idx)
        			 
        Arguments:
            * uint idx
                     
        Returns:
            float

         
            Returns the ghk current with identifier string ghk of triangle element with index idx, in amps.
                     
        Syntax::
        			 
            getTriGHKI(idx, ghk)
        			 
        Arguments:
            * uint idx
            * string ghk
                     
        Returns:
            float

        """
        return _steps_swig.API_getTriGHKI(self, *args)

    def getTriI(self, *args):
        """
        Returns the current of triangle element with index idx, in amps, 
        at the last EField calculation step.
        			 
        Syntax::
        			 
            getTriI(idx)
        			 
        Arguments:
            * uint idx
        			 
        Returns:
            float

        """
        return _steps_swig.API_getTriI(self, *args)

    def setTriIClamp(self, *args):
        """
        Set current clamp to triangle element with index idx to current i (amps).
        NOTE: Convention is maintained that a positive current clamp is depolarizing, a negative current clamp is hyperpolarizing.
        			
        Syntax::
        			 
        	setTriIClamp(idx, i)
        			 
        Arguments:
        	* uint idx
        	* float i
        			 
        Returns:
        	None

        """
        return _steps_swig.API_setTriIClamp(self, *args)

    def getTriVDepSReacActive(self, *args):
        """
        Returns whether voltage-dependent surface reaction with identifier string vsreac in triangular 
        element with index idx is active (True) or not (False). If it's not active 
        this means that the voltage-dependent surface reaction will never occur regardless of whether 
        reactants are present in sufficient numbers or not. 

        Syntax::

            getTriVDepSReacActive(idx, reac)

        Arguments:
            * uint idx
            * string vsreac

        Return:
            bool

        """
        return _steps_swig.API_getTriVDepSReacActive(self, *args)

    def setTriVDepSReacActive(self, *args):
        """
        Activate (active = True) or deactivate (active = False) a voltage-dependent surface reaction 
        with identifier string vsreac in triangular element with index idx. If it's 
        not active this means that the voltage-dependent surface reaction will never occur regardless 
        of whether reactants are present in sufficient numbers or not.  

        Syntax::

            setTriVDepSReacActive(idx, vsreac, active)

        Arguments:
            * uint idx
            * string vsreac
            * active

        Return:
            None

        """
        return _steps_swig.API_setTriVDepSReacActive(self, *args)

    def getVertV(self, *args):
        """
        Returns the potential (in volts) of vertex element with index idx.
        			
        Syntax::
        			 
        	getVertV(idx)
        			 
        Arguments:
        	* uint idx
        		
        Returns:
        	float

        """
        return _steps_swig.API_getVertV(self, *args)

    def setVertV(self, *args):
        """
        Set the potential (in volts) of vertex element with index idx.
        			
        Syntax::
        			 
        	setVertV(idx, v)
        			 
        Arguments:
        	* uint idx
        	* float v
        			 
        Returns:
        	None

        """
        return _steps_swig.API_setVertV(self, *args)

    def getVertVClamped(self, *args):
        """
        Returns true if the potential of vertex element with index idx is clamped
        to some voltage.
        			
        Syntax::
        			 
        	getVertVClamped(idx)
        			 
        Arguments:
        	* uint idx
        		
        Returns:
        	bool

        """
        return _steps_swig.API_getVertVClamped(self, *args)

    def setVertVClamped(self, *args):
        """
        Sets whether the potential of vertex element with index idx is clamped
        (clamped = True) or not (clamped = False).
        			
        Syntax::
        			 
        	setVertVClamped(idx, clamped)
        			 
        Arguments:
        	* uint idx
        	* bool clamped
        			 
        Returns:
        	None

        """
        return _steps_swig.API_setVertVClamped(self, *args)

    def setVertIClamp(self, *args):
        """
        Set current clamp to vertex element with index idx to current i (Amps). 
        NOTE: Convention is maintained that a positive current clamp is depolarizing, a negative current clamp is hyperpolarizing.

        Syntax::

            setVertIClamp(idx, i)
        			 
        Arguments:
            * uint idx
            * float i
        			 
        Returns:
            None

        """
        return _steps_swig.API_setVertIClamp(self, *args)

    def setMembPotential(self, *args):
        """
        Sets the potential (in volts) of membrane with string identifier memb.
        NOTE: This method will set the potential of all nodes in the volume conductor
        to the same value.

        Syntax::
        			
        	setMembPotential(memb, v)
        		
        Arguments:
        	* string memb
        	* double v

        Returns:
        	None

        """
        return _steps_swig.API_setMembPotential(self, *args)

    def setMembCapac(self, *args):
        """
        Sets the specific membrane capacitance (in farad / m^2) of membrane with string identifier memb.
        			 
        Syntax::
        			 
            setMembCapac(memb, cm)
        			 
        Arguments:
            * string memb
            * double cm
        			 
        Returns:
            None

        """
        return _steps_swig.API_setMembCapac(self, *args)

    def setMembVolRes(self, *args):
        """
        Sets the bulk electrical resistivity (in ohm.m) of the volume conductor 
        assocaited with membrane with string identifier memb.
        			 
        Syntax::
        			 
            setMembVolRes(memb, ro)
        			 
        Arguments:
            * string memb
            * double ro
        			 
        Returns:
            None

        """
        return _steps_swig.API_setMembVolRes(self, *args)

    def setMembRes(self, *args):
        """
        Sets the  electrical resistivity (in ohm/m^2) of the membrane with string identifier memb. Reversal potential vrev is required in Volts.
        			 
        Syntax::
        			 
            setMembRes(memb, ro, vrev)
        			 
        Arguments:
            * string memb
            * double ro
            * double vrev
        			 
        Returns:
            None

        """
        return _steps_swig.API_setMembRes(self, *args)

    def getNComps(self):
        """
        Return the number of compartments in the solver.

        Syntax::

            getNComps()

        Arguments:
            None

        Returns:
            integer

        """
        return _steps_swig.API_getNComps(self)

    def getNPatches(self):
        """
        Return the number of patches in the solver.

        Syntax::

            getNPatches()

        Arguments:
            None

        Returns:
            integer

        """
        return _steps_swig.API_getNPatches(self)

    def getCompName(self, *args):
        """
        Return the name of a compartment by its index in the solver.
            
        Syntax::
            
            getCompName(c_idx)
            
        Arguments:
            * integer c_idx
            
        Returns:
            string

        """
        return _steps_swig.API_getCompName(self, *args)

    def getPatchName(self, *args):
        """
        Return the name of a patch by its index in the solver.

        Syntax::

            getPatchName(p_idx)

        Arguments:
            * integer p_idx

        Returns:
            string

        """
        return _steps_swig.API_getPatchName(self, *args)

    def getNCompSpecs(self, *args):
        """
        Get number of species in a compartment.

        Syntax::

            getNCompSpecs(c_idx)

        Arguments:
            * integer c_idx

        Returns:
            integer

        """
        return _steps_swig.API_getNCompSpecs(self, *args)

    def getNPatchSpecs(self, *args):
        """
        Get number of species in a patch.

        Syntax::

            getNPatchSpecs(p_idx)

        Arguments:
            * integer p_idx

        Returns:
            integer

        """
        return _steps_swig.API_getNPatchSpecs(self, *args)

    def getCompSpecName(self, *args):
        """
        Get the name of a species in a compartment.

        Syntax::

            getCompSpecName(c_idx, s_idx)

        Arguments:
            * integer c_idx
            * integer s_idx

        Returns:
            string

        """
        return _steps_swig.API_getCompSpecName(self, *args)

    def getPatchSpecName(self, *args):
        """
        Get the name of a species in a patch.

        Syntax::

            getPatchSpecName(p_idx, s_idx)

        Arguments:
            * integer p_idx
            * integer s_idx

        Returns:
            string

        """
        return _steps_swig.API_getPatchSpecName(self, *args)

    def getBatchTetCounts(self, *args):
        """
        Get the counts of a species s in a list of tetrahedrons.

        Syntax::

            getBatchTetCounts(tets, s)

        Arguments:
            * list<uint> tets
            * string s

        Return:
            list<double>

        """
        return _steps_swig.API_getBatchTetCounts(self, *args)

    def getBatchTriCounts(self, *args):
        """
        Get the counts of a species s in a list of triangles.

        Syntax::

            getBatchTriCounts(tris, s)

        Arguments:
            * list<uint> tris
            * string s

        Return:
            list<double>

        """
        return _steps_swig.API_getBatchTriCounts(self, *args)

    def getBatchTetCountsNP(self, *args):
        """
        Get the counts of a species s in a list of tetrahedrons.

        Syntax::
            getBatchTetCountsNP(indices, s, counts)

        Arguments:
            * numpy.array<uint> indices
            * string s
            * numpy.array<double, lengh = len(indices)>

        Return:
            None

        """
        return _steps_swig.API_getBatchTetCountsNP(self, *args)

    def getBatchTriCountsNP(self, *args):
        """
        Get the counts of a species s in a list of triangles.

        Syntax::
            getBatchTriCountsNP(indices, s, counts)

        Arguments:
            * numpy.array<uint> indices
            * string s
            * numpy.array<double, lengh = len(indices)>

        Return:
            None

        """
        return _steps_swig.API_getBatchTriCountsNP(self, *args)

    def getROITetCounts(self, *args):
        """
        Get the counts of a species s in tetrehedrons of a ROI.

        Syntax::

            getROITetCounts(ROI_id, s)

        Arguments:
            * string ROI_id
            * string s

        Return:
            list<double>

        """
        return _steps_swig.API_getROITetCounts(self, *args)

    def getROITriCounts(self, *args):
        """
        Get the counts of a species s in triangles of a ROI.

        Syntax::

            getROITriCounts(ROI_id, s)

        Arguments:
            * string ROI_id
            * string s

        Return:
            list<double>

        """
        return _steps_swig.API_getROITriCounts(self, *args)

    def getROITetCountsNP(self, *args):
        """
        Get the counts of a species s in tetrehedrons of a ROI.

        Syntax::
            getROITetCountsNP(ROI_id, s, counts)

        Arguments:
            * string ROI_id
            * string s
            * numpy.array<double, lengh = len(indices)>

        Return:
            None

        """
        return _steps_swig.API_getROITetCountsNP(self, *args)

    def getROITriCountsNP(self, *args):
        """
        Get the counts of a species s in triangles of a ROI.

        Syntax::
            getROITriCountsNP(ROI_id, s, counts)

        Arguments:
            * string ROI_id
            * string s
            * numpy.array<double, lengh = len(indices)>

        Return:
            None

        """
        return _steps_swig.API_getROITriCountsNP(self, *args)

    def getROIVol(self, *args):
        """
        Get the volume of a ROI.

        Syntax::
            getROIVol(ROI_id)

        Arguments:
            * string ROI_id

        Return:
            double

        """
        return _steps_swig.API_getROIVol(self, *args)

    def getROIArea(self, *args):
        """
        Get the area of a ROI.

        Syntax::
            getROIArea(ROI_id)

        Arguments:
            * string ROI_id

        Return:
            double

        """
        return _steps_swig.API_getROIArea(self, *args)

    def getROICount(self, *args):
        """
        Get the count of a species in a ROI.

        Syntax::
            getROICount(ROI_id, s)

        Arguments:
            * string ROI_id
            * string s

        Return:
            double

        """
        return _steps_swig.API_getROICount(self, *args)

    def setROICount(self, *args):
        """
        Set the count of a species in a ROI.

        Syntax::
            setROICount(ROI_id, s, count)

        Arguments:
            * string ROI_id
            * string s
            * double count

        Return:
            None

        """
        return _steps_swig.API_setROICount(self, *args)

    def getROIAmount(self, *args):
        """
        Get the amount of a species in a ROI.

        Syntax::
            getROIAmount(ROI_id, s, count)

        Arguments:
            * string ROI_id
            * string s

        Return:
            double

        """
        return _steps_swig.API_getROIAmount(self, *args)

    def getROIConc(self, *args):
        """
        Get the concentration of a species in a ROI.

        Syntax::
            getROIConc(ROI_id, s, count)

        Arguments:
            * string ROI_id
            * string s

        Return:
            double

        """
        return _steps_swig.API_getROIConc(self, *args)

    def setROIClamped(self, *args):
        """
        Set a species in a ROI to be clamped or not. The count of species s in the ROI is clamped if
        b is True, not clamped if b is False.

        Syntax::
            setROIClamped(ROI_id, s, b)

        Arguments:
            * string ROI_id
            * string s
            * boolean b

        Return:
            None

        """
        return _steps_swig.API_setROIClamped(self, *args)

    def setROIReacK(self, *args):
        """
        Sets the macroscopic reaction constant of reaction with identifier string r
        in a ROI with identifier string ROI_id to kf. The unit of the reaction constant
        depends on the order of the reaction.

        Note: The default value still comes from the steps.model description, so 
        calling reset() will return the reaction constant to that value.

        Syntax::
            setROIReacK(ROI_id, r, kf)

        Arguments:
            * string ROI_id
            * string r
            * double kf

        Return:
            None

        """
        return _steps_swig.API_setROIReacK(self, *args)

    def setROISReacK(self, *args):
        """
        Sets the macroscopic reaction constant of surface reaction with identifier string sr
        in a ROI with identifier string ROI_id to kf. The unit of the reaction constant
        depends on the order of the reaction.

        Note: The default value still comes from the steps.model description, so 
        calling reset() will return the reaction constant to that value.

        Syntax::
            setROISReacK(ROI_id, sr, kf)

        Arguments:
            * string ROI_id
            * string sr
            * double kf

        Return:
            None

        """
        return _steps_swig.API_setROISReacK(self, *args)

    def setROIDiffD(self, *args):
        """
        Sets the macroscopic diffusion constant of diffusion with identifier string d
        in a ROI with identifier string ROI_id to dk.

        Note: The default value still comes from the steps.model description, so 
        calling reset() will return the diffusion constant to that value.

        Syntax::
            setROIDiffD(ROI_id, d, dk)

        Arguments:
            * string ROI_id
            * string d
            * double dk

        Return:
            None

        """
        return _steps_swig.API_setROIDiffD(self, *args)

    def setROIReacActive(self, *args):
        """
        Set reaction r in a ROI to be active or not.

        Syntax::
            setROIReacActive(ROI_id, r, a)

        Arguments:
            * string ROI_id
            * string r
            * bool a

        Return:
            None

        """
        return _steps_swig.API_setROIReacActive(self, *args)

    def setROISReacActive(self, *args):
        """
        Set surface reaction sr in a ROI to be active or not.

        Syntax::
            setROISReacActive(ROI_id, sr, a)

        Arguments:
            * string ROI_id
            * string sr
            * bool a

        Return:
            None

        """
        return _steps_swig.API_setROISReacActive(self, *args)

    def setROIDiffActive(self, *args):
        """
        Set diffusion d in a ROI to be active or not.

        Syntax::
            setROIDiffActive(ROI_id, sr, a)

        Arguments:
            * string ROI_id
            * string sr
            * bool a

        Return:
            None

        """
        return _steps_swig.API_setROIDiffActive(self, *args)

    def setROIVDepSReacActive(self, *args):
        """
        Set voltage dependent surface reaction vsr in a ROI to be active or not.

        Syntax::
            setROIVDepSReacActive(ROI_id, vsr, a)

        Arguments:
            * string ROI_id
            * string vsr
            * bool a

        Return:
            None

        """
        return _steps_swig.API_setROIVDepSReacActive(self, *args)

    def getROIReacExtent(self, *args):
        """
        Return the extent of reaction with identifier string r in ROI with
        identifier string ROI_id, that is the number of times the reaction has occurred up
        to the current simulation time.

        Syntax::
            getROIReacExtent(ROI_id, r)

        Arguments:
            * string ROI_id
            * string r

        Return:
            uint

        """
        return _steps_swig.API_getROIReacExtent(self, *args)

    def resetROIReacExtent(self, *args):
        """
        Reset the extent of reaction with identifier string r in ROI with
        identifier string ROI_id, that is the number of times the reaction has occurred up
        to the current simulation time, to 0.

        Syntax::
            resetROIReacExtent(ROI_id, r)

        Arguments:
            * string ROI_id
            * string r

        Return:
            None

        """
        return _steps_swig.API_resetROIReacExtent(self, *args)

    def getROISReacExtent(self, *args):
        """
        Return the extent of surface reaction with identifier string sr in ROI with
        identifier string ROI_id, that is the number of times the reaction has occurred up
        to the current simulation time.

        Syntax::
            getROISReacExtent(ROI_id, sr)

        Arguments:
            * string ROI_id
            * string sr

        Return:
            uint

        """
        return _steps_swig.API_getROISReacExtent(self, *args)

    def resetROISReacExtent(self, *args):
        """
        Reset the extent of surface reaction with identifier string r in ROI with
        identifier string ROI_id, that is the number of times the reaction has occurred up
        to the current simulation time, to 0.

        Syntax::
            resetROISReacExtent(ROI_id, r)

        Arguments:
            * string ROI_id
            * string sr

        Return:
            None

        """
        return _steps_swig.API_resetROISReacExtent(self, *args)

    def getROIDiffExtent(self, *args):
        """
        Return the extent of diffusion with identifier string d in ROI with
        identifier string ROI_id, that is the number of times the diffusion has occurred up
        to the current simulation time.

        Syntax::
            getROIDiffExtent(ROI_id, d)

        Arguments:
            * string ROI_id
            * string d

        Return:
            uint

        """
        return _steps_swig.API_getROIDiffExtent(self, *args)

    def resetROIDiffExtent(self, *args):
        """
        Reset the extent of diffusion with identifier string d in ROI with
        identifier string ROI_id, that is the number of times the diffusion has occurred up
        to the current simulation time, to 0.

        Syntax::
            resetROIDiffExtent(ROI_id, d)

        Arguments:
            * string ROI_id
            * string d

        Return:
            None

        """
        return _steps_swig.API_resetROIDiffExtent(self, *args)

API_swigregister = _steps_swig.API_swigregister
API_swigregister(API)

class Wmrk4(API):
    """Proxy of C++ steps::wmrk4::Wmrk4 class"""
    __swig_setmethods__ = {}
    for _s in [API]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Wmrk4, name, value)
    __swig_getmethods__ = {}
    for _s in [API]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Wmrk4, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(steps::wmrk4::Wmrk4 self, Model m, Geom g, RNG r) -> Wmrk4"""
        this = _steps_swig.new_Wmrk4(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_Wmrk4
    __del__ = lambda self : None;
    def getSolverName(self):
        """
        Returns a string of the solver's name.

        Syntax::
            
            getSolverName()
            
        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.Wmrk4_getSolverName(self)

    def getSolverDesc(self):
        """
        Returns a string giving a short description of the solver.

        Syntax::
            
            getSolverDesc()
            
        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.Wmrk4_getSolverDesc(self)

    def getSolverAuthors(self):
        """
        Returns a string of the solver authors names.

        Syntax::
            
            getSolverAuthors()
            
        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.Wmrk4_getSolverAuthors(self)

    def getSolverEmail(self):
        """
        Returns a string giving the author's email address.

        Syntax::
            
            getSolverEmail()
            
        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.Wmrk4_getSolverEmail(self)

    def checkpoint(self, *args):
        """
        Checkpoint data to a file.
            
        Syntax::
            
            checkpoint(file_name)
            
        Arguments:
            string file_name
            
        Return:
            None

        """
        return _steps_swig.Wmrk4_checkpoint(self, *args)

    def restore(self, *args):
        """
        Restore data from a file.
            
        Syntax::
            
            restore(file_name)
            
        Arguments:
            string file_name
            
        Return:
            None

        """
        return _steps_swig.Wmrk4_restore(self, *args)

    def reset(self):
        """
        Reset the simulation to the state the solver was initialised to. 
        Typically, this resets all concentrations of all chemical species in 
        all elements (whether compartments and patches in a well-mixed solver 
        or tetrahedrons and triangles in a mesh-based solver) to zero, 
        resets the simulation time to zero and resets reaction (and diffusion) 
        rates to the default values described in the steps.model objects. 
        All reaction (and diffusion) rules are reset to active and all 
        compartment volumes and patch areas are reset to default values 
        described in steps.geom objects (for well-mixed solvers). 
        Usually, this method should be called before starting each simulation iteration.

        Syntax::
            
            reset()
            
        Arguments:
            None

        Return:
            None

        """
        return _steps_swig.Wmrk4_reset(self)

    def run(self, *args):
        """
        Advance the simulation until endtime (given in seconds) is reached. 
        The endtime must be larger or equal to the current simulation time.

        Syntax::
            
            run(endtime)
            
        Arguments:
            float endtime

        Return:
            None

        """
        return _steps_swig.Wmrk4_run(self, *args)

    def getTime(self):
        """
        Returns the current simulation time in seconds.

        Syntax::
            
            getTime()
            
        Arguments:
            None

        Return:
            float

        """
        return _steps_swig.Wmrk4_getTime(self)

Wmrk4_swigregister = _steps_swig.Wmrk4_swigregister
Wmrk4_swigregister(Wmrk4)

class Wmdirect(API):
    """Proxy of C++ steps::wmdirect::Wmdirect class"""
    __swig_setmethods__ = {}
    for _s in [API]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Wmdirect, name, value)
    __swig_getmethods__ = {}
    for _s in [API]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Wmdirect, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(steps::wmdirect::Wmdirect self, Model m, Geom g, RNG r) -> Wmdirect"""
        this = _steps_swig.new_Wmdirect(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_Wmdirect
    __del__ = lambda self : None;
    def getSolverName(self):
        """
        Returns a string of the solver's name.

        Syntax::
            
            getSolverName()
            
        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.Wmdirect_getSolverName(self)

    def getSolverDesc(self):
        """
        Returns a string giving a short description of the solver.

        Syntax::
            
            getSolverDesc()
            
        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.Wmdirect_getSolverDesc(self)

    def getSolverAuthors(self):
        """
        Returns a string of the solver authors names.

        Syntax::
            
            getSolverAuthors()
            
        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.Wmdirect_getSolverAuthors(self)

    def getSolverEmail(self):
        """
        Returns a string giving the author's email address.

        Syntax::
            
            getSolverEmail()
            
        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.Wmdirect_getSolverEmail(self)

    def checkpoint(self, *args):
        """
        Checkpoint data to a file.

        Syntax::

        checkpoint(file_name)

        Arguments:
        string file_name

        Return:
        None

        """
        return _steps_swig.Wmdirect_checkpoint(self, *args)

    def restore(self, *args):
        """
        Restore data from a file.
            
        Syntax::
            
            restore(file_name)
            
        Arguments:
            string file_name
            
        Return:
            None

        """
        return _steps_swig.Wmdirect_restore(self, *args)

    def reset(self):
        """
        Reset the simulation to the state the solver was initialised to. 
        Typically, this resets all concentrations of all chemical species in 
        all elements (whether compartments and patches in a well-mixed solver 
        or tetrahedrons and triangles in a mesh-based solver) to zero, 
        resets the simulation time to zero and resets reaction (and diffusion) 
        rates to the default values described in the steps.model objects. 
        All reaction (and diffusion) rules are reset to active and all 
        compartment volumes and patch areas are reset to default values 
        described in steps.geom objects (for well-mixed solvers). 
        Usually, this method should be called before starting each simulation iteration.

        Syntax::
            
            reset()
            
        Arguments:
            None

        Return:
            None

        """
        return _steps_swig.Wmdirect_reset(self)

    def run(self, *args):
        """
        Advance the simulation until endtime (given in seconds) is reached. 
        The endtime must be larger or equal to the current simulation time.

        Syntax::
            
            run(endtime)
            
        Arguments:
            float endtime

        Return:
            None

        """
        return _steps_swig.Wmdirect_run(self, *args)

    def getTime(self):
        """
        Returns the current simulation time in seconds.

        Syntax::
            
            getTime()
            
        Arguments:
            None

        Return:
            float

        """
        return _steps_swig.Wmdirect_getTime(self)

Wmdirect_swigregister = _steps_swig.Wmdirect_swigregister
Wmdirect_swigregister(Wmdirect)

class Tetexact(API):
    """Proxy of C++ steps::tetexact::Tetexact class"""
    __swig_setmethods__ = {}
    for _s in [API]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Tetexact, name, value)
    __swig_getmethods__ = {}
    for _s in [API]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Tetexact, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(steps::tetexact::Tetexact self, Model m, Geom g, RNG r, bool calcMembPot=False, vector_uint tet_hosts=std::vector< uint >()) -> Tetexact
        __init__(steps::tetexact::Tetexact self, Model m, Geom g, RNG r, bool calcMembPot=False) -> Tetexact
        __init__(steps::tetexact::Tetexact self, Model m, Geom g, RNG r) -> Tetexact
        """
        this = _steps_swig.new_Tetexact(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_Tetexact
    __del__ = lambda self : None;
    def getSolverName(self):
        """
        Returns a string of the solver's name.

        Syntax::
            
            getSolverName()
            
        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.Tetexact_getSolverName(self)

    def getSolverDesc(self):
        """
        Returns a string giving a short description of the solver.

        Syntax::
            
            getSolverDesc()
            
        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.Tetexact_getSolverDesc(self)

    def getSolverAuthors(self):
        """
        Returns a string of the solver authors names.

        Syntax::
            
            getSolverAuthors()
            
        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.Tetexact_getSolverAuthors(self)

    def getSolverEmail(self):
        """
        Returns a string giving the author's email address.

        Syntax::
            
            getSolverEmail()
            
        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.Tetexact_getSolverEmail(self)

    def checkpoint(self, *args):
        """
        Checkpoint data to a file.
            
        Syntax::
            
            checkpoint(file_name)
            
        Arguments:
            string file_name
            
        Return:
            None

        """
        return _steps_swig.Tetexact_checkpoint(self, *args)

    def restore(self, *args):
        """
        Restore data from a file.
            
        Syntax::
            
            restore(file_name)
            
        Arguments:
            string file_name
            
        Return:
            None

        """
        return _steps_swig.Tetexact_restore(self, *args)

    def reset(self):
        """
        Reset the simulation to the state the solver was initialised to. 
        Typically, this resets all concentrations of all chemical species in 
        all elements (whether compartments and patches in a well-mixed solver 
        or tetrahedrons and triangles in a mesh-based solver) to zero, 
        resets the simulation time to zero and resets reaction (and diffusion) 
        rates to the default values described in the steps.model objects. 
        All reaction (and diffusion) rules are reset to active and all 
        compartment volumes and patch areas are reset to default values 
        described in steps.geom objects (for well-mixed solvers). 
        Usually, this method should be called before starting each simulation iteration.

        Syntax::
            
            reset()
            
        Arguments:
            None

        Return:
            None

        """
        return _steps_swig.Tetexact_reset(self)

    def run(self, *args):
        """
        Advance the simulation until endtime (given in seconds) is reached. 
        The endtime must be larger or equal to the current simulation time.

        Syntax::
            
            run(endtime)
            
        Arguments:
            float endtime

        Return:
            None

        """
        return _steps_swig.Tetexact_run(self, *args)

    def getTime(self):
        """
        Returns the current simulation time in seconds.

        Syntax::
            
            getTime()
            
        Arguments:
            None

        Return:
            float

        """
        return _steps_swig.Tetexact_getTime(self)

    def saveMembOpt(self, *args):
        """
        Saves the vertex optimization in the Efield structure.
                     
        Syntax::
                     
            saveMembOpt()
                     
        Arguments:
            string filename
                     
        Return:
            None

        """
        return _steps_swig.Tetexact_saveMembOpt(self, *args)

    def getMyRank(self):
        """
        Return the rank of the process where the solver is.
                     
        Syntax::
                     
            getMyRank()
                     
        Arguments:
            None
                     
        Return:
            uint

        """
        return _steps_swig.Tetexact_getMyRank(self)

Tetexact_swigregister = _steps_swig.Tetexact_swigregister
Tetexact_swigregister(Tetexact)

class TetODE(API):
    """Proxy of C++ steps::tetode::TetODE class"""
    __swig_setmethods__ = {}
    for _s in [API]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TetODE, name, value)
    __swig_getmethods__ = {}
    for _s in [API]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TetODE, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        Reset the extent of diffusion with identifier string d in ROI with
        identifier string ROI_id, that is the number of times the diffusion has occurred up
        to the current simulation time, to 0.

        Syntax::
            resetROIDiffExtent(ROI_id, d)

        Arguments:
            * string ROI_id
            * string d

        Return:
            None


        Reset the extent of diffusion with identifier string d in ROI with
        identifier string ROI_id, that is the number of times the diffusion has occurred up
        to the current simulation time, to 0.

        Syntax::
            resetROIDiffExtent(ROI_id, d)

        Arguments:
            * string ROI_id
            * string d

        Return:
            None

        """
        this = _steps_swig.new_TetODE(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _steps_swig.delete_TetODE
    __del__ = lambda self : None;
    def getSolverName(self):
        """
        Returns a string of the solver's name.

        Syntax::

            getSolverName()

        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.TetODE_getSolverName(self)

    def getSolverDesc(self):
        """
        Returns a string giving a short description of the solver.

        Syntax::

            getSolverDesc()

        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.TetODE_getSolverDesc(self)

    def getSolverAuthors(self):
        """
        Returns a string of the solver authors names.

        Syntax::

            getSolverAuthors()

        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.TetODE_getSolverAuthors(self)

    def getSolverEmail(self):
        """
        Returns a string giving the author's email address.

        Syntax::

            getSolverEmail()

        Arguments:
            None

        Return:
            string

        """
        return _steps_swig.TetODE_getSolverEmail(self)

    def checkpoint(self, *args):
        """
        Checkpoint data to a file.

        Syntax::

            checkpoint(file_name)

        Arguments:
            string file_name

        Return:
            None

        """
        return _steps_swig.TetODE_checkpoint(self, *args)

    def restore(self, *args):
        """
        Restore data from a file.

        Syntax::

            restore(file_name)

        Arguments:
            string file_name

        Return:
            None

        """
        return _steps_swig.TetODE_restore(self, *args)

    def reset(self):
        """
        Reset the simulation to the state the solver was initialised to. 
        Typically, this resets all concentrations of all chemical species in 
        all elements (whether compartments and patches in a well-mixed solver 
        or tetrahedrons and triangles in a mesh-based solver) to zero, 
        resets the simulation time to zero and resets reaction (and diffusion) 
        rates to the default values described in the steps.model objects. 
        All reaction (and diffusion) rules are reset to active and all 
        compartment volumes and patch areas are reset to default values 
        described in steps.geom objects (for well-mixed solvers). 
        Usually, this method should be called before starting each simulation iteration.

        Syntax::

            reset()

        Arguments:
            None

        Return:
            None

        """
        return _steps_swig.TetODE_reset(self)

    def run(self, *args):
        """
        Advance the simulation until endtime (given in seconds) is reached. 
        The endtime must be larger or equal to the current simulation time.

        Syntax::

            run(endtime)

        Arguments:
            float endtime

        Return:
            None

        """
        return _steps_swig.TetODE_run(self, *args)

    def getTime(self):
        """
        Returns the current simulation time in seconds.

        Syntax::

            getTime()

        Arguments:
            None

        Return:
            float

        """
        return _steps_swig.TetODE_getTime(self)

    def setMaxNumSteps(self, *args):
        """
        Sets the maximum number of steps in CVODE per call to run().
        Default is 10000 if this function is not called.
                     
        Syntax::
                     
            setMaxNumSteps()
                     
        Arguments:
            unsigned integer maxn
                     
        Return:
            None

        """
        return _steps_swig.TetODE_setMaxNumSteps(self, *args)

    def setTolerances(self, *args):
        """
        Set the absolute tolerance and the relative tolerance for CVODE.
                     
        Syntax::
                     
            setTolerance(atol, rtol)
                     
        Arguments:
            float atol
            float rtol
                     
        Return:
            None

        """
        return _steps_swig.TetODE_setTolerances(self, *args)

TetODE_swigregister = _steps_swig.TetODE_swigregister
TetODE_swigregister(TetODE)


def init():
  """init()"""
  return _steps_swig.init()

def getRank():
  """getRank() -> int"""
  return _steps_swig.getRank()

def getNHosts():
  """getNHosts() -> int"""
  return _steps_swig.getNHosts()

def finish():
  """finish()"""
  return _steps_swig.finish()
# This file is compatible with both classic and new-style classes.


