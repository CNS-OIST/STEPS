# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# STEPS - STochastic Engine for Pathway Simulation
# Copyright (C) 2005-2007 Stefan Wils. All rights reserved.
#
# This file is part of STEPS.
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
# 
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301, USA
#
# $Id: tetgen.py 
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #


"""Support for TetGen, a freely available tetrahedral mesh generator.
Currently, the module only offers support for reading TetGen files 
generated by calling TetGen from the command line.
"""


import numpy
import os.path as opath
import steps_0_5_0.geom as stetmesh					

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #


def read(pathroot, compmap = None, patchmap = None, patchiomap = None):
    """Read a TetGen-generated or refined mesh from a set of files.
    
    The TetGen file format for describing a mesh actually consists of 
    multiple files with varying suffixes. Currently, this routine only
    reads meshes consisting of three files:
    
        1/ <input>.node: describing the tetrahedral mesh node points.
        2/ <input>.ele: describing tetrahedral elements, each of which
           consists of 4 pointers into the <input>.node file. (TetGen
           also supports 10-node elements; these 6 extra nodes are obviously 
           not read by STEPS.) 
        3/ <input>.face: describing triangular faces, each of which 
           consists of 3 pointers into the <input>.node file. This file
           is optional.
    
    Other files are .vol (list of maximum volumes), .var (variant constraints)
    .neigh (list of neighbours), .smesh (simple PLC descriptions) and .edge
    (list of boundary edges) files. None of these seem relevant for our
    use cases, so we don't load them even when they are there. In particular,
    the .neigh file is computed by STEPS itself.
    
    Please refer to the TetGen manual (pages 31-40 in the last edition)
    for more information on these file formats:
    
        tetgen.berlios.de/files/tetgen-manual.pdf
    
    INDEXING
    
    Within STEPS, indexing of nodes and elements must start from 
    zero, whereas numbering in TetGen can optionally start from 1. This is 
    detected from the .node file and followed consequently in the .ele and
    .face files. If the indices start from 1, they are transformed by
    subtracting 1 from them while reading. 
    
    COMPARTMENT/PATCH ANNOTATION
    
    TetGen files record the volume and surface materials of tetrahedral and 
    triangular elements by marking them with integer numbers. In TetGen 
    terminology, compartments are called 'region attributes' and patches are 
    called 'boundary markers'. If region attributes or boundary markers
    are present in the .ele or .face file respectively, these are returned
    by the function (see section RETURNS).
    
    Annotation (= the task of assigning groups of tetrahedrons and triangles 
    to Comp and Patch objects, respectively) of the mesh can also be done 
    automatically by this function, if the caller provides dictionaries that 
    map integers to Compartment and Patch id's.
    
    More specifically, this method can automatically generate Comp objects
    if parameter 'compmap' is provided (the default value for this parameter
    is None, in which case no tetrahedron annotation takes place). compmap
    must be a dictionary that projects integer values (corresponding to 
    region attributes found in the .face file) to id strings.
    
    To automatically generate patches, a similar dictionary (called 
    'patchmap') must be provided that maps integer values (corresponding to
    boundary markers found in the .face file) to Patch id's. Additionally,
    a dictionary 'patchiomap' is required that, for each Patch id, returns 
    a tuple of id's refering to the inner and outer Comp objects relative to 
    the Patch. Therefore, automatic Patch generation only works if automatic 
    compartment generation is also requested. 
    
    (See the documentation for steps.geom.tetmesh to understand the 
    relationships between TetMesh, Comp and Patch objects.) 
    
    PARAMETERS:
        pathroot
            The root of the path name. E.g. mesh/torus would make this
            routine try to read files mesh/torus.node, mesh/torus.ele 
            and optionally for mesh/torus.face
        compmap
            Optional: a dictionary mapping integer values to Comp id strings.
            If None (=default), Comp objects are not created automatically.
        patchmap
            Optional: a dictionary mapping integers to Patch id strings.
            If None (=default), Patch objects are not created automatically.
        patchiomap
            Optional: a dictionary mapping a Patch id string to a tuple 
            of strings or None objects. The first element is the id of the
            inner Comp object, the second element of the tuple is the id of
            the outer Comp object.
            If None (=default), Patch objects are not created automatically.
    
    RETURNS:
        A tuple (tetmesh, comps, patches). 
        tetmesh 
            The STEPS TetMesh object
        comps 
            A list of integer values corresponding to the region attributes 
            found in the .ele file. If no region attributes were found, it
            returns None.
        patches
            A list of integer values corresponding to the boundary markers 
            found in the .face file. If the .face file does not exist, or
            if no boundary markers were found, it returns None.
    
    RAISES:
        Exception handling still needs to be incorporated for this routine.
    """
    nodefname = pathroot + '.node'
    elefname = pathroot + '.ele'
    facefname = pathroot + '.face'
    # Is there a .node file?
    if not opath.isfile(nodefname):
        print nodefname
        return None
    if not opath.isfile(elefname):
        print elefname
        return None
    if not opath.isfile(facefname):
        facefname = ''
    
    # Try to read the node file.
    nodefile = open(nodefname, 'r')
    # First line is:  <x> <y> <z> [att<# of points> <dimension (3)> <# of attributes>
    #                <boundary marker (0 or 1)>
    line = nodefile.readline()
    tokens = line.split()
    assert len(tokens) == 4
    nnodes = int(tokens[0])
    assert nnodes > 0
    ndims = int(tokens[1])
    assert ndims == 3
    nattribs = int(tokens[2])
    bmarkers = int(tokens[3])
    idxshift = 0
    # Construct appropriate data structure.
    nodes = numpy.empty((nnodes, ndims))
    # Read until we have all nodes.
    for nodeno in xrange(0, nnodes):
        line = nodefile.readline()
        commentstart = line.find('#')
        if commentstart != -1:
            line = line[0:commentstart]
        # Remaing lines: <point #>ributes] 
        #                [boundary marker]
        tokens = line.split()
        if len(tokens) == 0: 
            continue
        nodeidx = int(tokens[0])
        if nodeno == 0:
            idxshift = nodeidx
        idx2 = nodeidx - idxshift
        nodes[idx2,0] = float(tokens[1])
        nodes[idx2,1] = float(tokens[2])
        nodes[idx2,2] = float(tokens[3])
    # Close the file.
    nodefile.close()

    # Try to read the .ele file.
    elefile = open(elefname, 'r')
    # First line: <# of tetrahedra> <nodes per tet. (4 or 10)>
    #             <region attribute (0 or 1)>
    line = elefile.readline()
    tokens = line.split()
    assert len(tokens) == 3
    ntets = int(tokens[0])
    assert ntets > 0
    nodespertet = int(tokens[1])
    assert (nodespertet == 4) or (nodespertet == 10)
    attridx = 1 + nodespertet
    tetregattrib = int(tokens[2])
    assert (tetregattrib == 0) or (tetregattrib == 1)
    # Construct appropriate data structure.
    tets = numpy.empty((ntets, 4), dtype = int)
    comps = [ ]
    # Read until we have all the elements.
    for eleno in xrange(0, ntets):
        line = elefile.readline()
        commentstart = line.find('#')
        if commentstart != -1:
            line = line[0:commentstart]
        # Remaining lines: <tetrahedron #> <node> ... <node> [attribute]
        tokens = line.split()
        if len(tokens) == 0: 
            continue
        tetidx = int(tokens[0]) - idxshift
        tets[tetidx, 0] = int(tokens[1]) - idxshift
        tets[tetidx, 1] = int(tokens[2]) - idxshift
        tets[tetidx, 2] = int(tokens[3]) - idxshift
        tets[tetidx, 3] = int(tokens[4]) - idxshift
        if tetregattrib == 1:
            comps.append(int(tokens[attridx]))
    if tetregattrib == 1:
        assert len(comps) == ntets
    # Close the file.
    elefile.close() 
    
    # If we have a .face file, try to read it.
    nfaces = 0
    faceregattrib = 0
    faces = None
    patches = [ ]
    if len(facefname) > 0:
        facefile = open(facefname, 'r')
        # Read the first line: <# of faces
        line = facefile.readline()
        tokens = line.split()
        assert len(tokens) == 2
        nfaces = int(tokens[0])
        assert nfaces > 0
        faceregattrib = int(tokens[1])
        assert (faceregattrib == 0) or (faceregattrib == 1)
        # Construct appropriate data structure.
        faces = numpy.empty((nfaces, 3), dtype = int)
        patches = [ ]
        # Read until we have all the elements.
        for faceno in xrange(0, nfaces):
            line = facefile.readline()
            commentstart = line.find('#')
            if commentstart != -1:
                line = line[0:commentstart]
            # Remaining lines: <face #> <node> <node> <node> [bmarker]
            tokens = line.split()
            if len(tokens) == 0: 
                continue
            faceidx = int(tokens[0]) - idxshift
            faces[faceidx, 0] = int(tokens[1]) - idxshift
            faces[faceidx, 1] = int(tokens[2]) - idxshift
            faces[faceidx, 2] = int(tokens[3]) - idxshift
            if faceregattrib == 1:
                patches.append(int(tokens[4]))
        if faceregattrib == 1:
            assert len(patches) == nfaces
        # Close the face file.
        facefile.close()

    # Create the mesh.
    nodes = nodes.flatten()																						#########################
    tets = tets.flatten()																						######  flattening ######
    faces = faces.flatten()																						#########################
    tetmesh = stetmesh.Tetmesh(nodes, tets, faces)
    assert tetmesh != None
    
    # Annotation for compartments and patches.
    if (len(comps) > 0) and (compmap != None):
        # We start with compartments.
        uniqcomps = set(comps)
        # Check whether the provided map covers everything.
        for i in uniqcomps:
            assert i in compmap
        for i in uniqcomps:
            alltets = [ x for x in xrange(0, ntets) if comps[x] == i ]
            newcomp = stetmesh.TmComp(compmap[i], tetmesh, alltets)
        
        # Then we go on with patches.
        if (len(patches) > 0) and (patchmap != None) and (patchiomap != None):
            uniqpatches = set(patches)
            # Check whether the provided maps make sense.
            for i in uniqpatches:
                assert i in patchmap
            for i in uniqpatches:
                alltris = [ x for x in xrange(0, nfaces) if patches[x] == i ]
                patch_n = patchmap[i]
                (icomp_n, ocomp_n) = patchiomap[patch_n]
                icomp = tetmesh.getComp(icomp_n)
                assert icomp != None
                ocomp = None
                if ocomp_n != None:
                    ocomp = tetmesh.getComp(ocomp_n)
                    assert ocomp != None
                np = stetmesh.TmPatch(patch_n, tetmesh, alltris, icomp, ocomp)
    
    # Return the mesh.
    if len(comps) == 0:
        comps = None
    if len(patches) == 0:
        patches = None
    return (tetmesh, comps, patches)


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

