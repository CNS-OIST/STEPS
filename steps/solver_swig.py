# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.31
#
# Don't modify this file, modify the SWIG interface instead.
# This file is compatible with both classic and new-style classes.

import _solver_swig
import new
new_instancemethod = new.instancemethod
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'PySwigObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static) or hasattr(self,name):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError,name

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

import types
try:
    _object = types.ObjectType
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0
del types


class PySwigIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PySwigIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PySwigIterator, name)
    def __init__(self): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _solver_swig.delete_PySwigIterator
    __del__ = lambda self : None;
    def value(*args): return _solver_swig.PySwigIterator_value(*args)
    def incr(*args): return _solver_swig.PySwigIterator_incr(*args)
    def decr(*args): return _solver_swig.PySwigIterator_decr(*args)
    def distance(*args): return _solver_swig.PySwigIterator_distance(*args)
    def equal(*args): return _solver_swig.PySwigIterator_equal(*args)
    def copy(*args): return _solver_swig.PySwigIterator_copy(*args)
    def next(*args): return _solver_swig.PySwigIterator_next(*args)
    def previous(*args): return _solver_swig.PySwigIterator_previous(*args)
    def advance(*args): return _solver_swig.PySwigIterator_advance(*args)
    def __eq__(*args): return _solver_swig.PySwigIterator___eq__(*args)
    def __ne__(*args): return _solver_swig.PySwigIterator___ne__(*args)
    def __iadd__(*args): return _solver_swig.PySwigIterator___iadd__(*args)
    def __isub__(*args): return _solver_swig.PySwigIterator___isub__(*args)
    def __add__(*args): return _solver_swig.PySwigIterator___add__(*args)
    def __sub__(*args): return _solver_swig.PySwigIterator___sub__(*args)
    def __iter__(self): return self
PySwigIterator_swigregister = _solver_swig.PySwigIterator_swigregister
PySwigIterator_swigregister(PySwigIterator)

class Err(_object):
    """Proxy of C++ Err class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Err, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Err, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string msg="") -> Err
        __init__(self) -> Err
        """
        this = _solver_swig.new_Err(*args)
        try: self.this.append(this)
        except: self.this = this
    def getMsg(*args):
        """getMsg(self) -> char"""
        return _solver_swig.Err_getMsg(*args)

    __swig_destroy__ = _solver_swig.delete_Err
    __del__ = lambda self : None;
Err_swigregister = _solver_swig.Err_swigregister
Err_swigregister(Err)

class ArgErr(Err):
    """Proxy of C++ ArgErr class"""
    __swig_setmethods__ = {}
    for _s in [Err]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ArgErr, name, value)
    __swig_getmethods__ = {}
    for _s in [Err]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ArgErr, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string msg="") -> ArgErr
        __init__(self) -> ArgErr
        """
        this = _solver_swig.new_ArgErr(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _solver_swig.delete_ArgErr
    __del__ = lambda self : None;
ArgErr_swigregister = _solver_swig.ArgErr_swigregister
ArgErr_swigregister(ArgErr)

class NotImplErr(Err):
    """Proxy of C++ NotImplErr class"""
    __swig_setmethods__ = {}
    for _s in [Err]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NotImplErr, name, value)
    __swig_getmethods__ = {}
    for _s in [Err]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, NotImplErr, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string msg="") -> NotImplErr
        __init__(self) -> NotImplErr
        """
        this = _solver_swig.new_NotImplErr(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _solver_swig.delete_NotImplErr
    __del__ = lambda self : None;
NotImplErr_swigregister = _solver_swig.NotImplErr_swigregister
NotImplErr_swigregister(NotImplErr)

class API(_object):
    """Proxy of C++ API class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, API, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, API, name)
    def __init__(self): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _solver_swig.delete_API
    __del__ = lambda self : None;
    def getSolverName(*args):
        """
        Returns a string of the solver's name.

        Syntax::
            
            getSolverName()
            
        Arguments:
            None

        Return:
            string

        """
        return _solver_swig.API_getSolverName(*args)

    def getSolverDesc(*args):
        """
        Returns a string giving a short description of the solver.

        Syntax::
            
            getSolverDesc()
            
        Arguments:
            None

        Return:
            string

        """
        return _solver_swig.API_getSolverDesc(*args)

    def getSolverAuthors(*args):
        """
        Returns a string of the solver authors names.

        Syntax::
            
            getSolverAuthors()
            
        Arguments:
            None

        Return:
            string

        """
        return _solver_swig.API_getSolverAuthors(*args)

    def getSolverEmail(*args):
        """
        Returns a string giving the author's email address.

        Syntax::
            
            getSolverEmail()
            
        Arguments:
            None

        Return:
            string

        """
        return _solver_swig.API_getSolverEmail(*args)

    def reset(*args):
        """
        Reset the simulation to the state the solver was initialised to. 
        Typically, this resets all concentrations of all chemical species in 
        all elements (whether compartments and patches in a well-mixed solver 
        or tetrahedrons and triangles in a mesh-based solver) to zero, 
        resets the simulation time to zero and resets reaction (and diffusion) 
        rates to the default values described in the steps.model objects. 
        All reaction (and diffusion) rules are reset to active and all 
        compartment volumes and patch areas are reset to default values 
        described in steps.geom objects (for well-mixed solvers). 
        Usually, this method should be called before starting each simulation iteration.

        Syntax::
            
            reset()
            
        Arguments:
            None

        Return:
            None

        """
        return _solver_swig.API_reset(*args)

    def run(*args):
        """
        Advance the simulation until endtime (given in seconds) is reached. 
        The endtime must be larger or equal to the current simulation time.

        Syntax::
            
            run(endtime)
            
        Arguments:
            float endtime

        Return:
            None

        """
        return _solver_swig.API_run(*args)

    def getTime(*args):
        """
        Returns the current simulation time in seconds.

        Syntax::
            
            getTime()
            
        Arguments:
            None

        Return:
            float

        """
        return _solver_swig.API_getTime(*args)

    def advance(*args):
        """
        Advance the simulation for secs seconds. 

        Syntax::
            
            advance(adv)
            
        Arguments:
            float adv

        Return:
            None

        """
        return _solver_swig.API_advance(*args)

    def step(*args):
        """
        Advance the simulation for one 'step'. In stochastic solvers this is one 
        'realization' of the Gillespie SSA (one reaction 'event'). 
        In numerical solvers (currently Wmrk4) this is one time-step, with the 
        stepsize defined with the setDT method.

        Syntax::
            
            step()
            
        Arguments:
            None

        Return:
            None

        """
        return _solver_swig.API_step(*args)

    def setDT(*args):
        """
        Set the stepsize for numerical solvers. Must be called before running a 
        simulation with these solvers (currently Wmrk4) since there is no default 
        stepsize. The deterministic solver Wmrk4 implements a fixed stepsize 
        (i.e. not adaptive), although the stepsize can be altered at any point 
        during the simulation with this method.

        Syntax::
            
            setDT(dt)
            
        Arguments:
            float dt

        Return:
            None

        """
        return _solver_swig.API_setDT(*args)

    def getDT(*args):
        """
        Returns the stepsize for numerical solvers.

        Syntax::
            
            getDT()
            
        Arguments:
            None

        Return:
            float

        """
        return _solver_swig.API_getDT(*args)

    def setTime(*args):
        """
        Set the current simulation time.

        Syntax::
            
            setTime(time)
            
        Arguments:
            folat time

        Return:
            None

        """
        return _solver_swig.API_setTime(*args)

    def getA0(*args):
        """
        Returns the total propensity of the current simulation state 
        (the total propensity multiplied by an infinitesimally small 
        time dt gives the probability that a reaction will occur in that dt). 
        For Tetexact this includes the propensity from the extension of the SSA 
        for diffusive flux between tetrahedral elements in the mesh.

        Syntax::
            
            getA0()
            
        Arguments:
            None

        Return:
            float

        """
        return _solver_swig.API_getA0(*args)

    def getNSteps(*args):
        """
        Return the number of 'realizations' of the SSA, the number of reaction 
        (and diffusion) events in stochastic solvers.

        Syntax::
            
            getNSteps()
            
        Arguments:
            None

        Return:
            uint

        """
        return _solver_swig.API_getNSteps(*args)

    def setNSteps(*args):
        """
        Set the number of 'realizations' of the SSA, the number of reaction 
        (and diffusion) events in stochastic solvers.

        Syntax::
            
            setNSteps(nsteps)
            
        Arguments:
            uint nsteps

        Return:
            None

        """
        return _solver_swig.API_setNSteps(*args)

    def getCompVol(*args):
        """
        Returns the volume of compartment with identifier string comp (in m^3).

        Syntax::
            
            getCompVol(comp)
            
        Arguments:
            string comp

        Return:
            float

        """
        return _solver_swig.API_getCompVol(*args)

    def setCompVol(*args):
        """
        Set the volume of compartment with identifier string comp (in m^3).

        Syntax::
            
            setCompVol(comp, vol)
            
        Arguments:
            * string comp
            * float vol

        Return:
            None

        """
        return _solver_swig.API_setCompVol(*args)

    def getCompCount(*args):
        """
        Returns the number of molecules of a species with identifier string spec 
        in compartment with identifier string comp.

        In a mesh-based simulation (i.e. Tetexact) this is the combined count from 
        all tetrahedral elements in the compartment.

        Syntax::
            
            getCompCount(comp, spec)
            
        Arguments:
            * string comp
            * string spec

        Return:
            float

        """
        return _solver_swig.API_getCompCount(*args)

    def setCompCount(*args):
        """
        Set the number of molecules of a species with identifier string spec 
        in compartment with identifier string comp.

        In a mesh-based simulation (i.e. Tetexact) this is the combined count from 
        all tetrahedral elements in the compartment.

        Syntax::
            
            setCompCount(comp, spec, nspec)
            
        Arguments:
            * string comp
            * string spec
            * uint nspec

        Return:
            None

        """
        return _solver_swig.API_setCompCount(*args)

    def getCompAmount(*args):
        """
        Returns the amount (in mols) of species with identifier string spec in compartment 
        with identifier string comp.

        In a mesh-based simulation (i.e. Tetexact) this is the combined amount from all 
        tetrahedral elements in the compartment.

        Syntax::
            
            getCompAmount(comp, spec)
            
        Arguments:
            * string comp
            * string spec

        Return:
            float

        """
        return _solver_swig.API_getCompAmount(*args)

    def setCompAmount(*args):
        """
        Set the amount (in mols) of species with identifier string spec in compartment 
        with identifier string comp.

        In a mesh-based simulation (i.e. Tetexact) this is the combined amount from all 
        tetrahedral elements in the compartment.

        Syntax::
            
            setCompAmount(comp, spec, amount)
            
        Arguments:
            * string comp
            * string spec
            * float amount

        Return:
            None

        """
        return _solver_swig.API_setCompAmount(*args)

    def getCompConc(*args):
        """
        Returns the concentration (in Molar units) of species with identifier string spec 
        in compartment with identifier string comp.

        Note: in a mesh-based simulation (i.e. Tetexact) this is calculated from the combined 
        number of molecules from all tetrahedral elements in the compartment and the total 
        volume of the tetrahedrons.

        Syntax::
            
            getCompConc(comp, spec)
            
        Arguments:
            * string comp
            * string spec

        Return:
            float

        """
        return _solver_swig.API_getCompConc(*args)

    def setCompConc(*args):
        """
        Sets the concentration (in Molar units) of species with identifier string spec 
        in compartment with identifier string comp to conc. In a discrete solver the 
        continuous concentration is converted to a discrete number of 
        molecules.

        Note: in a mesh-based simulation (i.e. Tetexact) the molecules are divided as 
        equally as possible over all tetrahedral elements in the compartment (i.e. a 
        uniform distribution).

        Syntax::

            setCompConc(comp, spec, conc)
            
        Arguments:
            * string comp
            * string spec
            * float conc

        Return:
            None

        """
        return _solver_swig.API_setCompConc(*args)

    def getCompClamped(*args):
        """
        Returns True if species with identifier string spec in compartment with identifier 
        string comp is clamped (buffered), which means the concentration remains the same 
        regardless of reactions that consume or produce molecules of this species. 
        Returns False if not.

        Note: in a mesh-based simulation (i.e. Tetexact) it returns True only if the species 
        is clamped in all tetrahedral elements of the compartment.

        Syntax::
            
            getCompClamped(comp, spec)
            
        Arguments:
            * string comp
            * string spec

        Return:
            bool

        """
        return _solver_swig.API_getCompClamped(*args)

    def setCompClamped(*args):
        """
        Sets whether the concentration of species with identifier string spec in compartment 
        with identifier string comp is clamped (clamped = True) or not (clamped = False). 
        If a species is clamped the concentration stays the same regardless of reactions 
        that consume or produce molecules of the species.

        Note: in a mesh-based simulation (i.e. Tetexact) this will set the species to be 
        clamped or not in all tetrahedral elements of the compartment.

        Syntax::
            
            setCompClamped(comp, spec, clamped)
            
        Arguments:
            * string comp
            * string spec
            * bool clamped

        Return:
            bool

        """
        return _solver_swig.API_setCompClamped(*args)

    def getCompReacK(*args):
        """
        Returns the macroscopic reaction constant of reaction with identifier string reac 
        in compartment with identifier string comp. The unit of the reaction constant depends 
        on the order of the reaction.

        Note: In a mesh-based simulation (i.e. Tetexact) the value for the compartment is 
        returned, although individual tetrahedral elements may have different values 
        (set with setTetReacK).

        Syntax::
            
            getCompReacK(comp, reac)
            
        Arguments:
            * string comp
            * string reac

        Return:
            float

        """
        return _solver_swig.API_getCompReacK(*args)

    def setCompReacK(*args):
        """
        Sets the macroscopic reaction constant of reaction with identifier string reac 
        in compartment with identifier string comp to kf. The unit of the reaction constant 
        depends on the order of the reaction.

        Note: In a mesh-based simulation (i.e. Tetexact) this method sets the reaction 
        constant in all tetrahedral elements of the compartment to kf

        Note: The default value still comes from the steps.model description, so 
        calling reset() will return the reaction constant to that value.

        Syntax::
            
            setCompReacK(comp, reac, kf)
            
        Arguments:
            * string comp
            * string reac
            * float kf

        Return:
            None

        """
        return _solver_swig.API_setCompReacK(*args)

    def getCompReacActive(*args):
        """
        Returns whether a reaction with identifier string reac in compartment with identifier 
        string comp is active (True) or not (False). If it's not active this means that a 
        reaction will never occur regardless of whether the reactants are present in 
        sufficient numbers or not. 

        Note: In a mesh-based simulation (i.e. Tetexact) this method will return True only 
        if the reaction is active in all tetrahedral elements in the compartment. 

        Syntax::
            
            getCompReacActive(comp, reac)
            
        Arguments:
            * string comp
            * string reac

        Return:
            bool

        """
        return _solver_swig.API_getCompReacActive(*args)

    def setCompReacActive(*args):
        """
        Activate (active = True) or deactivate (active = False) a reaction with identifier 
        string reac in compartment with identifier string comp. If a reaction is not active 
        this means that a reaction will never occur regardless of whether the reactants are 
        present in sufficient numbers or not.

        Note: In a mesh-based simulation (i.e. Tetexact) this will activate/deactivate the 
        reaction in all tetrahedral elements in the compartment. 

        Syntax::
            
            setCompReacActive(comp, reac, active)
            
        Arguments:
            * string comp
            * string reac
            * bool active

        Return:
            None

        """
        return _solver_swig.API_setCompReacActive(*args)

    def getCompDiffD(*args):
        """
        Returns the diffusion constant of diffusion rule with identifier string diff 
        in compartment with identifier string comp. This constant is in units m^2/s.

        Note: In a mesh-based solver (i.e. Tetexact) the value for the compartment is 
        returned, although individual or groups of tetrahedral elements may have different 
        values (set with setTetDiffD). 

        Syntax::
            
            getCompDiffD(comp, diff)
            
        Arguments:
            * string comp
            * string diff

        Return:
            float

        """
        return _solver_swig.API_getCompDiffD(*args)

    def setCompDiffD(*args):
        """
        Sets the diffusion constant of diffusion rule with identifier string diff 
        in compartment with identifier string comp to dcst (in m^2/s).

        Note: This method will set the diffusion constant in all tetrahedral elements 
        in the compartment.

        Note: The default value still comes from the steps.model description, 
        so calling reset() will return the diffusion constants to that value. 

        Syntax::
            
            setCompDiffD(comp, diff, dcst)
            
        Arguments:
            * string comp
            * string diff
            * float dcst

        Return:
            None

        """
        return _solver_swig.API_setCompDiffD(*args)

    def getCompDiffActive(*args):
        """
        Returns whether a diffusion rule with identifier string diff in compartment with 
        identifier string comp is active (True) or not (False). If diffusion of a species 
        is inactive this means the molecules will remain in place and has the same effect 
        as a diffusion constant of zero. 

        Syntax::
            
            getCompDiffActive(comp, diff)
            
        Arguments:
            * string comp
            * string diff

        Return:
            bool

        """
        return _solver_swig.API_getCompDiffActive(*args)

    def setCompDiffActive(*args):
        """
        Activate (active = True) or deactivate (active = False) a diffusion rule with 
        identifier string diff in compartment with identifier string comp. If diffusion 
        of a species is inactive this means the molecules will remain in place and is 
        effectively the same as setting the diffusion constant to zero

        Syntax::
            
            setCompDiffActive(comp, diff, active)
            
        Arguments:
            * string comp
            * string diff
            * bool active

        Return:
            None

        """
        return _solver_swig.API_setCompDiffActive(*args)

    def getCompReacC(*args):
        """
        Returns the 'stochastic reaction constant' (or 'specific probability rate constant') 
        of reaction with identifier string reac in compartment with identifier string comp.

        The 'stochastic reaction constant' multiplied by infinitesimal time interval dt 
        gives the average probability that one reaction channel of this reaction type 
        will react accordingly in dt.

        Note: in a mesh-based simulation (i.e. Tetexact), the stochastic reaction constant 
        is computed as the weighted mean of the stochastic reaction constants in all 
        tetrahedral elements of the compartment.

        Syntax::
            
            getCompReacC(comp, reac)
            
        Arguments:
            * string comp
            * string reac

        Return:
            float

        """
        return _solver_swig.API_getCompReacC(*args)

    def getCompReacH(*args):
        """
        Returns h_mu, the distinct number of ways in which reaction with identifier string 
        reac can occur in compartment with identifier string comp, by computing the product 
        of its reactants. Note: in a mesh-based simulation (i.e. Tetexact), returns the sum 
        of the h_mu's over all tetrahedral elements in the compartment. 

        Syntax::
            
            getCompReacH(comp, reac)
            
        Arguments:
            * string comp
            * string reac

        Return:
            float

        """
        return _solver_swig.API_getCompReacH(*args)

    def getCompReacA(*args):
        """
        Returns the propensity of reaction with identifier string reac in compartment 
        with identifier string comp. 

        The propensity of a reaction is a function of state and is defined as the 
        function whose product with infinitesimal time dt gives the probability 
        that the reaction will occur in the next dt. It is the 'stochastic reaction 
        constant' multiplied by 'h_mu'. 

        Note: in a mesh-based simulation (i.e. Tetexact), the propensity of a reaction 
        in a compartment is computed as the sum of the propensities in all tetrahedral 
        elements of the compartment. 

        Syntax::
            
            getCompReacA(comp, reac)
            
        Arguments:
            * string comp
            * string reac

        Return:
            float

        """
        return _solver_swig.API_getCompReacA(*args)

    def getCompReacExtent(*args):
        """
        Return the extent of reaction with identifier string reac in compartment with 
        identifier string comp, that is the number of times the reaction has occurred up 
        to the current simulation time. 

        Note: in a mesh-based simulation (i.e. Tetexact), returns the sum of the reaction 
        extents in all tetrahedral elements of the compartment.

        Syntax::
            
            getCompReacExtent(comp, reac)
            
        Arguments:
            * string comp
            * string reac

        Return:
            uint

        """
        return _solver_swig.API_getCompReacExtent(*args)

    def resetCompReacExtent(*args):
        """
        Resets the extent of reaction with identifier string reac in compartment with 
        identifier string comp to zero. 

        Note: in a mesh-based simulation (i.e. Tetexact), 
        resets the extents of the reaction in all tetrahedral elements of the compartment.

        Syntax::
            
            resetCompReacExtent(comp, reac)
            
        Arguments:
            * string comp
            * string reac

        Return:
            None

        """
        return _solver_swig.API_resetCompReacExtent(*args)

    def getTetVol(*args):
        """
        Returns the volume (in m^3) of the tetrahedral element with index idx.

        Syntax::
            
            getTetVol(idx)
            
        Arguments:
            * uint idx

        Return:
            float

        """
        return _solver_swig.API_getTetVol(*args)

    def getTetCount(*args):
        """
        Returns the number of molecules of species with identifier string spec 
        in the tetrahedral element with index idx.

        Syntax::
            
            getTetCount(idx, spec)
            
        Arguments:
            * uint idx
            * string spec

        Return:
            uint

        """
        return _solver_swig.API_getTetCount(*args)

    def setTetCount(*args):
        """
        Sets the number of molecules of species with identifier string spec in 
        tetrahedral element with index idx to n.

        Syntax::
            
            setTetCount(idx, spec, n)
            
        Arguments:
            * uint idx
            * string spec
            * uint n

        Return:
            None

        """
        return _solver_swig.API_setTetCount(*args)

    def getTetAmount(*args):
        """
        Returns the amount (in mols) of species with identifier string spec in 
        tetrahedral element with index idx.

        Syntax::
            
            getTetAmount(idx, spec)
            
        Arguments:
            * uint idx
            * string spec

        Return:
            float

        """
        return _solver_swig.API_getTetAmount(*args)

    def setTetAmount(*args):
        """
        Sets the amount (in mols) of species with identifier string spec in tetrahedral 
        element with index idx to a. This continuous value must be converted internally 
        to a discrete number of molecules by multiplication with Avogadro's 
        number. 

        Due to the small volumes of tetrahedral elements the difference 
        between 'rounding up' and 'rounding down' can be a significant difference in 
        concentration.

        Syntax::
            
            setTetAmount(idx, spec, a)
            
        Arguments:
            * uint idx
            * string spec
            * float a

        Return:
            None

        """
        return _solver_swig.API_setTetAmount(*args)

    def getTetConc(*args):
        """
        Returns the concentration (in Molar units) of species with identifier 
        string spec in a tetrahedral element with index idx.

        Syntax::
            
            getTetConc(idx, spec)
            
        Arguments:
            * uint idx
            * string spec

        Return:
            float

        """
        return _solver_swig.API_getTetConc(*args)

    def setTetConc(*args):
        """
        Sets the concentration (in Molar units) of species with identifier string spec 
        in a tetrahedral element with index idx to conc.This continuous value must be 
        converted internally to a discrete number of molecules. 

        Due to the small volumes of tetrahedral elements the difference between 'rounding 
        up' and 'rounding down' can be a large difference in concentration.

        Syntax::
            
            setTetConc(idx, spec, conc)
            
        Arguments:
            * uint idx
            * string spec
            * conc

        Return:
            None

        """
        return _solver_swig.API_setTetConc(*args)

    def getTetClamped(*args):
        """
        Returns True if concentration of species with identifier string spec in tetrahedral 
        element with index idx is clamped (buffered), which means the concentration stays the 
        same regardless of reactions that consume or produce molecules of this species or 
        diffusion of this species into or out of the tetrahedral element. Returns False if 
        not.

        Syntax::
            
            getTetClamped(idx, spec)
            
        Arguments:
            * uint idx
            * string spec

        Return:
            bool

        """
        return _solver_swig.API_getTetClamped(*args)

    def setTetClamped(*args):
        """
        Sets whether the concentration of species spec in tetrahedral element with 
        index idx is clamped (clamped = True) or not (clamped = False). 
        If a species is clamped the concentration stays the same regardless 
        of reactions that consume or produce molecules of the species or 
        diffusion of the species into or out of the tetrahedral element.

        Syntax::
            
            setTetClamped(idx, spec, clamped)
            
        Arguments:
            * uint idx
            * string spec
            * bool clamped

        Return:
            None

        """
        return _solver_swig.API_setTetClamped(*args)

    def getTetReacK(*args):
        """
        Returns the macroscopic reaction constant of reaction with identifier string reac 
        in tetrahedral element with index idx. The unit of the reaction constant depends 
        on the order of the reaction.

        Syntax::
            
            getTetReacK(idx, reac)
            
        Arguments:
            * uint idx
            * string reac

        Return:
            float

        """
        return _solver_swig.API_getTetReacK(*args)

    def setTetReacK(*args):
        """
        Sets the macroscopic reaction constant of reaction with identifier string reac 
        in tetrahedral element with index idx to kf. The units of the reaction constant 
        depends on the order of the reaction.

        Syntax::
            
            setTetReacK(idx, reac, kf)
            
        Arguments:
            * uint idx
            * string reac
            * float kf

        Return:
            None

        """
        return _solver_swig.API_setTetReacK(*args)

    def getTetReacActive(*args):
        """
        Returns whether reaction with identifier string reac in tetrahedral element 
        with index idx is active (True) or not (False). If it's not active this means 
        that the reaction will never occur regardless of whether reactants are present 
        in sufficient numbers or not.

        Syntax::
            
            getTetReacActive(idx, reac)
            
        Arguments:
            * uint idx
            * string reac

        Return:
            bool

        """
        return _solver_swig.API_getTetReacActive(*args)

    def setTetReacActive(*args):
        """
        Activate (active = True) or deactivate (active = False) a reaction with identifier 
        string reac in tetrahedral element with index idx. If it's not active this means 
        that the reaction will never occur regardless of whether reactants are present 
        in sufficient numbers or not.

        Syntax::
            
            setTetReacActive(idx, reac, active)
            
        Arguments:
            * uint idx
            * string reac
            * bool active

        Return:
            None

        """
        return _solver_swig.API_setTetReacActive(*args)

    def getTetDiffD(*args):
        """
        Returns the diffusion constant of diffusion rule with identifier string diff 
        in tetrahedral element with index idx. This constant is in units m^2/s. 

        Syntax::
            
            getTetDiffD(idx, diff)
            
        Arguments:
            * uint idx
            * string diff

        Return:
            float

        """
        return _solver_swig.API_getTetDiffD(*args)

    def setTetDiffD(*args):
        """
        Sets the diffusion constant of diffusion rule with identifier string diff in 
        tetrahedral element with index idx to dcst (in m^2/s).

        Syntax::
            
            setTetDiffD(idx, diff, dcst)
            
        Arguments:
            * uint idx
            * string diff
            * dcst

        Return:
            None

        """
        return _solver_swig.API_setTetDiffD(*args)

    def getTetDiffActive(*args):
        """
        Returns whether diffusion with identifier string diff in tetrahedral element 
        with index idx is active (True) or not (False). If diffusion of a species 
        is inactive this means the molecules will never diffuse out of the tetrahedron 
        and has the same effect as a diffusion constant of zero.

        Syntax::
            
            getTetDiffActive(idx, diff)
            
        Arguments:
            * uint idx
            * string diff

        Return:
            bool

        """
        return _solver_swig.API_getTetDiffActive(*args)

    def setTetDiffActive(*args):
        """
        Activate (active = True) or deactivate (active = False) diffusion rule with 
        identifier string diff in tetrahedral element with index idx. If diffusion of 
        a species is inactive this means the molecules will never diffuse out of the 
        tetrahedron and has the same effect as a diffusion constant of zero. 

        Syntax::
            
            setTetDiffActive(idx, diff, active)
            
        Arguments:
            * uint idx
            * string diff
            * bool active

        Return:
            None

        """
        return _solver_swig.API_setTetDiffActive(*args)

    def getTetReacC(*args):
        """
        Returns the 'stochastic reaction constant' (or 'specific probability rate constant') 
        of reaction with identifier string reac in tetrahedral element with index idx.

        Syntax::
            
            getTetReacC(idx, reac)
            
        Arguments:
            * uint idx
            * string reac

        Return:
            float

        """
        return _solver_swig.API_getTetReacC(*args)

    def getTetReacH(*args):
        """
        Returns h_mu, the distinct number of ways in which reaction with identifier string 
        reac can occur in tetrahedral element with index idx, by computing the product of 
        its reactants.

        Syntax::
            
            getTetReacH(idx, reac)
            
        Arguments:
            * uint idx
            * string reac

        Return:
            float

        """
        return _solver_swig.API_getTetReacH(*args)

    def getTetReacA(*args):
        """
        Returns the propensity of reaction with identifier string reac in tetrahedral 
        element with index idx.

        Syntax::
            
            getTetReacA(idx, reac)
            
        Arguments:
            * uint idx
            * string reac

        Return:
            float

        """
        return _solver_swig.API_getTetReacA(*args)

    def getTetDiffA(*args):
        """
        Returns the propensityof diffusion rule with identifier string diff in 
        tetrahedral element with index idx. 

        Syntax::
            
            getTetDiffA(idx, reac)
            
        Arguments:
            * uint idx
            * string reac

        Return:
            float

        """
        return _solver_swig.API_getTetDiffA(*args)

    def getPatchArea(*args):
        """
        Returns the area of patch with identifier string pat (in m^2).

        Syntax::
            
            getPatchArea(pat)
            
        Arguments:
            * string pat

        Return:
            float

        """
        return _solver_swig.API_getPatchArea(*args)

    def setPatchArea(*args):
        """
        Sets the area of patch with identifier string pat to area a (in m^2).

        Syntax::
            
            setPatchArea(pat, area)
            
        Arguments:
            * string pat
            * float area

        Return:
            None

        """
        return _solver_swig.API_setPatchArea(*args)

    def getPatchCount(*args):
        """
        Returns the number of molecules of species with identifier string spec in patch 
        with identifier string pat.Note: in a mesh-based simulation (i.e. Tetexact) this 
        is the combined count from all triangular elements in the patch. 

        Syntax::
            
            getPatchCount(pat, spec)
            
        Arguments:
            * string pat
            * string spec

        Return:
            float

        """
        return _solver_swig.API_getPatchCount(*args)

    def setPatchCount(*args):
        """
        Sets the number of molecules of species with identifier string spec in patch 
        with identifier string pat to n. Note: in a mesh-based simulation (i.e. Tetexact) 
        the molecules are divided as equally as possible over all triangular elements in 
        the patch (i.e. a uniform distribution). 

        Syntax::
            
            setPatchCount(pat, spec, n)
            
        Arguments:
            * string pat
            * string spec
            * uint n

        Return:
            float

        """
        return _solver_swig.API_setPatchCount(*args)

    def getPatchAmount(*args):
        """
        Returns the amount (in mols) of species with identifier string spec in patch 
        with identifier string pat.

        Note: in a mesh-based simulation (i.e. Tetexact) this is the combined amount 
        from all triangular elements in the patch. 

        Syntax::
            
            getPatchAmount(pat, spec)
            
        Arguments:
            * string pat
            * string spec

        Return:
            float

        """
        return _solver_swig.API_getPatchAmount(*args)

    def setPatchAmount(*args):
        """
        Sets the amount (in mols) of species with identifier string spec in patch with 
        identifier string pat to a. In a discrete solver, such as Wmdirect and Tetexact, 
        this continuous value is converted internally into a discrete number of molecules 
        by multiplication with Avogadro's number. 

        Note: in a mesh-based simulation (i.e. Tetexact) the molecules are divided as 
        equally as possible over all triangular elements in the patch (i.e. a uniform 
        distribution).

        Syntax::
            
            setPatchAmount(pat, spec, a)
            
        Arguments:
            * string pat
            * string spec
            * float a

        Return:
            None

        """
        return _solver_swig.API_setPatchAmount(*args)

    def getPatchClamped(*args):
        """
        Sets the amount (in mols) of species with identifier string spec in patch with 
        identifier string pat to a. In a discrete solver, such as Wmdirect and Tetexact, 
        this continuous value is converted internally into a discrete number of molecules 
        by multiplication with Avogadro's number. 

        Note: in a mesh-based simulation (i.e. Tetexact) the molecules are divided as equally 
        as possible over all triangular elements in the patch (i.e. a uniform distribution).

        Syntax::
            
            getPatchClamped(pat, spec)
            
        Arguments:
            * string pat
            * string spec

        Return:
            bool

        """
        return _solver_swig.API_getPatchClamped(*args)

    def setPatchClamped(*args):
        """
        Sets whether the species with identifier string spec in patch with identifier 
        string pat is clamped (clamped = True) or not (clamped = False). If a species 
        is clamped the number of molecules stays the same regardless of surface reactions 
        that consume or produce molecules of the species.

        Note: in a mesh-based simulation this will set the species to be clamped in all 
        triangular elements of the patch.

        Syntax::
            
            setPatchClamped(pat, spec, clamped)
            
        Arguments:
            * string pat
            * string spec
            * bool clamped

        Return:
            None

        """
        return _solver_swig.API_setPatchClamped(*args)

    def getPatchSReacK(*args):
        """
        Returns the macroscopic reaction constant of surface reaction with identifier 
        string sreac in patch with identifier string pat. The unit of the reaction constant 
        depends on the order of the reaction.

        Note: In a mesh-based solver (i.e. Tetexact) the value for the patch is returned, 
        although individual triangle elements may have different values 
        (set with setTriSReacK).

        Syntax::
            
            getPatchSReacK(pat, reac)
            
        Arguments:
            * string pat
            * string reac

        Return:
            float

        """
        return _solver_swig.API_getPatchSReacK(*args)

    def setPatchSReacK(*args):
        """
        Sets the macroscopic reaction constant of surface reaction with identifier 
        string sreac in patch with identifier string pat to kf. The unit of the reaction 
        constant depends on the order of the reaction. 

        Note: In a mesh-based simulation (i.e. Tetexact) this method sets the surface 
        reaction constant in all triangular elements of the patch to kf.

        Note: The default value still comes from the steps.model description, so calling 
        reset() will return the surface reaction constant to that value.

        Syntax::
            
            setPatchSReacK(pat, reac, kf)
            
        Arguments:
            * string pat
            * string reac
            * float kf

        Return:
            None

        """
        return _solver_swig.API_setPatchSReacK(*args)

    def getPatchSReacActive(*args):
        """
        Returns whether a surface reaction with identifier string sreac in patch with 
        identifier string pat is active (True) or not (False). If it's not active this means 
        that a surface reaction will never occur regardless of whether the reactants are 
        present in sufficient numbers or not. 

        Note: In a mesh-based simulation (i.e. Tetexact) this method will return True only 
        if the surface reaction is active in all triangular elements in the patch.

        Syntax::
            
            getPatchSReacActive(pat, reac)
            
        Arguments:
            * string pat
            * string reac

        Return:
            bool

        """
        return _solver_swig.API_getPatchSReacActive(*args)

    def setPatchSReacActive(*args):
        """
        Activate (active = True) or deactivate (active = False) a surface reaction with 
        identifier string sreac in patch with identifier string pat. If a surface reaction 
        is not active this means that a reaction will never occur regardless of whether the 
        reactants are present in sufficient numbers or not.

        Note: In a mesh-based simulation (i.e. Tetexact) this will activate/ deactivate the 
        reaction in all triangular elements in the patch.

        Syntax::
            
            setPatchSReacActive(pat, reac, active)
            
        Arguments:
            * string pat
            * string reac
            * bool active

        Return:
            None

        """
        return _solver_swig.API_setPatchSReacActive(*args)

    def getPatchSReacC(*args):
        """
        Returns the 'stochastic reaction constant' (or 'specific probability rate constant') 
        of surface reaction with identifier string sreac in patch with identifier string pat.

        Note: in a mesh-based simulation (i.e. Tetexact), the stochastic reaction constant is 
        computed as the weighted mean of the stochastic reaction constants in all triangular 
        elements of the patch.

        Syntax::
            
            getPatchSReacC(pat, reac)
            
        Arguments:
            * string pat
            * string reac

        Return:
            float

        """
        return _solver_swig.API_getPatchSReacC(*args)

    def getPatchSReacH(*args):
        """
        Returns h_mu, the distinct number of ways in which surface reaction with identifier 
        string sreac can occur in patch with identifier string pat, by computing the product 
        of its reactants. Note: in a mesh-based simulation (i.e. Tetexact), returns the sum 
        of the h_mu's over all triangular elements in the patch. 

        Syntax::
            
            getPatchSReacH(pat, reac)
            
        Arguments:
            * string pat
            * string reac

        Return:
            float

        """
        return _solver_swig.API_getPatchSReacH(*args)

    def getPatchSReacA(*args):
        """
        Returns the propensity of surface reaction with identifier string sreac in patch 
        with identifier string pat. Note: in a mesh-based simulation (i.e. Tetexact), 
        the propensity of a surface reaction in a patch is computed as the sum of the 
        propensities in all triangular elements of the patch.

        Syntax::
            
            getPatchSReacA(pat, reac)
            
        Arguments:
            * string pat
            * string reac

        Return:
            float

        """
        return _solver_swig.API_getPatchSReacA(*args)

    def getPatchSReacExtent(*args):
        """
        Returns the extent of surface reaction with identifier string sreac in patch 
        with identifier string pat, that is the number of times the surface reaction 
        has occurred up to the current simulation time. 

        Note: in a mesh-based simulation (i.e. Tetexact), returns the sum of the reaction 
        extents in all triangular elements of the patch.

        Syntax::
            
            getPatchSReacExtent(pat,reac)
            
        Arguments:
            * string pat
            * string reac

        Return:
            uint

        """
        return _solver_swig.API_getPatchSReacExtent(*args)

    def resetPatchSReacExtent(*args):
        """
        Resets the extent of reaction with identifier string sreac in patch with identifier 
        string pat to zero. 

        Note: in a mesh-based simulation (i.e. Tetexact), resets the extents of the reaction 
        in all triangular elements of the patch.

        Syntax::
            
            resetPatchSReacExtent(pat, reac)
            
        Arguments:
            * string pat
            * string reac

        Return:
            None

        """
        return _solver_swig.API_resetPatchSReacExtent(*args)

    def getTriArea(*args):
        """
        Returns the area (in m^2) of the triangular element with index idx.

        Syntax::
            
            getTriArea(idx)
            
        Arguments:
            * uint idx

        Return:
            float

        """
        return _solver_swig.API_getTriArea(*args)

    def getTriCount(*args):
        """
        Returns the number of molecules of species with identifier string spec 
        in the triangular element with index idx.

        Syntax::
            
            getTriCount(idx, spec)
            
        Arguments:
            * uint idx
            * string spec

        Return:
            float

        """
        return _solver_swig.API_getTriCount(*args)

    def setTriCount(*args):
        """
        Sets the number of molecules of species with identifier string spec in 
        triangular element with index idx to n. 

        Syntax::
            
            setTriCount(idx, spec, n)
            
        Arguments:
            * uint idx
            * string spec
            * uint n

        Return:
            None

        """
        return _solver_swig.API_setTriCount(*args)

    def getTriAmount(*args):
        """
        Returns the amount (in mols) of species with identifier string spec in triangular 
        element with index idx.  

        Syntax::
            
            getTriAmount(idx, spec)
            
        Arguments:
            * uint idx
            * string spec

        Return:
            float

        """
        return _solver_swig.API_getTriAmount(*args)

    def setTriAmount(*args):
        """
        Sets the amount (in mols) of species with identifier string spec in triangular 
        element with index idx to a. This continuous value must be converted internally 
        to a discrete number of molecules by multiplication with Avogadro's number. 

        Syntax::
            
            setTriAmount(idx, spec, a)
            
        Arguments:
            * uint idx
            * string spec
            * float a

        Return:
            None

        """
        return _solver_swig.API_setTriAmount(*args)

    def getTriClamped(*args):
        """
        Returns True if the species with identifier string spec in triangular element 
        with index idx is clamped (buffered), which means the number of molecules stays 
        the same regardless of reactions that consume or produce molecules of this species. 
        Returns False if not.

        Syntax::
            
            getTriClamped(idx, spec)
            
        Arguments:
            * uint idx
            * string spec

        Return:
            bool

        """
        return _solver_swig.API_getTriClamped(*args)

    def setTriClamped(*args):
        """
        Sets whether the concentration of species spec in triangular element with index idx 
        is clamped (clamped = True) or not (clamped = False). If a species is clamped the 
        concentration stays the same regardless of reactions that consume or produce 
        molecules of the species. 

        Syntax::
            
            setTriClamped(idx, spec, clamped)
            
        Arguments:
            * uint idx
            * string spec
            * bool clamped

        Return:
            None

        """
        return _solver_swig.API_setTriClamped(*args)

    def getTriSReacK(*args):
        """
        Returns the macroscopic reaction constant of surface reaction with identifier 
        string sreac in triangular element with index idx. The units of the reaction 
        constant depends on the order of the reaction. 

        Syntax::
            
            getTriSReacK(idx, reac)
            
        Arguments:
            * uint idx
            * string reac

        Return:
            float

        """
        return _solver_swig.API_getTriSReacK(*args)

    def setTriSReacK(*args):
        """
        Sets the macroscopic reaction constant of surface reaction with identifier 
        string sreac in triangular element with index idx to kf. The units of the 
        reaction constant depends on the order of the reaction.

        Syntax::
            
            setTriSReacK(idx, reac, kf)
            
        Arguments:
            * uint idx
            * string reac
            * float kf

        Return:
            None

        """
        return _solver_swig.API_setTriSReacK(*args)

    def getTriSReacActive(*args):
        """
        Returns whether surface reaction with identifier string sreac in triangular 
        element with index idx is active (True) or not (False). If it's not active 
        this means that the surface reaction will never occur regardless of whether 
        reactants are present in sufficient numbers or not. 

        Syntax::
            
            getTriSReacActive(idx, reac)
            
        Arguments:
            * uint idx
            * string reac

        Return:
            bool

        """
        return _solver_swig.API_getTriSReacActive(*args)

    def setTriSReacActive(*args):
        """
        Activate (active = True) or deactivate (active = False) a surface reaction 
        with identifier string sreac in triangular element with index idx. If it's 
        not active this means that the surface reaction will never occur regardless 
        of whether reactants are present in sufficient numbers or not.  

        Syntax::
            
            setTriSReacActive(idx, reac, active)
            
        Arguments:
            * uint idx
            * string reac
            * active

        Return:
            None

        """
        return _solver_swig.API_setTriSReacActive(*args)

    def getTriSReacC(*args):
        """
        Returns the 'stochastic reaction constant' (or 'specific probability rate constant') 
        of surface reaction with identifier string sreac in triangular element with index idx.  

        Syntax::
            
            getTriSReacC(idx, reac)
            
        Arguments:
            * uint idx
            * string reac

        Return:
           float

        """
        return _solver_swig.API_getTriSReacC(*args)

    def getTriSReacH(*args):
        """
        Returns h_mu, the distinct number of ways in which surface reaction with identifier 
        string sreac can occur in triangular element with index idx, by computing the product 
        of its reactants. 

        Syntax::
            
            getTriSReacH(idx, reac)
            
        Arguments:
            * uint idx
            * string reac

        Return:
           float

        """
        return _solver_swig.API_getTriSReacH(*args)

    def getTriSReacA(*args):
        """
        Returns the propensity of surface reaction with identifier string sreac 
        in triangular element with index idx. 

        Syntax::
            
            getTriSReacA(idx, reac)
            
        Arguments:
            * uint idx
            * string reac

        Return:
           float

        """
        return _solver_swig.API_getTriSReacA(*args)

API_swigregister = _solver_swig.API_swigregister
API_swigregister(API)

class Wmrk4(API):
    """Proxy of C++ Wmrk4 class"""
    __swig_setmethods__ = {}
    for _s in [API]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Wmrk4, name, value)
    __swig_getmethods__ = {}
    for _s in [API]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Wmrk4, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, steps::model::Model m, steps::wm::Geom g, steps::rng::RNG r) -> Wmrk4"""
        this = _solver_swig.new_Wmrk4(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _solver_swig.delete_Wmrk4
    __del__ = lambda self : None;
    def getSolverName(*args):
        """
        Returns a string of the solver's name.

        Syntax::
            
            getSolverName()
            
        Arguments:
            None

        Return:
            string

        """
        return _solver_swig.Wmrk4_getSolverName(*args)

    def getSolverDesc(*args):
        """
        Returns a string giving a short description of the solver.

        Syntax::
            
            getSolverDesc()
            
        Arguments:
            None

        Return:
            string

        """
        return _solver_swig.Wmrk4_getSolverDesc(*args)

    def getSolverAuthors(*args):
        """
        Returns a string of the solver authors names.

        Syntax::
            
            getSolverAuthors()
            
        Arguments:
            None

        Return:
            string

        """
        return _solver_swig.Wmrk4_getSolverAuthors(*args)

    def getSolverEmail(*args):
        """
        Returns a string giving the author's email address.

        Syntax::
            
            getSolverEmail()
            
        Arguments:
            None

        Return:
            string

        """
        return _solver_swig.Wmrk4_getSolverEmail(*args)

    def reset(*args):
        """
        Reset the simulation to the state the solver was initialised to. 
        Typically, this resets all concentrations of all chemical species in 
        all elements (whether compartments and patches in a well-mixed solver 
        or tetrahedrons and triangles in a mesh-based solver) to zero, 
        resets the simulation time to zero and resets reaction (and diffusion) 
        rates to the default values described in the steps.model objects. 
        All reaction (and diffusion) rules are reset to active and all 
        compartment volumes and patch areas are reset to default values 
        described in steps.geom objects (for well-mixed solvers). 
        Usually, this method should be called before starting each simulation iteration.

        Syntax::
            
            reset()
            
        Arguments:
            None

        Return:
            None

        """
        return _solver_swig.Wmrk4_reset(*args)

    def run(*args):
        """
        Advance the simulation until endtime (given in seconds) is reached. 
        The endtime must be larger or equal to the current simulation time.

        Syntax::
            
            run(endtime)
            
        Arguments:
            float endtime

        Return:
            None

        """
        return _solver_swig.Wmrk4_run(*args)

    def getTime(*args):
        """
        Returns the current simulation time in seconds.

        Syntax::
            
            getTime()
            
        Arguments:
            None

        Return:
            float

        """
        return _solver_swig.Wmrk4_getTime(*args)

Wmrk4_swigregister = _solver_swig.Wmrk4_swigregister
Wmrk4_swigregister(Wmrk4)

class Wmdirect(API):
    """Proxy of C++ Wmdirect class"""
    __swig_setmethods__ = {}
    for _s in [API]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Wmdirect, name, value)
    __swig_getmethods__ = {}
    for _s in [API]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Wmdirect, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, steps::model::Model m, steps::wm::Geom g, steps::rng::RNG r) -> Wmdirect"""
        this = _solver_swig.new_Wmdirect(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _solver_swig.delete_Wmdirect
    __del__ = lambda self : None;
    def getSolverName(*args):
        """
        Returns a string of the solver's name.

        Syntax::
            
            getSolverName()
            
        Arguments:
            None

        Return:
            string

        """
        return _solver_swig.Wmdirect_getSolverName(*args)

    def getSolverDesc(*args):
        """
        Returns a string giving a short description of the solver.

        Syntax::
            
            getSolverDesc()
            
        Arguments:
            None

        Return:
            string

        """
        return _solver_swig.Wmdirect_getSolverDesc(*args)

    def getSolverAuthors(*args):
        """
        Returns a string of the solver authors names.

        Syntax::
            
            getSolverAuthors()
            
        Arguments:
            None

        Return:
            string

        """
        return _solver_swig.Wmdirect_getSolverAuthors(*args)

    def getSolverEmail(*args):
        """
        Returns a string giving the author's email address.

        Syntax::
            
            getSolverEmail()
            
        Arguments:
            None

        Return:
            string

        """
        return _solver_swig.Wmdirect_getSolverEmail(*args)

    def reset(*args):
        """
        Reset the simulation to the state the solver was initialised to. 
        Typically, this resets all concentrations of all chemical species in 
        all elements (whether compartments and patches in a well-mixed solver 
        or tetrahedrons and triangles in a mesh-based solver) to zero, 
        resets the simulation time to zero and resets reaction (and diffusion) 
        rates to the default values described in the steps.model objects. 
        All reaction (and diffusion) rules are reset to active and all 
        compartment volumes and patch areas are reset to default values 
        described in steps.geom objects (for well-mixed solvers). 
        Usually, this method should be called before starting each simulation iteration.

        Syntax::
            
            reset()
            
        Arguments:
            None

        Return:
            None

        """
        return _solver_swig.Wmdirect_reset(*args)

    def run(*args):
        """
        Advance the simulation until endtime (given in seconds) is reached. 
        The endtime must be larger or equal to the current simulation time.

        Syntax::
            
            run(endtime)
            
        Arguments:
            float endtime

        Return:
            None

        """
        return _solver_swig.Wmdirect_run(*args)

    def getTime(*args):
        """
        Returns the current simulation time in seconds.

        Syntax::
            
            getTime()
            
        Arguments:
            None

        Return:
            float

        """
        return _solver_swig.Wmdirect_getTime(*args)

Wmdirect_swigregister = _solver_swig.Wmdirect_swigregister
Wmdirect_swigregister(Wmdirect)

class Tetexact(API):
    """Proxy of C++ Tetexact class"""
    __swig_setmethods__ = {}
    for _s in [API]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Tetexact, name, value)
    __swig_getmethods__ = {}
    for _s in [API]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Tetexact, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, steps::model::Model m, steps::wm::Geom g, steps::rng::RNG r) -> Tetexact"""
        this = _solver_swig.new_Tetexact(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _solver_swig.delete_Tetexact
    __del__ = lambda self : None;
    def getSolverName(*args):
        """
        Returns a string of the solver's name.

        Syntax::
            
            getSolverName()
            
        Arguments:
            None

        Return:
            string

        """
        return _solver_swig.Tetexact_getSolverName(*args)

    def getSolverDesc(*args):
        """
        Returns a string giving a short description of the solver.

        Syntax::
            
            getSolverDesc()
            
        Arguments:
            None

        Return:
            string

        """
        return _solver_swig.Tetexact_getSolverDesc(*args)

    def getSolverAuthors(*args):
        """
        Returns a string of the solver authors names.

        Syntax::
            
            getSolverAuthors()
            
        Arguments:
            None

        Return:
            string

        """
        return _solver_swig.Tetexact_getSolverAuthors(*args)

    def getSolverEmail(*args):
        """
        Returns a string giving the author's email address.

        Syntax::
            
            getSolverEmail()
            
        Arguments:
            None

        Return:
            string

        """
        return _solver_swig.Tetexact_getSolverEmail(*args)

    def reset(*args):
        """
        Reset the simulation to the state the solver was initialised to. 
        Typically, this resets all concentrations of all chemical species in 
        all elements (whether compartments and patches in a well-mixed solver 
        or tetrahedrons and triangles in a mesh-based solver) to zero, 
        resets the simulation time to zero and resets reaction (and diffusion) 
        rates to the default values described in the steps.model objects. 
        All reaction (and diffusion) rules are reset to active and all 
        compartment volumes and patch areas are reset to default values 
        described in steps.geom objects (for well-mixed solvers). 
        Usually, this method should be called before starting each simulation iteration.

        Syntax::
            
            reset()
            
        Arguments:
            None

        Return:
            None

        """
        return _solver_swig.Tetexact_reset(*args)

    def run(*args):
        """
        Advance the simulation until endtime (given in seconds) is reached. 
        The endtime must be larger or equal to the current simulation time.

        Syntax::
            
            run(endtime)
            
        Arguments:
            float endtime

        Return:
            None

        """
        return _solver_swig.Tetexact_run(*args)

    def getTime(*args):
        """
        Returns the current simulation time in seconds.

        Syntax::
            
            getTime()
            
        Arguments:
            None

        Return:
            float

        """
        return _solver_swig.Tetexact_getTime(*args)

Tetexact_swigregister = _solver_swig.Tetexact_swigregister
Tetexact_swigregister(Tetexact)



